<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习10——自定义Gradle插件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习10——自定义Gradle插件/" itemprop="url">Gradle学习10——自定义Gradle插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:10+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>Gradle插件分为两类：</p>
<ul>
<li>脚本插件，是一个普通的Gradle构建脚本，它可以被导入到其它的构建脚本中。</li>
<li>对象插件，需要实现<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Plugin.html" target="_blank" rel="noopener">org.gradle.api.Plugin</a>接口。</li>
</ul>
<h1 id="使用脚本插件"><a href="#使用脚本插件" class="headerlink" title="使用脚本插件"></a>使用脚本插件</h1><p>假设我们有一个脚本名为 sayhello.gradle ，它里面有一个task：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task sayHello &lt;&lt; &#123;</span><br><span class="line">	println &apos;hello world&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在build.gradle 中依赖这个外部脚本，调用<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a>的apply方法，apply方法调用时传入from属性，它的值可以是任何类型的URL，比如HTTP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &apos;sayhello.gradle&apos;</span><br></pre></td></tr></table></figure>
<p>此时我们运行<code>gradle sayHello</code> 命令，可以看到sayHello 这个task执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sayHello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>通过apply from的方式引入脚本插件，就好像那个脚本插件中的内容是写在当前的build.gradle中一样。它是使用比较简单，这里就不多做介绍了。</p>
<h1 id="对象插件"><a href="#对象插件" class="headerlink" title="对象插件"></a>对象插件</h1><p>我们之前讲了自定义的task，它的实现逻辑是一种可维护、可测试的解决方案。通过打包成jar文件，task可以在独立的项目中被重用。然而，该方式仍有一些限制。<br>优点：</p>
<ul>
<li>定制逻辑在类中是自包含的，并且可以通过增强型task配置</li>
<li>通过将task属性用注解标志可以支持声明式增量构建</li>
<li>自定义的task可以测试</li>
</ul>
<p>缺点：</p>
<ul>
<li>自定义的task仅仅暴露独立的工作单元。所提供的额外的公式化代码、约定和生命周期的整合并不是很直接</li>
<li>自定义的task仅仅能通过增强型task来配置。通过自定义的DSL，缺乏有表达性的扩展机制</li>
<li>其他插件的功能不容易使用或扩展</li>
</ul>
<p>而使用对象插件的方式，可以给你最大的灵活性去封装高复杂度的逻辑，并且提供一种强大的扩展机制可以在构建脚本中定制它的行为。比如编译Java代码，我们会通过一句话来引入Java插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin :&apos;java&apos;</span><br></pre></td></tr></table></figure>
<p>然后我们还可以配置很多属性来控制编译逻辑。这个Java插件就是一个对象插件。</p>
<h1 id="对象插件的实现方式"><a href="#对象插件的实现方式" class="headerlink" title="对象插件的实现方式"></a>对象插件的实现方式</h1><p>对于实现一个对象插件，有4个基本元素是非常重要的。</p>
<ol>
<li><p>在放置插件实现的位置方面Gradle给你完全的灵活性。代码可以放在构建脚本中或者buildSrc目录下，也可以作为一个独立的工程被开发并且以jar文件方式发布。</p>
</li>
<li><p>每个插件都需要提供一个实现类，它代表着插件的入口点。插件可以用任何JVM语言编写并编译成字节码。</p>
</li>
<li><p>应用到项目中的插件可以通过暴露出来的扩展对象进行定制。如果用户想要在构建脚本中覆盖插件的默认配置时，这一点特别有用。</p>
</li>
<li><p>插件描述符是一个属性文件，它包含了关于插件的元信息。通常，它包含有插件的简短名字和插件实现类的映射。</p>
</li>
</ol>
<h1 id="编写对象插件"><a href="#编写对象插件" class="headerlink" title="编写对象插件"></a>编写对象插件</h1><p>编写一个插件最低的要求是提供<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Plugin.html" target="_blank" rel="noopener">org.gradle.api.Plugin<t></t></a>接口的一个实现类。该接口仅仅定义了一个简单的方法：apply(T target)。</p>
<p>现在我们来演示自定义一个插件，这个插件的作用是提供一个task来打印用户凭证。<br>我们前面已经提到，自定义对象插件和自定义task方式类似，代码可以放在构建脚本中或者buildSrc目录下，也可以作为一个独立的工程被开发并且以JAR文件方式发布，下面我们根据这三种方式来分别演示如何自定义和使用插件。</p>
<h2 id="放在构建脚本中"><a href="#放在构建脚本中" class="headerlink" title="放在构建脚本中"></a>放在构建脚本中</h2><p>在build.gradle中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:CredentialPlugin</span><br><span class="line"></span><br><span class="line">userCredential&#123;</span><br><span class="line">	username=&apos;admin&apos;</span><br><span class="line">	password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CredentialPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	void apply(Project project)&#123;</span><br><span class="line">		project.extensions.create(&apos;userCredential&apos;,CredentialExtension)</span><br><span class="line">		project.tasks.create(&apos;printUserCredential&apos;) &lt;&lt; &#123;</span><br><span class="line">			 println &quot;username is: &quot; + project.userCredential.username</span><br><span class="line">			 println &quot;password is: &quot; + project.userCredential.password</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展模型</span><br><span class="line">class CredentialExtension &#123;</span><br><span class="line">	String username</span><br><span class="line">	String password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gradle将语言结构化模型作为扩展，扩展可以被添加到许多Gradle对象中，如果一个类实现了<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/plugins/ExtensionAware.html" target="_blank" rel="noopener">org.gradle.api.plugins.ExtensionAware</a>接口，比如Project或者Task，就认为它是扩展可知的。每个扩展都是一个数据模型，它是扩展的基础。这个模型可以是一个POJO或者Groovy Bean。<br>在上面的代码中，userCredential闭包中的内容，可以从构建脚本中给task提供所需要的属性值，这个userCredential就是我们暴露的一个DSL。<br>ExtensionAware对象有一个方法getExtensions()，该方法返回一个<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/plugins/ExtensionContainer.html" target="_blank" rel="noopener">ExtensionContainer</a>对象，ExtensionContainer对象可以通过create()方法来注册我们的扩展，也就是把我们配置的DSL和具体的类关联起来。在本例中就是把userCredential这个闭包和CredentialExtension这个类关联起来，这就是插件的扩展机制。</p>
<blockquote>
<p>扩展对象vs额外属性  被用来扩展一个对象的DSL的扩展是扩展可知的，一个已注册的扩展模型会暴露一些属性和方法，用来给构建脚本建立新的构建语言结构，这些属性名和方法在创建的时候已经定好。扩展模型的典型用例是插件。额外属性，是一些通过ext命名空间创建的简单变量，它们一般提供给用户空间也就是构建脚本使用，额外属性的属性名是可以任意指定的。请尽量避免在插件实现中使用额外属性。</p>
</blockquote>
<h2 id="放在buildSrc目录下"><a href="#放在buildSrc目录下" class="headerlink" title="放在buildSrc目录下"></a>放在buildSrc目录下</h2><p>与自定义task一样，Groovy代码放在buildSrc/src/main/groovy 目录下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen.credential</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">class CredentialPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	void apply(Project project)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.sososeen.credential</span><br><span class="line">class CredentialExtension &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在与buildSrc同级的目录下，创建build.gradle脚本，引入这个plugin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:com.sososeen.credential.CredentialPlugin</span><br><span class="line">userCredential&#123;</span><br><span class="line">	username=&apos;admin&apos;</span><br><span class="line">	password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>gradle printUserCredential</code> 命令，可以看到打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:printUserCredential</span><br><span class="line">username is: admin</span><br><span class="line">password is: 000000</span><br></pre></td></tr></table></figure>
<p>可以看到，我们引入这个插件的时候是把它的包名带类名写上了，这显得太长了，不好写。我们可以给这个插件一个有意义且精简的名字。在src/main/resources/META-INF/gradle-plugins目录下，我们可以创建一个属性文件来配置。比如创建一个credentials.properties，它就是一个插件描述符，暴露了插件名字是credentials。在这个文件中，将该插件类的全局类名赋值给键implemention-class，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class = com.sososeen.credential.CredentialPlugin</span><br></pre></td></tr></table></figure>
<p>然后应用插件就可以这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin : &apos;credentials&apos;</span><br></pre></td></tr></table></figure>
<p>执行  <code>gradle printUserCredential</code> 命令，可以看到打印结果与之前一样。</p>
<p>目录结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-0a93dc30b128b3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buildSrc目录结构"></p>
<blockquote>
<p>有一点需要说明，Gradle可以用驼峰式的缩写在命令行上运行任务。但要保证缩写是唯一的。比如我们执行<code>gradle printUserCredential</code>，实际上可以缩写为<code>gradle pUC</code>，这对于任务名称比较长的时候特别有用，感兴趣的可以试一下。</p>
</blockquote>
<h2 id="以jar文件形式提供插件"><a href="#以jar文件形式提供插件" class="headerlink" title="以jar文件形式提供插件"></a>以jar文件形式提供插件</h2><p>这个步骤与自定义task打包为jar文件一样，新建一个项目，把buildSrc目录下的文件复制过来，同时，在该项目下创建一个build.gradle文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos; //应用这个插件来编译Groovy代码</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line">version = &apos;1.0&apos;</span><br><span class="line">group = &apos;com.sososeen09&apos;</span><br><span class="line">archivesBaseName = &apos;credential&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // 使用Gradle中的API需要这个</span><br><span class="line">    compile gradleApi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: &quot;file:../lib&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行gradle uploadArchives命令后就可以看到，在与当前项目同级的lib文件目录中生成了我们期望的jar文件。</p>
<p>我们再新建一个工程，这个工程中有一个脚本文件build.gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply plugin : &apos;credentials&apos;</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;file:../lib&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.sososeen09:credential:1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userCredential&#123;</span><br><span class="line">    username=&apos;admin&apos;</span><br><span class="line">    password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行  <code>gradle printUserCredential</code> 命令，可以看到打印结果与之前一样。</p>
<p>目录结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-e7b763635d2f8fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以jar包形式提供依赖"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Gradle提供了一个丰富的插件生态系统来重用哪些开箱即用的标准插件和由社区提供的第三方插件。有两种类型的插件：脚本插件和对象插件。</p>
<p>脚本插件是一种普通的Gradle构建脚本，它可以完全访问Gradle的API。编写一个脚本插件是非常简单的，降低了分享代码的难度。可以通过URL被另一个项目使用。</p>
<p>对象插件通常包含更为复杂的逻辑，需要适当的包和类。每个对象插件的入口点都是Pulgin接口，它提供了一种直接的方式来访问Gradle的Project模型。通过将对象插件添加到构建脚本的classpath下，许多对象插件都可以在多个独立的项目中使用，可以被打包成jar文件，发布到仓库中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习9——多项目构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习9——多项目构建/" itemprop="url">Gradle学习9——多项目构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:09+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>为了提高可维护性和防止紧密耦合，可以基于特定的功能和逻辑将代码写在不同的模块中。模块通常具有层次结构而且可以定义为相互依赖。Gradle对构建多模块项目提供了强大的支持，Gradle中的每一模块都是一个项目，我们称之为多项目构建。</p>
<blockquote>
<p>注意：在Android Studio中，一个模块和一个项目是有区别的。一个项目包含多个模块module。而Android Studio中的每一个module对应的是Gradle多项目构建中的一个项目</p>
</blockquote>
<p>在多项目构建中，settings文件声明了所需的配置来实例化项目的层次结构。在默认情况下，这个文件被命名为settings.gradle，并且和根项目的build.gradle 文件放在一起。settings.gradle脚本的执行是在构建生命周期的初始化阶段。Gradle组装构建之前会创建一个<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/initialization/Settings.html" target="_blank" rel="noopener">Settings</a>类型的实例。Settings接口是settings文件的直接表示。若想使每个子项目都称为构建的一部分，则可以调用Settings接口中带有项目路径参数的include方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootProject</span><br><span class="line">      |———— settings.gradle</span><br><span class="line">      |———— build.gradle</span><br><span class="line">      |———— sub_project1</span><br><span class="line">      |            |———— build.gradle</span><br><span class="line">      |———— sub_project2</span><br><span class="line">      |            |———— build.gradle</span><br></pre></td></tr></table></figure>
<p>在settings.gradle中要声明当前项目包含的子项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:sub_project1&apos;, &apos;sub_project2&apos;</span><br></pre></td></tr></table></figure>
<p>注意：传给include方法的参数是项目路径，不是文件路径。该项目路径是相对于根目录的项目目录。也可以构建更深层次的项目结构。使用冒号(:)字符来分隔每一个子项目的层次结构。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:subs:sub_project1&apos;</span><br></pre></td></tr></table></figure>
<p>有时候，想要为所有的项目或只有子项目定义一些公共的行为。为实现这些用力，<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a> API提供了两个专门的方法：allprojects和subprojects。<br>在根目录中的build.gradle中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">	task allTaskHello &lt;&lt;&#123;</span><br><span class="line">		println &quot;hello from $&#123;project.name&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置在allprojects 这个闭包下的所有内容对根项目和子项目都有效。<br>在根目录下执行<code>gradle  allTaskHello</code> 命令，可以看到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:allTaskHello</span><br><span class="line">hello from rootProject</span><br><span class="line"></span><br><span class="line">:sub_project1:allTaskHello</span><br><span class="line">hello from sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project2:allTaskHello</span><br><span class="line">hello from sub_project2</span><br></pre></td></tr></table></figure>
<p>在根目录中的build.gradle中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">	task subTaskHello &lt;&lt;&#123;</span><br><span class="line">		println &quot;hello from sub project $&#123;project.name&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置在subprojects 这个闭包下的所有内容只对子项目都有效，对根项目无效。<br>在根目录下执行<code>gradle subTaskHello</code> 命令，可以看到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:subTaskHello</span><br><span class="line">hello from sub project sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project2:subTaskHello</span><br><span class="line">hello from sub project sub_project2</span><br></pre></td></tr></table></figure>
<p>如果进入到子项目目录下执行gradle命令，只会对当前的这个子项目有效。比如进入sub_project1这个子项目中，执行<code>gradle  subTaskHello</code>命令，结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:subTaskHello</span><br><span class="line">hello from sub project sub_project1</span><br></pre></td></tr></table></figure>
<p><strong>默认的task执行顺序</strong></p>
<p>如果task没有声明依赖另一个task，在多项目构建中位于根目录的task总是先执行。对于子项目来说，执行顺序完全取决于项目名称的字母顺序。例如，sub_project1在sub_project2之前。记住，在settings文件中子项目的声明顺序完全不影响其执行顺序。</p>
<p><strong>单独定义特定的行为</strong></p>
<p>前面我们讲的，都是在allprojects和subprojects中进行的定义，实际上我们在根目录下的build.gradle中也可以对每一个项目进行单独的定义。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project(&apos;:sub_project1&apos;)&#123;</span><br><span class="line">	task forSub1 &lt;&lt;&#123;</span><br><span class="line">		println &apos;this is only for sub_project1 task&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle forSub1</code>命令，可以看到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:forSub1</span><br><span class="line">this is only for sub_project1 task</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记住：在根目录下的build.gradle中执行task，Gradle会在所有拥有该task的project上执行该task。</p>
</blockquote>
<p><strong>属性继承</strong></p>
<p>属性继承，在一个根项目中定义的属性会自动的被其子项目继承，也就是说子项目中也可以用到这些属性，例如我们在根项目中声明一个扩展属性projectInfo，对于根项目和子项目都是可用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext.projectInfo=[&apos;group&apos;:&apos;com.sososeen09&apos;,&apos;version&apos;:&apos;0.1&apos;]</span><br><span class="line"></span><br><span class="line">group = projectInfo.group</span><br><span class="line">version = projectInfo.version</span><br><span class="line">project(&apos;:sub_project1&apos;)&#123;</span><br><span class="line">	group = projectInfo.group</span><br><span class="line">    version = projectInfo.version</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project(&apos;:sub_project2&apos;)&#123;</span><br><span class="line">	group = projectInfo.group</span><br><span class="line">    version = projectInfo.version</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>项目之间的依赖</strong></p>
<p>多项目之间一般不会是毫无关联的，可能会存在依赖关系。比如sub-project1中有taskA和taskB，taskA依赖于taskB，而taskB依赖于sub_project2中的taskC。到目前为止，我们把子项目中的属性和任务都放在根目录下的build.gradle中声明，现在是时候在它们各自的build.gradle中是声明自己的任务了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//sub_project1 中</span><br><span class="line">task taskA &lt;&lt; &#123;</span><br><span class="line">	println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task taskB &lt;&lt; &#123;</span><br><span class="line">	println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskA.dependsOn taskB</span><br><span class="line">taskB.dependsOn &apos;:sub_project2:taskC&apos;</span><br><span class="line"></span><br><span class="line">//sub_project2 中</span><br><span class="line">task taskC &lt;&lt; &#123;</span><br><span class="line">	println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分析一下，taskA 依赖taskB ，所以taskA执行之前，taskB必须先执行；而taskB又依赖于sub_project2中的taskC，所以taskB执行前，taskC必须先执行。<br>现在执行 <code>gradle taskA</code>命令，可以看到结果跟我们的分析一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:sub_project2:taskC</span><br><span class="line">this is taskC from sub_project2</span><br><span class="line"></span><br><span class="line">:sub_project1:taskB</span><br><span class="line">this is taskB from sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project1:taskA</span><br><span class="line">this is taskA from sub_project1</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">下一篇</a>，我们开始学习自定义Gradle插件，这是本系列的最后一篇，也是一个非常重要的部分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习8——依赖管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习8——依赖管理/" itemprop="url">Gradle学习8——依赖管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:08+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>依赖管理是Gradle非常棒的一个功能，很多情况下，你只需要在构建文件中添加一行代码，Gradle就会从远程仓库中下载依赖，在项目中就可以使用依赖中的类。如果你所依赖的这个库本身也有它自己的依赖，Gradle会处理并解决这些问题，这些依赖中的依赖，被称作传递性依赖。</p>
<p>Gradle使用 dependencies 这个DSL来定义构建所依赖的类库，使用repositories 来告诉构建从哪里获取依赖，当你配置好后，Gradle会自动下载依赖，并存储在本地缓存中，在构建中使用它们，一个特定版本的依赖只会在你的机器上下载一次。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.jsoup:jsoup:1.9.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gradle支持三种不同的依赖仓库：Maven、Ivy和静态文件或文件夹。一个依赖通常由三种元素定义的，可以称呼它们为依赖属性。</p>
<ul>
<li>group：通常标识一个组织、公司或者项目。如org.jsoup</li>
<li>name:一个工件的名称唯一的描述了依赖。如：:jsoup</li>
<li>version：一个类库的版本号。如1.9.2</li>
</ul>
<p>上面的dependencies，也可以使用map形式包含group、name、version属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group:&apos;org.jsoup&apos;, name:&apos;jsoup&apos;, version:&apos;1.9.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于依赖来说，唯一需要的字段是name。group和version都是可选的元素。尽管如此，为了表述清楚，建议添加group，而version可确保依赖库不会自动更新。</p>
</blockquote>
<h1 id="使用和配置仓库"><a href="#使用和配置仓库" class="headerlink" title="使用和配置仓库"></a>使用和配置仓库</h1><p>为了方便，Gradle预定义了三个Maven仓库：</p>
<ul>
<li>Jcenter</li>
<li>Maven Central</li>
<li>本地Maven仓库</li>
</ul>
<p>Gradle使用Maven Central仓库就是调用mavenCentral()方法，其它两个仓库的使用也类似。为了在构建脚本中包含它们，你需要这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    mavenCentral()</span><br><span class="line">    mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Maven Central 和JCenter是两个有名的远程仓库，一般不同时使用它们，通常推荐使用JCenter，它是Maven Central的超集，其也是Android Studio创建Android项目时的默认依赖仓库，而且JCenter还支持HTTPS。</p>
<p>本地Maven仓库是你已经使用了的所有依赖的本地缓存，你也可以自己添加依赖。默认情况下，依赖仓库可以在一个名为.m2目录文件夹的主目录中找到。在Linux或Mac OS X上，该路径是~/.m2，在Windows上路径是%UserProfile%/.m2。<br>除了这些预定义的依赖仓库，你也可以添加其它的公有或私有仓库，可以指定一个任意的Maven或者Ivy仓库的URL并且配置来使用身份验证，或者可以使用简单的文件系统仓库来解决依赖关系。</p>
<p>在项目中定义仓库的关键是<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/dsl/RepositoryHandler.html" target="_blank" rel="noopener">RepositoryHandler</a>接口，它提供了添加各种类型仓库的方法。从项目上看，这些方法在repositories配置块中被调用。</p>
<p>可以声明多个仓库，下载依赖的时候按照声明的顺序来检查仓库，仓库提供了依赖优先原则，对于特定的依赖后续的仓库声明不会被进一步检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs &apos;libs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gradle API 支持两种方式来配置一个自定义仓库：maven()和mavenRepo()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        name &apos;Custom Maven Repository&apos;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用Ivy仓库，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些Maven仓库的访问需要凭证，那么可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">        credentials&#123;</span><br><span class="line">            username &apos;user&apos;</span><br><span class="line">            password &apos;secretPassword&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不建议在构建配置文件中存储凭证，最好是在本地一个单独的未纳入版本控制系统的属性文件存储凭证</p>
</blockquote>
<p><strong>扁平的目录仓库</strong></p>
<p>flat目录是最简单和最基本的仓库形式。在文件系统中它是一个单独的目录，只包含jar文件或者Android 库中的aar类型的文件，没有maven元数据。<br>当声明依赖时，你只能使用name和versin属性，不能使用group属性，因为它会导致产生不明确的依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile name: &apos;jsoup&apos;, version: &apos;1.9.2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir&#123;</span><br><span class="line">        dirs &apos;flatlibs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h1><p>某些情况下，你可能仍然需要使用手动下载的jar文件或原生库。<br>你可以使用Gradle提供的files方法来添加jar文件作为一个依赖，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">	compile files(&apos;libs/jsoup.jar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果jar文件很多，我们一个一个的这样依赖太繁琐，就可以一次添加一个完成的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">	compile fileTree(&apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Android Studio中创建Android项目的时候，新建的Android项目会有一个libs文件夹，其会被声明为依赖的文件夹，并且通过过滤只依赖jar文件，而不是所有的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">	compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原生依赖</strong></p>
<p>如果想要使用C或C++编译的原生依赖库.so文件，需要指明jniLibs的目录。假设.so文件也都放置在libs目录下，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-685e209dd721faf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在脚本文件中就需要这么配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>依赖项目</strong></p>
<p>如果在项目中创建了一个模块作为依赖项目，那么需要在settings.gradle中添加该模块，然后在应用模块中使用它作为依赖。比如，在Android项目中，app模块是我们的主模块，library模块是依赖模块，也称作依赖库。<br>settings.gradle 中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos; ,&apos; : library&apos;</span><br></pre></td></tr></table></figure>
<p>app模块下的build.gradle中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">	compile project(&apos;:library&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用.aar文件</strong></p>
<p>当你已经把aar文件放置在libs目录下或者其他的扁平文件目录下，添加aar文件作为依赖可以这么操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(name: &apos;libraryname&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure>
<p>这样就告知Gradle查找具有特定名称切扩展名为.aar的依赖库</p>
<h1 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h1><p>前面我们讲了添加依赖库的时候，前面都要有一个compile。其实这个compile就是一个配置Configuration。<br>Gradle根据配置对依赖进行分组，比如编译Java时使用的是这组依赖，运行Java时又可以使用另一组依赖。每一组依赖称为一个Configuration，在声明依赖时，我们实际上是在设置不同的Configuration。<br>Java插件提供了6个现成的配置：compile、runtime、testCompile、testRuntime、archives、default。<br>而在Android中的插件也提供了几个标准配置：compile、apk、provided、testCompile、androidTestCompile。<br>compile 是默认的配置，在编译主应用时包含所有的依赖，不禁会将依赖添加至类路径，还会生成对应的apk。<br>如果依赖使用apk配置，则该依赖只会被打包到apk，而不会被添加到编译类路径。<br>provided配置与apk配置相反，只在编译的时候用到，其依赖不会被打包进apk。<br>testCompile、androidTestCompile配置会添加用于测试的额外依赖库，在运行测试相关的任务时会被用到。比如添加JUnit或者Espresso测试框架。</p>
<p>要自定义一个配置Configuration，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    myConfiguration &#123;</span><br><span class="line">        description = &apos;this is  my configuration&apos;</span><br><span class="line">        visible = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在自定义配置的时候，同时定义了该配置的一些属性，description表示的是该配置的描述信息，visiable表示该配置是否可以在该Project之外可见，默认是true。还可以定义其它的属性，具体可参考<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/Configuration.html" target="_blank" rel="noopener">Configuration</a>这个类。当然，你也可以什么都不写。configurations对应的Gradle的Api中<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/ConfigurationContainer.html" target="_blank" rel="noopener">ConfigurationContainer
</a>这个类。</p>
<p>以上只是定义了一个名为myConfiguration的配置，我们并未向其中加入依赖。可以通过dependencies()方法向myConfiguration中加入实际的依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   myConfiguration &apos;org.jsoup:jsoup:1.9.2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>gradle dependencies</code> 这个帮助task，会显示当前的依赖树。此时可以看到我们在myConfiguration这个配置中依赖的库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myConfiguration - this is  my configuration</span><br><span class="line">\--- org.jsoup:jsoup:1.9.2</span><br></pre></td></tr></table></figure>
<p>由于我们只依赖了一个库，所以依赖树看着很简洁。如果依赖很多库，而这些依赖库又都有传递性依赖，就有可能发生依赖冲突。如果存在依赖冲突，在默认情况下，Gradle会选择最新版本，这和Maven是不同的，Maven会选择离依赖树最近的版本。如果你需要更改默认的冲突解决策略，可以自行搜索相关内容，本文就不多做介绍了。</p>
<p>使用Gradle API可以找到Gradle依赖的缓存文件放置的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printDependencies &lt;&lt; &#123;</span><br><span class="line">    configurations.getByName(&apos;myConfiguration&apos;).each &#123; dependency -&gt;</span><br><span class="line">        println dependency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle printDependencies</code> 命令，可以看到打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :printDependencies</span><br><span class="line">/Users/jason/.gradle/caches/modules-2/files-2.1/org.jsoup/jsoup/1.9.2/5e3bda828a80c7a21dfbe2308d1755759c2fd7b4/jsoup-1.9.2.jar</span><br></pre></td></tr></table></figure>
<h1 id="动态版本声明"><a href="#动态版本声明" class="headerlink" title="动态版本声明"></a>动态版本声明</h1><p>如果想使用最新版本的依赖，可以使用占位符 latest.integration 。例如 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jsoup:jsoup:latest-integration</span><br></pre></td></tr></table></figure>
<p>或者，声明版本属性，通过使用一个加号(+) 标定它来动态改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jsoup:jsoup:1.+</span><br></pre></td></tr></table></figure>
<p>当然了，我们最好是少用或者不用动态版本声明。</p>
<p><a href="http://www.jianshu.com/p/62c1f3ca380c" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中的多项目构建。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习7——编写和使用自定义Task/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习7——编写和使用自定义Task/" itemprop="url">Gradle学习7——编写和使用自定义Task</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:07+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>自定义task包含两个组件：</p>
<ul>
<li>自定义的task类，封装了逻辑行为，也被称作任务类型</li>
<li>真实的task，提供了用于配置行为的task类所暴露的属性值。Gradle把这些task称为增强的task。</li>
</ul>
<p>可维护性是编写自定义task类的优势之一。增强的task的另一个优势是可重用性。自定义task所暴露的属性可以在构建脚本中进行单独设置。</p>
<p>我们还是按照之前的例子，修改配置文件中的release 参数。</p>
<h1 id="自定义task类"><a href="#自定义task类" class="headerlink" title="自定义task类"></a>自定义task类</h1><p>前面已经提到，Gradle为构建脚本中每个简单的task都创建了一个DefaultTask类型的实例。我们现在创建一个ReleaseVersionTask，它的作用是把目标文件中的release变为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ReleaseVersionTask extends DefaultTask&#123;</span><br><span class="line">  @Input Boolean release</span><br><span class="line">  @OutputFile File destFile</span><br><span class="line"></span><br><span class="line">  ReleaseVersionTask()&#123;</span><br><span class="line">    group=&apos;versioning&apos;</span><br><span class="line">    description=&apos;Makes project a release version.&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @TaskAction</span><br><span class="line">  void start()&#123;</span><br><span class="line">    project.version.release=true;</span><br><span class="line">    ant.propertyfile(file:destFile)&#123;</span><br><span class="line">       entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过org.gradle.api.tasks包下的注解可以用来声明输入输出属性。</p>
<blockquote>
<p>task输入验证 @Input注解会在配置期间验证属性值。如果值为null，Gradle会抛出TaskValidationException异常。为了允许输入为null值，可以给它添加@Optional注解。</p>
</blockquote>
<h1 id="使用自定义task"><a href="#使用自定义task" class="headerlink" title="使用自定义task"></a>使用自定义task</h1><p>我们自定义的task类是没有办法自己执行的，要使用和配置自定义task类定义的行为和属性，需要创建一个增强型的task。该task定义了它要使用的task类型，在本例中我们定义一个增强型taskmakeReleaseVersion，它使用的task类型是ReleaseVersionTask，通过为它的属性赋值来设置输入和输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(type:ReleaseVersionTask)&#123;</span><br><span class="line">// 设置自定义task属性</span><br><span class="line">    release = version.release</span><br><span class="line">    destFile = versionFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>gradle makeReleaseVersion</code> 命令 ，会发现增强型的makeReleaseVersion task与之前的<a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">文章</a>中简单的task的运行结果表现完全一致。<br>与简单的task实现相比，增强型task的一个巨大优势在于所暴露的属性可以被单独赋值。</p>
<p>比如，ProjectVersion 中的release字段名改为了prodReady，属性文件改名为 project-version.properties。<br>那么makeReleaseVersion task可以这样设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(type:ReleaseVersionTask)&#123;</span><br><span class="line">    release = version.prodReady</span><br><span class="line">    destFile =file(&apos;project-version.properties&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在buildSrc目录下构建代码"><a href="#在buildSrc目录下构建代码" class="headerlink" title="在buildSrc目录下构建代码"></a>在buildSrc目录下构建代码</h1><p>我们可以把ReleaseVersionTask这个类单独放在一个Groovy文件中，这样就可以在其它地方通过导包的方式来重用这个类。<br>在一个项目工程当中，创建的Groovy类适合被移动到项目的buildSrc目录下。Gradle在buildSrc目录下使源文件结构标准化。Groovy代码放在src/main/groovy目录下，对于Java文件则是放置在src/main/java目录下面。位于这些目录下的文件会被自动编译，并且都加入到Gradle构建脚本的classpath中。</p>
<p><strong>注意：提取一个类到Groovy文件中需要设置package，在build.gradle中或者其它地方使用这个类的时候需要导包，这一点与Java类的使用是一样的。当然了，如果这个类本身就放在build.gradle中则不需要这个过程，就像之前的例子那样。</strong></p>
<p>例如 ReleaseVersionTask </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen09.gia</span><br><span class="line"></span><br><span class="line">import org.gradle.api.DefaultTask</span><br><span class="line">import org.gradle.api.tasks.Input</span><br><span class="line">import org.gradle.api.tasks.OutputFile</span><br><span class="line">import org.gradle.api.tasks.TaskAction</span><br><span class="line">class ReleaseVersionTask extends DefaultTask&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Groovy文件实际放置的位置是 buildSrc/src/main/groovy/com/sososeen09/gia/ReleaseVersionTask</p>
<p>根据同样的方式，我们也可以把ProjectVersion这个类抽取出来。</p>
<p>使用的时候，在build.gradle中顶部记得导包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import com.sososeen09.gia.ReleaseVersionTask</span><br><span class="line">import com.sososeen09.gia.ProjectVersion</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此时，执行<figure class="highlight gradle"><figcaption><span>makeReleaseVersion``` 命令，我们就可以看到编译过程：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>:buildSrc:compileJava UP-TO-DATE<br>:buildSrc:compileGroovy UP-TO-DATE<br>:buildSrc:processResources UP-TO-DATE<br>:buildSrc:classes UP-TO-DATE<br>:buildSrc:jar UP-TO-DATE<br>:buildSrc:assemble UP-TO-DATE<br>:buildSrc:compileTestJava UP-TO-DATE<br>:buildSrc:compileTestGroovy UP-TO-DATE<br>:buildSrc:processTestResources UP-TO-DATE<br>:buildSrc:testClasses UP-TO-DATE<br>:buildSrc:test UP-TO-DATE<br>:buildSrc:check UP-TO-DATE<br>:buildSrc:build UP-TO-DATE<br>Reading the version file<br>:makeReleaseVersion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**记住：buildSrc 目录被视为Gradle项目的指定路径。**</span><br><span class="line"></span><br><span class="line"># 把Task编写的类编译成jar包提供给其它项目使用</span><br><span class="line"></span><br><span class="line">我们把Groovy类放在了buildSrc目录下，虽然自定义的Task类与build.gradle分离开了，但是这些类依然只能应用到当前的项目中。如果我们想要在其它的项目中也可以使用这些Task，就需要在单独的项目中来定义，然后其它项目通过声明依赖的方式来使用。</span><br><span class="line"></span><br><span class="line">创建一个新项目，把之前我们讲的buildSrc目录下的内容复制到这个项目中。这个时候，我们就要自己使用Groovy插件来编译这些Groovy源代码了，就像我们编译Java代码需要Java插件一样。Groovy插件是基于Java插件的。在这个项目目录下新建一个build.gradle文件，并在文件中引入Groovy Plugin。</span><br><span class="line">还有一点，我们期望把这些Groovy编写的Task和其它类打包成jar文件供其它地方使用。这个时候我们就可以使用maven插件，把jar文件上传到repository中。关于如何使用maven插件上传，可以查阅相关文档，也可以看这篇 [Gradle User Guide Maven Plugin](https://docs.gradle.org/4.2.1/userguide/maven_plugin.html)。为了简单演示，打包的jar文件上传到了本地的文件系统中。最终的build.gradle文件如下：</span><br></pre></td></tr></table></figure>
<p>apply plugin: ‘groovy’<br>apply plugin: ‘maven’</p>
<p>version = ‘1.0’<br>group = ‘com.sososeen09.gia’<br>archivesBaseName = ‘releaseVersionTask’</p>
<p>repositories {<br>    mavenCentral()<br>}</p>
<p>dependencies {<br>    // 编译的时候我们需要使用Gradle中的API<br>    compile gradleApi()<br>}</p>
<p>uploadArchives {<br>    repositories {<br>        mavenDeployer {<br>            repository(url: “file:../lib”)<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行`gradle uploadArchives`命令后就可以看到，在与当前项目同级的lib文件目录中生成了我们期望的jar文件。</span><br><span class="line"></span><br><span class="line">下面来演示如何使用这个jar文件。我们再新建一个工程，这个工程中有一个脚本文件build.gradle和一个配置文件version.properties。</span><br><span class="line">其中，build.gradle中的代码如下：</span><br></pre></td></tr></table></figure></p>
<p>import com.sososeen09.gia.ReleaseVersionTask<br>import com.sososeen09.gia.ProjectVersion<br>buildscript {<br>    repositories {<br>        maven {<br>            url ‘file:../lib’<br>        }</p>
<pre><code>}

dependencies {
    classpath &apos;com.sososeen09.gia:releaseVersionTask:1.0&apos;
}
</code></pre><p>}</p>
<p>version=new ProjectVersion(0,1)</p>
<p>task printVersion {<br>  doLast{<br>    logger.quiet “Version: $version”<br>  }<br>}</p>
<p>// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例<br>ext.versionFile=file(‘version.properties’)</p>
<p>task loadVersion{<br>    project.version=readVersion()<br>}</p>
<p>//readVersion方法，与task是不同的<br>ProjectVersion readVersion(){<br>    logger.quiet ‘Reading the version file’<br>    if(!versionFile.exists()){<br>        throw new GradleException (“Required version file dose not exist:$versionFile.canonicalPath “ )<br>    }</p>
<pre><code>//Groovy的文件实现通过添加新的方法来读取InputStream
Properties versionProps=new Properties()
versionFile.withInputStream{stream-&gt;
    versionProps.load(stream)
}
// 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略
new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())
</code></pre><p>}</p>
<p>task makeReleaseVersion(type:ReleaseVersionTask){<br>    release = version.release<br>    destFile = versionFile<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">version.properties中的内容如下：</span><br></pre></td></tr></table></figure>
<p>major=0<br>minor=1<br>release=fasle<br>```</p>
<p>执行 <code>gradle makeReleaseVersion</code> 命令之后可以看到配置文件中release变为true。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的介绍，我们了解了自定义Task的方式。 自定义的Task可以放置在build.gradle脚本中，也可以在当前的项目的buildSrc目录下。当然了，如果你期望你写的自定义Task可以被其它的项目中使用，那么你可以用一个单独的工程来放置自定的Task。</p>
<p>关于自定义Task的学习，我们也可以查看Gradle的官方Guide来查看如何<a href="https://guides.gradle.org/writing-gradle-tasks/" target="_blank" rel="noopener">自定义task</a></p>
<p><a href="http://www.jianshu.com/p/e01d647b1c75" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中的依赖管理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://docs.gradle.org/4.2.1/userguide/maven_plugin.html" target="_blank" rel="noopener">Gradle User Guide Maven Plugin</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习6——挂接到构建生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习6——挂接到构建生命周期/" itemprop="url">Gradle学习6——挂接到构建生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:06+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>之前已经讲了Gradle的构建生命周期阶段，当我们在编写构建脚本的时候，可能不仅限于编写不同构建阶段执行的task工作或者配置逻辑。有的时候当一个特定的生命周期事件或者task执行的时候，你想要执行一些代码。这个时候我们就可以根据回调生命周期事件来处理我们需要的逻辑。</p>
<p>有两种方式编写回调生命周期事件：在闭包中或者通过Gradle API所提供的监听器接口实现。<br>选择哪种方式都可以，这个就看个人选择了。<br>采用监听器实现最大的优势在于你处理的类通过编写单元测试是完全可测试的。<br>下面展示了一个hook 构建生命周期的示意图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-a0bb14f5a52d292e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hook生命周期.png"></p>
<p>许多生命周期回调方法被定义在Project和Gradle接口中。</p>
<h1 id="挂接到task执行图"><a href="#挂接到task执行图" class="headerlink" title="挂接到task执行图"></a>挂接到task执行图</h1><p>我们之前讲的例子是通过一个task来将配置文件中的release变为true，现在，我们编写一个生命周期钩子可以实现同样的目标。因为构建确切的知道task在得到执行之前哪些将参与构建，假设当我们的脚本文件build.gradle中如果有releaseProject 这个task的话，我们就把release 变为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task releaseProject &lt;&lt; &#123;</span><br><span class="line">    logger.quiet &apos;Releasing the project...&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.whenReady&#123;TaskExecutionGraph taskGraph -&gt;</span><br><span class="line">  //注册的生命周期钩子在task图生成后被调用</span><br><span class="line">  //查看执行图中是否包含task releaseProject</span><br><span class="line">  if(taskGraph.hasTask(releaseProject))&#123;</span><br><span class="line">     if(!version.release)&#123;</span><br><span class="line">       version.release=true</span><br><span class="line">       ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">         entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行任何一个能够触发releaseProject任务的命令，比如<code>gradle releaseProject</code>，这个时候releaseProject 这个task就被添加到task执行图中了，当task执行图生成完成后，TaskExecutionGraph 这个类提供的 whenReady 方法会被调用。</p>
<h1 id="实现task执行图监听器"><a href="#实现task执行图监听器" class="headerlink" title="实现task执行图监听器"></a>实现task执行图监听器</h1><p>通过监听器挂接到构建生命周期只需要两个简单的步骤：</p>
<ul>
<li>通过在构建脚本中编写一个类实现特定的监听器接口</li>
<li>注册监听器实现</li>
</ul>
<p>用于监听task执行图事件的接口是由TaskExecutionGraphListener接口提供的。<br>监听器可以通过通用的addListener方法或者指定监听器类型实例的方法进行注册。</p>
<p>有一点要指出，在我们自定义的监听器中，是不可以直接访问构建脚本的Project实例的。我们可以根据Task类的getProject()方法来获得该task所在的Project实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ReleaseVersionListener implements TaskExecutionGraphListener &#123;</span><br><span class="line">    final static String releaseTaskPath = &apos;:releaseProject&apos;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void graphPopulated(TaskExecutionGraph taskGraph) &#123;</span><br><span class="line">      // 确定releaseProject task 是否包含在执行图中</span><br><span class="line">        if (taskGraph.hasTask(releaseTaskPath)) &#123;</span><br><span class="line">            List&lt;Task&gt; allTasks = taskGraph.allTasks</span><br><span class="line">            // 从执行图中的所有task来找到releaseProject 的 task 实例</span><br><span class="line">            Task releaseTask = allTasks.find &#123; it.path == releaseTaskPath &#125;</span><br><span class="line">            // 每个task都知道自己所属的project</span><br><span class="line">            Project project = releaseTask.project</span><br><span class="line"></span><br><span class="line">            if (!project.version.release) &#123;</span><br><span class="line">                project.version.release = true</span><br><span class="line">                project.ant.propertyfile(file: project.versionFile) &#123;</span><br><span class="line">                    entry(key: &apos;release&apos;, type: &apos;string&apos;, operation: &apos;=&apos;, value: &apos;true&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册监听器到task执行图中</span><br><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(new ReleaseVersionListener())</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们上面介绍了挂接到构建生命周期的两种方式，这些都是在构建脚本中进行的。但实际上并不局限于在构建脚本中注册生命周期监听器。在任何task执行之前，都可以应用生命周期逻辑来监听Gradle事件，比如在初始化脚本中也可以来挂接到构建生命周期，这部分内容我们就不介绍了，有兴趣的可以自行搜索。</p>
<p><a href="http://www.jianshu.com/p/5a413815a7ae" target="_blank" rel="noopener">下一篇</a>，我们开始学习编写和使用自定义Task。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习5——Gradle增量式构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习5——Gradle增量式构建/" itemprop="url">Gradle学习5——Gradle增量式构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:05+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>Gradle的增量式构建特性紧紧的与生命周期相结合。Gradle的增量式构建支持自动鉴别不需要被运行的任务。这些任务会被标记为 UP-TO-DATE。特别是在大型的企业级项目，这个特性是节约时间的好帮手。</p>
<p>Gradle通过比较两次构建task的inputs和outputs来决定task是否是最新的。自从最后一次task执行以来，如果inputs和outputs没有发生变化，则认为task是最新的。</p>
<p>输入可以是一个目录、一个或多个文件，或者是一个任意属性。<br>一个task的输出是通过一个目录或1~n个文件来定义的。<br>inputs和outputs在DefaultTask类中被定义为属性或者有一个直接类来表示。对应的是TaskInputs和TaskOutputs。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-e7d0ab5ff92f309d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TaskInputs和TaskOutputs.png"></p>
<p>为了便于表述，我们还是接着<a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">上一篇</a>的那个例子，从配置文件version.properties中读取参数，并打印出版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">version=new ProjectVersion(0,1)</span><br><span class="line"></span><br><span class="line">class ProjectVersion&#123;</span><br><span class="line">    Integer major</span><br><span class="line">    Integer minor</span><br><span class="line">    Boolean release</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=Boolean.FALSE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor, Boolean release)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=release</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String toString()&#123;</span><br><span class="line">      &quot;$major.$minor$&#123;release?&apos;&apos;: &apos;-SNAPSHOT&apos;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例</span><br><span class="line">ext.versionFile=file(&apos;version.properties&apos;)</span><br><span class="line"></span><br><span class="line">task loadVersion&#123;</span><br><span class="line">    project.version=readVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//readVersion方法，与task是不同的</span><br><span class="line">ProjectVersion readVersion()&#123;</span><br><span class="line">    logger.quiet &apos;Reading the version file&apos;</span><br><span class="line">    if(!versionFile.exists())&#123;</span><br><span class="line">        throw new GradleException (&quot;Required version file dose not exist:$versionFile.canonicalPath &quot; )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Groovy的文件实现通过添加新的方法来读取InputStream</span><br><span class="line">    Properties versionProps=new Properties()</span><br><span class="line">    versionFile.withInputStream&#123;stream-&gt;</span><br><span class="line">        versionProps.load(stream)</span><br><span class="line">    &#125;</span><br><span class="line">    // 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略</span><br><span class="line">    new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件中的初始参数是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">major=0</span><br><span class="line">minor=1</span><br><span class="line">release=false</span><br></pre></td></tr></table></figure>
<p>现在，我们要增加一个新的任务：新建一个名为makeReleaseVersion的task来将配置文件中的release属性改为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(group :&apos;versioning&apos;,description :&apos;Makes project a release version.&apos; )&lt;&lt; &#123;</span><br><span class="line">    version.release=true</span><br><span class="line">// Ant task 的propertyfile 提供了一种便利的方式来修改属性文件</span><br><span class="line">    ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">        entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行gradle makeReleaseVersion<br>之后打开配置文件 version.properties 就可以看到文件中的release属性已经变为true了。</p>
<p>执行 <code>gradle printVersion</code> 命令，可以看到结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">Version: 0.1</span><br></pre></td></tr></table></figure>
<p><strong>注意，虽然我们将配置文件中的release标记为true，但是Gradle并不知道。当我们再次执行makeReleaseVersion这个task的时候，doLast这个闭包中的代码还是会执行，会花多余的时间。为了解决这个问题，需要声明它的inputs和outputs。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(group :&apos;versioning&apos;,description :&apos;Makes project a release version.&apos; )&#123;</span><br><span class="line">    //在配置阶段声明inputs/outputs</span><br><span class="line">    //声明版本的release属性作为输入</span><br><span class="line">    inputs.property(&apos;release&apos;,version.release)</span><br><span class="line">    //由于版本文件被修改了，所以它被声明作为输出文件属性</span><br><span class="line">    outputs.file versionFile</span><br><span class="line">    doLast&#123;</span><br><span class="line">        version.release=true</span><br><span class="line">// Ant task 的propertyfile 提供了一种便利的方式来修改属性文件</span><br><span class="line">        ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">            entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记住：task的inputs和outputs属性是在配置阶段执行的用来连接task的依赖。这就是他们需要在配置块中被定义的原因。为了避免出现所不期望出现的行为，请确保赋给inputs和outputs的值在配置阶段是可访问的。如果需要通过编程获得输出，可以通过TaskOutputs上的upToDateWhen（Closure）方法来实现。与常规的inputs和outputs相比，这个方法是在执行期间执行的。如果闭包返回true，这个task则会被认为是最新的。</p>
</blockquote>
<p>如果执行两次makeReleaseVersion任务，会发现Gradle已经知道配置文件中的release 已经变为true，会自动跳过第二次执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:makeReleaseVersion UP-TO-DATE</span><br></pre></td></tr></table></figure>
<p>实际上，我们在apk打包过程中经常看到的UP-TO-DATE 就是因为输入输出没有发生变化，Gradle跳过了这个task的执行。</p>
<p><a href="http://www.jianshu.com/p/bb13bfb8d1b0" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中如何挂接到构建生命周期。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习4——深入了解Task和构建生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习4——深入了解Task和构建生命周期/" itemprop="url">Gradle学习4——深入了解Task和构建生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:04+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<h1 id="声明Task"><a href="#声明Task" class="headerlink" title="声明Task"></a>声明Task</h1><p>默认情况下，每个新创建的task都是org.gradle.api.DefaultTask类型的，它是标准的org.gradle.api.Task 实现。DefaultTask的所有属性都是private的，只能通过getter和setter方法来访问。</p>
<blockquote>
<p>幸运的是，Groovy提供了一些语法糖，可以直接通过属性名来使用属性。在底层，Groovy会为你调用这些方法。</p>
</blockquote>
<p>一个简单的task可以是这样，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task printVersion &#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle printVersion</code> 命令，结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>如果换成doFirst，执行的结果也是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="给现有的Task添加动作"><a href="#给现有的Task添加动作" class="headerlink" title="给现有的Task添加动作"></a>给现有的Task添加动作</h1><p>task在创建后，可以根据需要添加很多动作，在内部，每个task都保持了一个动作列表，在运行时，它们按顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line"></span><br><span class="line">// 声明一个包含doFirst和doLast的task</span><br><span class="line">task printVersion &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">      println &quot;Before reading the project version&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在动作列表的开始添加doFirst闭包</span><br><span class="line">//在动作列表的最后添加doLast闭包，采用别名的方式</span><br><span class="line">printVersion.doFirst &#123;println &quot;First action&quot;&#125;</span><br><span class="line">printVersion&lt;&lt;&#123;println &quot;Last action&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle printVersion</code> 命令，结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">First action</span><br><span class="line">Before reading the project version</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br><span class="line">Last action</span><br></pre></td></tr></table></figure>
<p>如上所示，可以给现有的task添加一些动作，这在你想要为不是自己编写的task执行自定义逻辑时非常有用。比如，为Java插件的compileJava task添加一个doFirst动作来检查项目中至少包含一个Java源文件。</p>
<h1 id="访问DefaultTask属性"><a href="#访问DefaultTask属性" class="headerlink" title="访问DefaultTask属性"></a>访问DefaultTask属性</h1><p>Gradle提供了一个基于SLF4J日志库的logger实现。除了常规的日志级别如DEBUG、ERROR、INFO、TRACE、WARN，之外Gradle还增加了一些额外的日志级别。通过Task的方法可以直接访问logger实例。例如，打印QUIET日志级别的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task还有两个属性：description和group。description属性用于描述任务的作用，而group属性则用于定义task的逻辑分组。<br>创建task的时候可以为这两个属性设置值作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printVersion(group: &apos;versioning&apos;,description:&apos;Print project version&apos; ) &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过setter方法来设置属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task printVersion&#123;</span><br><span class="line">  group = &apos;versioning&apos;</span><br><span class="line">  description = &apos;Print project version&apos;</span><br><span class="line">  doLast&#123;</span><br><span class="line">    logger.quiet &quot;Version: $version&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>gradle task</code> 命令，可以看到task正确的分组和描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Versioning tasks</span><br><span class="line">----------------</span><br><span class="line">printVersion - Print project version</span><br></pre></td></tr></table></figure>
<p>尽管设置task的描述和分组和可选的，但是为所有的task指定description和group是一个比较好的实践，这会帮助用户比较容易的去识别task的功能。</p>
<h1 id="定义task依赖"><a href="#定义task依赖" class="headerlink" title="定义task依赖"></a>定义task依赖</h1><p>dependsOn方法允许声明依赖一个或多个task。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task first &lt;&lt; &#123; println &apos;first&apos;&#125;</span><br><span class="line">task second &lt;&lt; &#123; println &apos;second&apos; &#125;</span><br><span class="line"></span><br><span class="line">//指定多个task依赖</span><br><span class="line">task printVersion(dependsOn :[second,first]) &lt;&lt; &#123;</span><br><span class="line">    logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//task third(dependsOn : printVersion) &lt;&lt;&#123;</span><br><span class="line">//    println &apos;third&apos;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//还可以采用这样的方式</span><br><span class="line">task third &lt;&lt;&#123; println &apos;third&apos;&#125;</span><br><span class="line">third.dependsOn(&apos;printVersion&apos;)</span><br></pre></td></tr></table></figure>
<p>执行gradle -q third 结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br><span class="line">third</span><br></pre></td></tr></table></figure>
<p>看到执行结果会有一点点意外，printVersion任务的依赖是second和first，为什么不是先执行second再执行first呢？在Gradle中，task执行顺序是不确定的。</p>
<h1 id="Task的执行顺序"><a href="#Task的执行顺序" class="headerlink" title="Task的执行顺序"></a>Task的执行顺序</h1><p>理解Gradle并不能保证task依赖的执行顺序是很重要的。dependsOn方法只是定义了所依赖的task需要先执行。Gradle的思想是声明在一个给定的task执行之前什么该被执行，而没有去定义它该如何执行。在Gradle中，执行顺序是由task的输入/输出规范自动确定的。</p>
<p><strong>好处</strong>：</p>
<ol>
<li>不需要知道整个task依赖链上的关系是否发生改变，这样可以提高代码的可维护性和避免潜在的破坏。</li>
<li>因为构建没有严格的执行顺序，也就是支持task的并行执行，这样可以极大地节约构建执行时间。</li>
</ol>
<h1 id="理解task配置"><a href="#理解task配置" class="headerlink" title="理解task配置"></a>理解task配置</h1><p>在Gradle脚本中可以定义通用的Groovy代码的功能。Groovy中只需要声明属性，不需要添加访问权限修饰符。getter和setter方法本质上是在生成字节码时自动添加的，运行时可以直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version=new ProjectVersion(0,1)</span><br><span class="line">class ProjectVersion&#123;</span><br><span class="line">    Integer major</span><br><span class="line">    Integer minor</span><br><span class="line">    Boolean release</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=Boolean.FALSE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor, Boolean release)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=release</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String toString()&#123;</span><br><span class="line">      &quot;$major.$minor$&#123;release?&apos;&apos;: &apos;-SNAPSHOT&apos;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>gradle printVersion</code> ，得到的结果与之前相同。</p>
<p>我们也可以使用配置文件来设置属性。<br>例如新建一个version.properties文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">major = 0</span><br><span class="line">minor = 1</span><br><span class="line">release = false</span><br></pre></td></tr></table></figure>
<p>对应的version就是0.1-SANPSHOT</p>
<p>然后可以添加task的配置块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例</span><br><span class="line">// versionFile是一个扩展属性</span><br><span class="line">ext.versionFile=file(&apos;version.properties&apos;)</span><br><span class="line"></span><br><span class="line">//没有使用左移操作符定义task配置</span><br><span class="line">task loadVersion&#123;</span><br><span class="line">    project.version=readVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//readVersion方法，注意：这个是方法，而不是task</span><br><span class="line">ProjectVersion readVersion()&#123;</span><br><span class="line">    logger.quiet &apos;Reading the version file&apos;</span><br><span class="line">    if(!versionFile.exists())&#123;</span><br><span class="line">        throw new GradleException (&quot;Required version file dose not exist:$versionFile.canonicalPath &quot; )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Groovy的文件实现通过添加新的方法来读取InputStream</span><br><span class="line">    Properties versionProps=new Properties()</span><br><span class="line">    versionFile.withInputStream&#123;stream-&gt;</span><br><span class="line">        versionProps.load(stream)</span><br><span class="line">    &#125;</span><br><span class="line">    // 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略</span><br><span class="line">    new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>gradle printVersion</code>，会看到 loadVersion 中的代码执行了。尽管 loadVersion 这个task的名字没有打印出来，但是可以看到打印日志了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reading the version file</span><br><span class="line">:printVersion</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>我们不禁疑问，为什么我们没有执行 loadVersion 这个task，也没有声明依赖关系，但是它内部的代码依然被执行了呢？<br>原因就是我们在loadVersion这个task闭包中的<code>project.version=readVersion()</code>属于task配置块，而task配置块永远在task动作执行之前被执行，只要触发构建，脚本文件中的所有task配置块都会执行，这牵涉到了Gradle的构建生命周期问题。</p>
<blockquote>
<p>注意区分 配置块和action是不同的，task的action一般就是doFirst和doLast。</p>
</blockquote>
<h1 id="构建生命周期阶段"><a href="#构建生命周期阶段" class="headerlink" title="构建生命周期阶段"></a>构建生命周期阶段</h1><p>无论什么时候执行Gradle构建，都会运行三个不同的生命周期阶段：初始化、配置和执行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-8da49286d17b50b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle生命周期示意图.png"></p>
<p>初始化阶段，Gradle为项目创建了一个Project实例。给定的构建脚本只定义了一个项目，在多项目构建中，这个构建阶段变得更加重要。根据正在执行的项目，Gradle找出哪些项目依赖需要参与到构建中。</p>
<blockquote>
<p>注意：在这个构建阶段当前已有的构建脚本代码都不会被执行。</p>
</blockquote>
<p>配置阶段，Gradle构造了一个模型来表示任务，并参与到构建中来。增量式构建特性决定了模型中的task是否需要被运行。这个阶段非常适合与为项目或执行task设置所需的配置。</p>
<blockquote>
<p>注意：项目每一次构建的任何配置代码都可以被执行——即使你只执行gradle tasks</p>
</blockquote>
<p>执行阶段，所有的task都应该以正确的顺序被执行。执行顺序是由它们的依赖决定的。如果任务被认为没有修改过，将被跳过，这个牵涉到增量式构建，我们<a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">下一篇</a>再讲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习3——自定义属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习3——自定义属性/" itemprop="url">Gradle学习3——自定义属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:03+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<p>读取和设置Project和Task的属性是很重要的一块内容，每个Project和Task实例都提供了可以通过getter和setter方法访问的属性。一个属性可能是一个任务的描述或者项目的版本。你也可以定义自己的属性。Gradle允许用户通过扩展属性自定义一些变量。还有，很多Plugin都会加入扩展属性，可以通过设置属性来控制使用Pulgin。</p>
<h1 id="Project自带的属性"><a href="#Project自带的属性" class="headerlink" title="Project自带的属性"></a>Project自带的属性</h1><p>Gradle在默认情况下已经为Project定义了很多属性，其中比较常用的有：</p>
<ul>
<li>project：Project本身对象</li>
<li>name：Project的名字</li>
<li>path：Project的绝对路径</li>
<li>description：Project的描述信息</li>
<li>buildDir：Project构建结果存放目录</li>
<li>version：Project的版本号<br>属性都可以通过getter和setter方法来访问，也可以直接使用点好的形式来访问，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setDescription(&apos;myProject&apos;)</span><br><span class="line">println &quot;Description of project $name: &quot;+project.description</span><br></pre></td></tr></table></figure>
<p>当在build.gradle中访问属性和方法的时候，不需要使用project变量，它会假设你使用的是project实例。但是有一些情况需要注意，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = &apos;this is the project version&apos;</span><br><span class="line">description = &apos;this is the project description&apos;</span><br><span class="line"></span><br><span class="line">task showProjectProperties &lt;&lt; &#123;</span><br><span class="line">   println version</span><br><span class="line">   println project.description</span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Task本身也有description属性，所以当在Task中，如果不显式的指定project，就会打印的是Task的description。这是因为定义Task的闭包将delegate设置成了当前的Task。有关delegate的介绍，我们可以看前一篇文章。<br> Gradle还为我们提供了多种方法来自定义Project的Property。</p>
<h1 id="额外属性"><a href="#额外属性" class="headerlink" title="额外属性"></a>额外属性</h1><p>Gradle的很多领域模型类提供了特别的属性支持。在内部，这些属性以简直对的形式存储。为了添加属性，你需要使用ext命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 只在初始声明额外属性时需要使用ext命名空间</span><br><span class="line">project.ext.myProp=&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">ext&#123;</span><br><span class="line">        someOtherProp=123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用ext命名空间访问属性是可选的</span><br><span class="line">assert myProp==&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">println project.someOtherProp</span><br><span class="line"></span><br><span class="line">ext.someOtherProp=567</span><br></pre></td></tr></table></figure>
<p>类似的，额外的属性也可以通过属性文件来提供。</p>
<h1 id="Gradle属性"><a href="#Gradle属性" class="headerlink" title="Gradle属性"></a>Gradle属性</h1><p>Gradle属性可以通过在gradle.properties文件中声明直接添加到项目中，这个文件位于<user_home>/.gradle目录或者项目的根目录下。这些属性可以通过项目实例访问。即使有多个项目，每个用户也只有能一个Gradle属性文件在xx/.gradle目录下，这是目前Gradle对它的限制。</user_home></p>
<p>在这个属性文件中声明的属性对所有的项目可用。<br>我们假设在gradle.properties文件中声明的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exampleProp=myValue</span><br><span class="line">someOtherProp=455</span><br></pre></td></tr></table></figure>
<p>可以按照如下方式访问项目中的这两个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assert project.exampleProp==&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">task printGradleProperties &lt;&lt;&#123;</span><br><span class="line">    println &quot;Second property :$someOtherProp&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="声明属性的其他方式"><a href="#声明属性的其他方式" class="headerlink" title="声明属性的其他方式"></a>声明属性的其他方式</h1><p>前面两种方式，我们大多用来声明自定义变量及其值。Gradle也提供了很多其他方式为构建提供属性。</p>
<h2 id="项目属性通过-P命令行选项提供"><a href="#项目属性通过-P命令行选项提供" class="headerlink" title="项目属性通过 -P命令行选项提供"></a>项目属性通过 -P命令行选项提供</h2><p>对于下面的例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printMyProperties &lt;&lt;&#123;</span><br><span class="line">	println myProperties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们直接执行 <code>gradle -q printMyProperties</code> 命令，会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:printMyProperties&apos;.</span><br><span class="line">&gt; Could not get unknown property &apos;myProperties&apos; for task &apos;:printMyProperties&apos; of type org.gradle.api.DefaultTask.</span><br></pre></td></tr></table></figure>
<p>这是因为myProperties属性没有定义，所以我们在调用gradle命令的时候可以通过 -P 命令来传参数，就可以把这个属性打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -P myProperties=&apos;this is -P params&apos;  printMyProperties</span><br></pre></td></tr></table></figure>
<h2 id="系统属性通过-D命令行选项提供"><a href="#系统属性通过-D命令行选项提供" class="headerlink" title="系统属性通过 -D命令行选项提供"></a>系统属性通过 -D命令行选项提供</h2><p>与在Java中类似的，我们在Gradle中也可以通过-D来定义JVM的系统参数，只是需要增加一些约定，每个通过-D 方式声明的属性前面都要以“org.gradle.project”为前缀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -D org.gradle.project.myProperties=&apos;this is -D params&apos;  printMyProperties</span><br></pre></td></tr></table></figure>
<h2 id="环境属性模式提供"><a href="#环境属性模式提供" class="headerlink" title="环境属性模式提供"></a>环境属性模式提供</h2><p>我们可以通过设置环境变量的形式来设置Project的属性。但是也要增加一些约定，例如每个属性前面都要加上一个<code>ORG_GRADLE_PROJECT_</code>的前缀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORG_GRADLE_PROJECT_propertyName=someValue</span><br></pre></td></tr></table></figure>
<p>当你再去执行printMyProperties这个task的时候就不用传参数了。</p>
<p><a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">下一篇</a>，我们会开始探索task的依赖，构建的生命周期等内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习2——开始使用Gradle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习2——开始使用Gradle/" itemprop="url">Gradle学习2——开始使用Gradle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:52:02+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果把Gradle当做脚本来学习，对于那么多的DSL配置，我们似乎难以下手。在这一点上，我认为邓凡平的<a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Android之Gradle</a>这篇文章讲的很好，把Gradle当做一个编程框架来学习，这篇文章可以让我们从一个不同的视角来学习和理解Gradle。</p>
<h1 id="Gradle-之hello-world"><a href="#Gradle-之hello-world" class="headerlink" title="Gradle 之hello world"></a>Gradle 之hello world</h1><p>新建一个build.gradle文件，然后输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//task是一个任务，doLast 是一个action</span><br><span class="line">task helloWorld &#123;</span><br><span class="line">    println &apos;hello world!&apos;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;hello World! do last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入命令 <code>gradle helloWorld</code>，执行helloWorld这个task。结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld //这个代表的是helloWold任务</span><br><span class="line">hello World! do last</span><br></pre></td></tr></table></figure>
<p>可以看到task中的内容正确的执行了，在task中 doLast是一个action，此外还有一个叫作doFirst的action。doFirst、doLast都是闭包。顾名思义就是再任务开始执行的开始和最后执行该闭包中的内容。</p>
<p>对于doLast这个action，可以使用一个简单的左移操作符来替代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可以使用左移符号 &lt;&lt; 来简单的代表doLast</span><br><span class="line">task name &lt;&lt; &#123;</span><br><span class="line">    println &apos;this is doLast action&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Gradle的命令"><a href="#Gradle的命令" class="headerlink" title="Gradle的命令"></a>Gradle的命令</h1><p>Gradle的执行有很多有用的命令，运行gradle –help就可以查看这些命令。</p>
<h2 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p>-?, -h, –help 打印所有可用的命令行选项，包含描述信息<br>-b, –build-file gradle构建脚本的默认命名约定为build.gradle ,使用这个命令可以执行一个指定名字的构建脚本（比如，gradle -b test.gradle）。<br>–offline 可以在离线模式下构建，仅在本地缓存中检查依赖是否存在。</p>
<h2 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h2><p>-D, –system-prop Gradle是以一个JVM进程运行的。和所有的Java进行一样，你可以提供一个系统参数 (例如 -Dmyprop=myvalue)。<br>-P, –project-prop 项目参数是构建脚本中可用的变量，可以使用这个选项直接向构建脚本中传入参数(如 -Pmyprop=myvalue)。</p>
<h2 id="日志选项"><a href="#日志选项" class="headerlink" title="日志选项"></a>日志选项</h2><p>-i, –info 在默认设置中，Gradle构建不会提供大量的输出信息。通过这个选项可以将Gradle的日志级别改变到INFO以获得更多信息。<br>-s, –stacktrace 如果构建在运行中出现错误，-s选项在有异常抛出时会打印简短的堆栈跟踪信息，帮助你进行调试。<br>-q, –quiet 只在出错的时候打印信息</p>
<h2 id="帮助任务"><a href="#帮助任务" class="headerlink" title="帮助任务"></a>帮助任务</h2><ul>
<li>tasks ：显示项目中所有可运行的task，包括它们的描述信息。项目中应用的插件可能会提供一些额外的task。</li>
<li>properties：显示出项目中的所有可用的属性。某些属性是由Gradle的project对象提供的，project对象是一个构建的本质表现形式。其它的属性都是用户自行一的，要么来自于属性文件或者命令行选项，要么是直接在构建脚本重定义的。</li>
</ul>
<p>例如：</p>
<ol>
<li>gradle -q helloworld<br>表示静默执行helloworld任务 。-q 的意思是 quiet，也可以不带q</li>
<li>gradle -q tasks<br>列出gradle中的task</li>
<li>gradle -q tasks –all<br>列出gradle中更多的task</li>
</ol>
<p>当然了这个命令行我们不需要死记硬背，忘记怎么使用的时候，运行一下 <code>gradle --help</code>命令即可查阅相关的命令。</p>
<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>gradle有一个命令<code>--daemon</code>可以用来开启一个守护进程，这个守护进程以后台方式运行。开启完守护进程之后，下一次运行构建的将会变快，这是因为减少了启动Gradle的开销。</p>
<p>执行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task helloWorld &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">       println &apos;hello World! do first&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println &apos;hello world!&apos;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;hello World! do last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，我们使用<code>gradle helloWorld</code>命令，可以看一下执行的时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.787 secs</span><br></pre></td></tr></table></figure>
<p>然后我们使用命令 <code>gradle --daemon helloWorld</code> 运行构建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 4.522 secs</span><br></pre></td></tr></table></figure>
<p>WTF，不是说开启守护进程，构建时间会减少吗，怎么还变多了？<br>不要急，我们再来运行一次 <code>gradle --daemon helloWorld</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1.228 secs</span><br></pre></td></tr></table></figure>
<p>看到了没，这一次时间减少了很多。第一次构建时间变长是因为后台开启这个守护进程也是需要开销的，但是开启了守护进程之后我们就可以轻快的玩耍了。</p>
<p>需要注意的是：</p>
<ol>
<li>守护进程只会被创建一次</li>
<li>守护进程会在3小时空闲时间之后自动过期</li>
<li>想要重用守护进程，构建的时候要加上<code>--daemon</code>选项</li>
</ol>
<p><code>--no-daemon</code> 选项可以选择执行构建时不使用守护进程。<br><code>gradle --stop</code> 命令可以手动停止守护进程。</p>
<h1 id="Gradle-Wrapper-包装器"><a href="#Gradle-Wrapper-包装器" class="headerlink" title="Gradle Wrapper 包装器"></a>Gradle Wrapper 包装器</h1><p>在从Eclipse切换到Android Studio进行Android开发的时候，我在很长一段时间都不明白这个gradle Wrapper有什么作用。直到学习了Gradle的构建才了解到它的重要作用。<br>Gradle包装器是Gradle的核心特性，能够让机器在没有安装Gradle运行时的情况下运行Gradle构建，也可以让构建脚本运行在一个指定的Gradle版本上。<br>使用Wrapper被认为是最佳实践，这样在不同的机器上面，构建的版本就能够保证统一。使用了包装器的Gradle脚本非常适合作为自动化发布的一部分，比如持续集成。</p>
<h2 id="配置包装器"><a href="#配置包装器" class="headerlink" title="配置包装器"></a>配置包装器</h2><p>为了能够让项目下载压缩过的Gradle运行时文件，定义一个类型为Wrapper的任务，通过gradleVersion属性指定你想要使用的Gradle版本。<br>不要求该任务的名字为wrapper，任何名字都可以。但是这个名字在Gradle的在线文档中使用，是一个默认的约定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(type: Wrapper) &#123;</span><br><span class="line">    gradleVersion = &apos;3.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行任务 `gradle wrapper’ ，就会在构建脚本同级的目录下生成了包装器文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build.gradle*</span><br><span class="line">gradle/</span><br><span class="line">.gradle/</span><br><span class="line">gradlew*</span><br><span class="line">gradlew.bat</span><br></pre></td></tr></table></figure>
<p>gradle目录中的结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-44921bcf6fd57c9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在gradle-wrapper.properties文件中包含了Wrapper的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-bin.zip</span><br></pre></td></tr></table></figure>
<p>.gradle 是存放下载下来的gradle的目录。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-15d303a10d9db8cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".gradle中存放文件.png"></p>
<p>记住：只需在项目中运行一次gradle wrapper命令就可以了。而且通常情况下，我们最好把gradle wrapper文件提交到版本控制系统中去。</p>
<h2 id="使用包装器"><a href="#使用包装器" class="headerlink" title="使用包装器"></a>使用包装器</h2><p>作为包装器内容的一部分，它提供了一个命令执行脚本。对于 *nix系统，如Linux、Mac Os系统，它是一个叫做gradlew的shell脚本；对于Windows操作系统，它是gradle.bat。使用它们运行构建和使用已安装的Gradle运行时运行构建是一样的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-a8ecf18fcbad57ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle生成的脚本.png"></p>
<p>对于android开发，假如我们在android studio中使用命令行工具 ，如clean任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean  //Mac OS</span><br><span class="line">gradlew clean //Windows</span><br></pre></td></tr></table></figure>
<p>更多信息可以查看官方文档<a href="https://docs.gradle.org/4.1/dsl/org.gradle.api.tasks.wrapper.Wrapper.html#org.gradle.api.tasks.wrapper.Wrapper:gradleVersion" target="_blank" rel="noopener">Wrapper</a>。</p>
<h1 id="Gradle构建块"><a href="#Gradle构建块" class="headerlink" title="Gradle构建块"></a>Gradle构建块</h1><p>每个Gradle构建都包含三个基本构建块：project、task、property。每个构建至少包含一个project，进而包含一个或者多个task。project和task暴露的属性可以用来控制构建。</p>
<p>Gradle使用的是领域驱动设计（DDD）的原理为其自己的领域构建软件建模。因此，在<strong>Gradle API中有相应的类来表示project和task</strong>。</p>
<blockquote>
<p>Gradle API中有相应的类来表示project和task。这一点是要明确的，Gradle中的脚本实际上是转为代码来执行的。</p>
</blockquote>
<h2 id="项目Project"><a href="#项目Project" class="headerlink" title="项目Project"></a>项目Project</h2><p>在Gradle术语中，一个项目（project）代表一个正在构建的组件，比如一个JAR文件，或一个想要完成的目标，如部署应用程序。<br>当构建进程启动后，Gradle基于build.gradle中的配置实例化org.gradle.api.Project接口，并且能够通过project变量使其隐式可用。</p>
<h2 id="任务Task"><a href="#任务Task" class="headerlink" title="任务Task"></a>任务Task</h2><p>任务动作 task action，定义了一个当任务执行时最小的工作单元。<br>任务依赖 task dependency，很多时候运行一个task之前需要运行另一个task。<br>Gradle task对应的API是org.gradle.api.Task 接口。</p>
<h2 id="属性-Property"><a href="#属性-Property" class="headerlink" title="属性 Property"></a>属性 Property</h2><p>每个Project和Task实例都提供了可以通过getter和setter方法访问的属性。一个属性可能是一个任务的描述或者项目的版本。<br>你也可以定义自己的属性。Gradle允许用户通过扩展属性自定义一些标量。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了Gradle中task的基本使用、命令行的使用、包装器Wrapper的作用以及Gradle构建块的介绍。</p>
<p><a href="http://www.jianshu.com/p/434eba22561e" target="_blank" rel="noopener">下一篇</a>，我们会开始介绍Project和Task的属性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/Gradle学习1——Groovy基本介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/14/Gradle学习1——Groovy基本介绍/" itemprop="url">Gradle学习1——Groovy基本介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T16:51:01+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习Gradle，前前后后总结了一些内容，然后整理出了一个系列，共计10篇文章，与大家分享：</p>
<ol>
<li><a href="http://www.jianshu.com/p/0bde7097abaf" target="_blank" rel="noopener">Groovy基本介绍</a></li>
<li><a href="http://www.jianshu.com/p/158851436e82" target="_blank" rel="noopener">开始使用Gradle</a></li>
<li><a href="http://www.jianshu.com/p/434eba22561e" target="_blank" rel="noopener">自定义属性</a></li>
<li><a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">深入了解Task和构建生命周期</a></li>
<li><a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">Gradle增量式构建</a></li>
<li><a href="http://www.jianshu.com/p/bb13bfb8d1b0" target="_blank" rel="noopener">挂接到构建生命周期</a></li>
<li><a href="http://www.jianshu.com/p/5a413815a7ae" target="_blank" rel="noopener">编写和使用自定义Task</a></li>
<li><a href="http://www.jianshu.com/p/e01d647b1c75" target="_blank" rel="noopener">依赖管理</a></li>
<li><a href="http://www.jianshu.com/p/62c1f3ca380c" target="_blank" rel="noopener">多项目构建</a></li>
<li><a href="http://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">自定义Gradle插件</a></li>
</ol>
<blockquote>
<p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gradle脚本使用的是Groovy语言，Groovy也是基于JVM的一种动态语言，基于Java并扩展了Java语言。Groovy会使写Java程序就要写脚本一样简单，写完就可以执行，所以看起来也像是一门脚本语言。Groovy内部会把代码编译为Java class文件然后启动虚拟机来执行，这些过程，我们开发人员是不用管的。</p>
<p>Gradle是一种DSL，也即是 Domain Specific Language 领域特定语言。说白了DSL就是一种行话，这个语言在Gradle中可以识别，在其它地方就用不了了。</p>
<p>学习Gradle，我们不必要精通Groovy语言，但还是需要了解一些Groovy的基本知识，比如def关键字、返回语句、字符串、集合、闭包等。下面，我们就来简单介绍一下。</p>
<h1 id="Groovy代码的执行"><a href="#Groovy代码的执行" class="headerlink" title="Groovy代码的执行"></a>Groovy代码的执行</h1><p>前面我们说了，Groovy很像是一门脚本语言，我们来看一下怎么回事。<br>创建一个HelloGroovy.groovy文件，里面就一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println &apos;hello groovy!&apos;</span><br></pre></td></tr></table></figure>
<p>然后执行命令<code>groovy HelloGroovy.groovy</code>,得到结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello groovy!</span><br></pre></td></tr></table></figure>
<p>是不是很简单，很像脚本语言。</p>
<h1 id="Groovy中的字符串"><a href="#Groovy中的字符串" class="headerlink" title="Groovy中的字符串"></a>Groovy中的字符串</h1><p>Groovy 对字符串支持相当强大，可以使用多种字符串，包括单引号、双引号、三引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str=&apos;hello groovy!&apos;</span><br><span class="line"></span><br><span class="line">String getStr()&#123;</span><br><span class="line">	&apos;hello groovy!&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str1=&apos;hello&apos;</span><br><span class="line">String str2=&apos; groovy!&apos;</span><br><span class="line">println &apos;hello groovy!&apos;</span><br><span class="line">println &quot;hello groovy!&quot;</span><br><span class="line">println &quot;$str&quot;</span><br><span class="line">println getStr()</span><br><span class="line">println &quot;$&#123;str1+str2&#125;&quot;</span><br><span class="line">println &apos;hello $str2&apos;  //单引号，直接打印内容</span><br></pre></td></tr></table></figure>
<p>使用单引号会直接打印字符串的内容，不会对美元$符号的内容进行转义。使用双引号的功能更加强大，字符串中使用美元符$后面可以跟字符串变量，如<code>&quot;$str&quot;</code>，也可以跟表达式如 <code>&quot;${str1+str2}&quot;</code>，如果跟表达式，记得要用{}括起来。</p>
<p>三引号用的比较少，可以支持字符串内容换行，我们了解一下就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println &apos;&apos;&apos; aa</span><br><span class="line">bb</span><br><span class="line"></span><br><span class="line">cc</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<p>我们在getStr()方法中并没有使用return语句，这是因为Groovy默认是把最后一行的执行结果进行返回。如果你需要返回的结果正好是最后一行，就可以省略return。</p>
<p>另外，在Groovy中，语句的最后的<code>“；”</code>号是可以省略的。还有一点就是Groovy中在调用函数的时候可以不加括号，比如，<code>println (&quot;hello&quot;)</code> 与 <code>println &quot;hello&quot;</code> 的意思是一样的</p>
<h1 id="def关键字"><a href="#def关键字" class="headerlink" title="def关键字"></a>def关键字</h1><p>def关键字很像是Java中的Object，在定义变量或者方法的时候使用def，如果没有指定具体的参数类型。在运行阶段Groovy会自动判断参数类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def a = 1, b = 2</span><br><span class="line">def str = &quot;hello&quot;</span><br><span class="line">println a + b</span><br><span class="line">println str</span><br></pre></td></tr></table></figure>
<p>实际上我们在定义变量的时候是可以省略def的，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">str = &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>但是，最好还是加上def，这是一种好的实践。<br>你还可以在定义变量的时候，在def后面再加上具体的参数类型，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def int a = 1</span><br><span class="line">def String str = &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>使用def定义方法的返回值类型，可以返回任意类型。如果指定了具体的返回值类型，就要正确的返回，否则会报错。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Groovy的基本类型与Java一样。对于集合类型的数据，List的具体实现是ArrayList。Map集合的具体实现是LinkedHashMap。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>下面我们来简单了解一下如果使用。List使用一个 []中括号来括起来来表示的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义一个List</span><br><span class="line">def lists=[&apos;groovy&apos;,&apos;gradle&apos;,&apos;android&apos;]</span><br><span class="line"></span><br><span class="line">//打印集合size</span><br><span class="line">println lists.size</span><br><span class="line"></span><br><span class="line">//打印集合中的数据</span><br><span class="line">lists.each&#123;</span><br><span class="line">	list-&gt;println list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出集合中的数据直接用索引就可以了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert lists[0]==&apos;groovy&apos;</span><br></pre></td></tr></table></figure>
<p>对于集合中变量的存储，我们是不需要担心数组越界的，如果索引超过当前长度，List会自动在该索引中添加元素。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists[100]=100</span><br><span class="line">println lists.size</span><br><span class="line">println lists[99]</span><br></pre></td></tr></table></figure>
<p>打印结果，会发现集合的size变为101。index为99的集合数据为null。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map的表示就是用中括号[]括起来的 key:value形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def map=[&quot;key1&quot;:&quot;hello&quot;,&quot;key2&quot;:&quot;groovy&quot;,&quot;key3&quot;:true]</span><br><span class="line">println map.size()</span><br><span class="line"></span><br><span class="line">map.forEach&#123;</span><br><span class="line">	key,value-&gt;</span><br><span class="line">	println &quot;$key :$value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">key1 :hello</span><br><span class="line">key2 :groovy</span><br><span class="line">key3 :true</span><br></pre></td></tr></table></figure>
<p>获取Map的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println map.&apos;key1&apos;</span><br><span class="line">println map[&apos;key1&apos;]</span><br></pre></td></tr></table></figure>
<p>添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.&apos;key4&apos;=&apos;android&apos;</span><br><span class="line">println map[&apos;key4&apos;]</span><br></pre></td></tr></table></figure>
<h1 id="Groovy的类"><a href="#Groovy的类" class="headerlink" title="Groovy的类"></a>Groovy的类</h1><p>Groovy中的类与Java中的类的写法类似，但是要更简洁一些。<br>我们在Hello.groovy文件中写一个HelloWorld类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorld&#123;</span><br><span class="line">	String msg=&apos;hello world&apos;</span><br><span class="line">    </span><br><span class="line">    HelloWorld()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HelloWorld(String msg)&#123;</span><br><span class="line">		this.msg=msg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void sayHello()&#123;</span><br><span class="line">		println msg</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def say=&#123;</span><br><span class="line">	new HelloWorld(&apos;hello&apos;).sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getMsg=&#123;</span><br><span class="line">	new HelloWorld().msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say()</span><br><span class="line">println getMsg()</span><br></pre></td></tr></table></figure>
<p>调用<code>groovy Hello.groovy</code> 命令执行该脚本，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>当然了，我们也可以写一个单独的HelloWorld类，带上包名，然后在其它地方导包使用，就像Java那样。有关于Groovy类的使用，我们后面还会讲到，这里就不赘述了。<br>总结一下Groovy的类相比Java的一些不同，或者说是优化的一些地方：</p>
<ul>
<li>表达式后面的分号是可选的</li>
<li>每个类、构造方法和方法默认是public的</li>
<li>在Groovy中，方法体中的最后一个表达式的值会被作为返回值。这意味着return语句是可选的</li>
<li>Groovy编译器自动加上getter/setter方法，所以不需要自己去书写</li>
<li>类的属性可以通过点号来获取，看起来好像它们在Java中是public的，在底层Groovy调用的是自动生成的getter/setter方法。</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包<a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>，在Groovy中是很重要的一种数据类型。闭包实际上就是一段代码块，需要用{}包括起来。前面我们在讲解一些例子的时候已经用到了闭包，我们再来看一下闭包的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义一个闭包 ，记得要用&#123;&#125;包裹起来</span><br><span class="line">def aClosure=&#123;</span><br><span class="line">	int a,int b-&gt; //-&gt; 箭头前面代表的是参数，后面是执行语句</span><br><span class="line">	a+b  //返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println aClosure(1,2)</span><br></pre></td></tr></table></figure>
<p>结果为 3。</p>
<p>闭包的参数类型也可以不指定，在运行期有Groovy自动推断，比如下面这个例子，执行起来也是没有问题的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def bClosure=&#123;</span><br><span class="line">	 a,b-&gt;</span><br><span class="line">	a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println bClosure(1,2)</span><br></pre></td></tr></table></figure>
<p>闭包也可以没有参数,如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def aa=&#123;</span><br><span class="line">	println &quot;this is a Closure&quot;</span><br><span class="line">&#125;</span><br><span class="line">aa()</span><br></pre></td></tr></table></figure>
<p>总结一下，闭包的类型有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. def closureNama =&#123;params -&gt; code&#125; </span><br><span class="line">2. def closureName= &#123;code&#125; 没有参数的时候就没有箭头 -&gt;</span><br></pre></td></tr></table></figure>
<p>闭包的调用有两种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 闭包对象.call(参数)</span><br><span class="line">2. 闭包对象(参数)</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">aClosure(1,2)</span><br><span class="line">aClosure.call(1,2)</span><br></pre></td></tr></table></figure>
<p>需要注意一点，闭包如果没有参数的话，其隐含了一个参数是 <code>it</code>。<br>和this的作用类似，代表的是传入闭包的参数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sayHello=&#123;&quot;hello $&#123;it&#125;&quot;&#125;</span><br><span class="line">println sayHello(&quot;Jim&quot;)</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">def sayHello=&#123;it-&gt;&quot;hello $&#123;it&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，如果闭包显示的指明了无参数，则在调用闭包的时候不能传参数，否则会报错。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def noParams=&#123;-&gt;println &quot;noParams&quot;&#125;</span><br><span class="line">noParams();</span><br><span class="line">//下面的代码执行会报错</span><br><span class="line">//noParams(1)</span><br></pre></td></tr></table></figure></p>
<p><strong>闭包返回值</strong></p>
<p>闭包总是会返回一个值。返回值是闭包的最后一条语句的值（如果没有显式的return语句），或者是可执行的return 语句的值。如果闭包的最后一条语句没有值就返回null。如之前举得Hello.groovy中的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getMsg=&#123;</span><br><span class="line">	new HelloWorld().msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>闭包作为方法参数</strong></p>
<p>闭包也可以作为方法参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int increment(Closure closure,int count)&#123;</span><br><span class="line">	closure()+count</span><br><span class="line">&#125;</span><br><span class="line">//断言，如果为true就正常执行，如果为false，就会报错</span><br><span class="line">assert increment(&#123;1+1&#125;,1)==3</span><br></pre></td></tr></table></figure>
<p><strong>闭包委托</strong></p>
<p>闭包代码是在委托的闭包上执行。默认的，这个委托就是闭包的所有者。比如你在Groovy脚本中定义了一个闭包，那么所有者就是一个groovy.lang.Script实例。闭包的隐式变量delegate 允许你重新定义默认的所有者。</p>
<p>例如：</p>
<pre><code>class Test {
    def x = 30
    def y = 40

    def run() {
        def data = [ x: 10, y: 20 ]
        def cl = { 
             y = x + y 
        }
        cl.delegate = data
        cl.resolveStrategy = Closure.DELEGATE_FIRST
        cl()
        assert x == 30
        assert y == 40
        assert data == [x:10, y:30]
    }
}

new Test().run()
</code></pre><p>上面例子中闭包c1的委托变为data，闭包的resolveStrategy在默认情况下是OWNER_FIRST，即它会先查找闭包的owner（在本例中指的就是Test对象本身），如果owner存在，则在owner上执行闭包中的代码。这里我们将其设置成了DELEGATE_FIRST，即该闭包会首先查找delegate（本例中即data），如果找不到再去找owner。resolveStrategy还有其它的一些情况，具体的可以查看文档中的例子，相信当你看到这些例子后，会对闭包委托有一个清晰的认识。</p>
<ul>
<li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#DELEGATE_FIRST" target="_blank" rel="noopener">Closure.DELEGATE_FIRST</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#DELEGATE_ONLY" target="_blank" rel="noopener">Closure.DELEGATE_ONLY</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#OWNER_FIRST" target="_blank" rel="noopener">Closure.OWNER_FIRST</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#OWNER_ONLY" target="_blank" rel="noopener">Closure.OWNER_ONLY</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#TO_SELF" target="_blank" rel="noopener">Closure.TO_SELF</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>限于篇幅和本系列的主题，本文简单介绍了Groovy的一些语法和数据结构，这对于学习Gradle会有一些帮助。在后面Gradle的学习过程中，如果对Groovy的一些Api不熟悉可以查看<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="noopener">Groovy的Api文档</a>，我们没必要死记硬背这个Api，掌握学习的方法更加重要，对吗？</p>
<p><a href="http://www.jianshu.com/p/158851436e82" target="_blank" rel="noopener">下一篇</a>，我们就正式进入Gradle部分的学习了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">Groovy文档</a></li>
<li><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Android之Gradle</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
