<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/Android四大组件——Service的工作过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Android四大组件——Service的工作过程分析/" itemprop="url">Android四大组件——Service的工作过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T11:00:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>启动Service分为两种方式，分别是start方式和bind方式。</p>
<p>start方式对应的是Service由Context.startService(Intent service)方法来启动，从创建到销毁经历的生命周期方法是onCreate、onStartCommand、onDestory。已经在后台运行的Service，如果外界调用Context.stopService(Intent service)方法或者Service自己调用stopSelf()方法，Service会执行onDestory生命周期方法，然后结束运行。start状态的Service与Activity相互独立，即使Activity销毁，Service还是会存在。每次start方式启动Service，其onStartCommand方法均会被调用。</p>
<p>bind方式对应的是Service由Context.bindService(Intent service, ServiceConnection conn,  int flags)方法来启动，从创建到销毁经历的生命周期方法是onCreate、onBind、onUnbind、onDestory。bind状态的Service与Activity相互关联，可以认为Service与Activity的生命周期绑定。多次bind启动同一个Service，其onBind方法只会被调用一次。bind启动的Service，可以调用Context.unbindService(ServiceConnection conn)方法来解除绑定，Activity销毁的时候也会自动与bind状态的Service解除绑定。当Service上的所有绑定都解除后，Service会被销毁。</p>
<blockquote>
<p>注意：Service的周期方法中不管是多次start还是多次bind启动，onCreate方法只会调用一次。Service不同状态的启动方法和销毁方法是对应的，假如用start方式启动，调用unbind是没有效果的，只有调用对用的stop方法才可以销毁Service；反之同理。</p>
</blockquote>
<p>简单来说，start状态和bind状态的区别有4点：</p>
<p>a. 启动方式不同<br>b. 生命周期阶段不同<br>c. 销毁方式不同。<br>d. 交互不同，以start方式启动的Service，组件与Service是无法交互的。以bind方式启动的Service，组件可以与Service进行交互。</p>
<p>Service可以以start方式和bind方式混合启动，如果一个Service通过start方式和bind方式启动，想要停止这个Service的话，它的stopService和unbindService都要调用，调用顺序没有关系，只调用一个是无法停止Service的。还要注意一点，多次startService只要一次stopService就可以了，但是如果多次bindService就需要多次unBindService，或者与Service绑定的组件结束其生命周期。</p>
<p>下面按照start方式和bind方式来分别介绍Service的启动过程。</p>
<h1 id="start方式启动"><a href="#start方式启动" class="headerlink" title="start方式启动"></a>start方式启动</h1><p>不管是start方式还是bind方式，启动一个Service都是通过ContextWrapper的方法来的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContextWrapper</span><br><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    return mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最终它还是通过mBase来启动，这是典型的桥接模式。Application、Activity、Service在对象创建完毕之后第一件事就是调用他们自身的attach方法，在attach方法中又会调用attachBaseContext方法，进而对mBase进行赋值。这个mBase实际上就是ContextImpl对象，ContextImpl的创建过程在<a href="https://www.jianshu.com/p/7bab8afb6de0" target="_blank" rel="noopener">Activity启动过程之生命周期方法回调分析</a>中也有介绍。</p>
<p>我们直接看一下ContextImpl的startService方法，这个方法后面调用了startServiceCommon方法。而startServiceCommon中通过ActivityManagerNative的getDefault对象去startService。相信看过<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>这篇文章的应该很明白，ActivityManagerNative.getDefault()获取的是ActivityManagerService在本地进程的一个代理对象，通过Binder机制，进行一次IPC过程调用到ActivityManagerService的startService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (cn != null) &#123;</span><br><span class="line">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Not allowed to start service &quot; + service</span><br><span class="line">                                + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Unable to start service &quot; + service</span><br><span class="line">                                + &quot;: &quot; + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cn;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerNative相关内容我们就不多做介绍了，直接看一下ActivityManagerService的startService方法。在该方法中又会调用mServices的startServiceLocked方法，这个mServices是ActiveServices类型，用来是辅助AMS对Service进行启动管理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">                                  String resolvedType, String callingPackage, int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">   ...</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActiveServices的startServiceLocked中会对所要启动的Service进行检查，包括其它一些安全方面的校验。如果所有的检查都通过，就会调用ActiveServices自身的startServiceInnerLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">                                 int callingPid, int callingUid, String callingPackage, final int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">  ...</span><br><span class="line">    // 对所要启动的Service进行检查</span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                    callingPid, callingUid, userId, true, callerFg, false);</span><br><span class="line">    if (res == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res.record == null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!&quot;, res.permission != null</span><br><span class="line">                ? res.permission : &quot;private to package&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActiveServices的startServiceInnerLocked中，会继续调用bringUpServiceLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">                                      boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">  ...</span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    return r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActiveServices的startServiceInnerLocked中，如注释1处，首先判断当前的Service是否已经启动过，如果已经启动多的话会通过一个IPC过程调用ApplicationThread的scheduleServiceArgs，然后通过Hander的切换调用到ActivityThread的handleServiceArgs方法，进而调用Service的onStartCommand方法。这里我们先不细说了，继续分析Service的启动过程。</p>
<p>在这个方法中还是根据当前启动的Service是否需要一个独立的进程，如果不需要独立的进程并且当前的进程已经存在的话就会调用realStartServiceLocked。如果进程不存在话还会先创建一个进程，进程的创建是通过ActivityManagerService的startProcessLocked方法来进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">                                    boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    //Slog.i(TAG, &quot;Bring up service:&quot;);</span><br><span class="line">    //r.dump(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line"> //  1 判断当前的Service是否已经启动过</span><br><span class="line">    if (r.app != null &amp;&amp; r.app.thread != null) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!whileRestarting &amp;&amp; r.restartDelay &gt; 0) &#123;</span><br><span class="line">        // If waiting for a restart, then do nothing.</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Bringing up &quot; + r + &quot; &quot; + r.intent);</span><br><span class="line"></span><br><span class="line">    // We are now bringing the service up, so no longer in the</span><br><span class="line">    // restarting state.</span><br><span class="line">    if (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure this service is no longer considered delayed, we are starting it now.</span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (bring up): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure that the user who owns this service is started.  If not,</span><br><span class="line">    // we don&apos;t want to allow it to run.</span><br><span class="line">    if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                + r.intent.getIntent() + &quot;: user &quot; + r.userId + &quot; is stopped&quot;;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Service is now being launched, its package can&apos;t be stopped.</span><br><span class="line">    try &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, false, r.userId);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                + r.packageName + &quot;: &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 2 判断是否需要独立的进程</span><br><span class="line">    final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;</span><br><span class="line">    final String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">        if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid</span><br><span class="line">                + &quot; app=&quot; + app);</span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">      // 3 进程存在，</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                return null;</span><br><span class="line">            &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If this service runs in an isolated process, then each time</span><br><span class="line">        // we call startProcessLocked() we will get a new isolated</span><br><span class="line">        // process, starting another process if we are currently waiting</span><br><span class="line">        // for a previous process to come up.  To deal with this, we store</span><br><span class="line">        // in the service any current isolated process it is running in or</span><br><span class="line">        // waiting to have come up.</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Not running -- get it started, and enqueue this service record</span><br><span class="line">    // to be executed when the app comes up.</span><br><span class="line">    // 4 进程不存在，需要创建进程</span><br><span class="line">    if (app == null &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;</span><br><span class="line">            String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                    + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                    + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                    + r.intent.getIntent() + &quot;: process is bad&quot;;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (in bring up): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设进程已经存在，现在开始分析ActiveServices的realStartServiceLocked方法，看名字也能猜到，在这里是真的要启动一个Service了。在该方法中有一段代码<code>app.thread.scheduleCreateService</code>，app.thread 表示的就是IApplicationThread在本地的一个代理，这个方法通过一个IPC过程会调用到ApplicationThread的scheduleCreateService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">                                          ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">    if (app.thread == null) &#123;</span><br><span class="line">        throw new RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    final boolean newService = app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">    mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    boolean created = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">            String nameTerm;</span><br><span class="line">            int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">            nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        // 1 通过IPC过程创建Service</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Application dead when creating service &quot; + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!created) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            // Cleanup.</span><br><span class="line">            if (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Retry.</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    // If the service is in the started state, and there are no</span><br><span class="line">    // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">    // be called.</span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2 在该方法中会通过IPC过程调动Service的onStartCommand方法</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下，ApplicationThread的scheduleCreateService方法，其实ApplicationThread的中的方法都像套路一样，均会发送一个消息，然后进入ActivityThread的内部类H的handleMessage方法中。这个传递的参数对象是一个CreateServiceData，就是一个JavaBean对象，封装了IBinder、ServiceInfo、CompatibilityInfo，可以看到这里面传递的也是一个IBinder的token，这个token就是用于识别这个对应的Service。AMS那边实际上存的也是这个token。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">                                        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    CreateServiceData s = new CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Handler中又会调用ActivityThread的handleCreateService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">    。。。</span><br><span class="line">        case CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityThread的handleCreateService方法中，做的事情清晰明了，其实与Activity的创建过程类似，可以查看<a href="https://www.jianshu.com/p/7bab8afb6de0" target="_blank" rel="noopener">Activity启动过程之生命周期方法回调分析</a>。</p>
<ol>
<li>通过getPackageInfoNoCheck方法获取LoadedApk对象</li>
<li>通过LoadedApk中的ClassLoader对象创建Service对象，对于一个已经安装的Apk来讲，这个ClassLoader一般指的就是PathClassLoader。</li>
<li>创建ContextImpl对象</li>
<li>调用LoadedApk的makeApplication创建Application对象，一个LoadedApk只会对应一个Application，如果已经存在的话直接返回该对象。</li>
<li>调用attach方法，绑定一些必须的参数，注意这个context就是ContextImpl对象，也就是我们之前讲的在ContextWrapper中获取的mBase对象就是它</li>
<li>调用Service的onCreate方法</li>
<li>mServices.put(data.token, service)，用于缓存一个App进程中已经创建的Service</li>
<li>通过IPC调用AMS的serviceDoneExecuting方法，这个传递的type是SERVICE_DONE_EXECUTING_ANON类型，实际上在AMS那边是没有做处理的。这里我们暂时不分析它。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread</span><br><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    // 1 获取LoadedApk对象</span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = null;</span><br><span class="line">    // 2 创建Service对象</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">        // 3 创建ContextImpl对象，</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        </span><br><span class="line">        //4 调用LoadedApk的makeApplication创建Application对象，一个LoadedApk只会对应一个Application</span><br><span class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        // 5 调用attach方法，绑定一些必须的参数，注意这个context就是ContextImpl对象，也就是我们之前讲的在ContextWrapper中获取的mBase对象就是它</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        // 6 调用Service的onCreate方法</span><br><span class="line">        service.onCreate();</span><br><span class="line">        // 7 存储起来</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        // 8 通过IPC调用AMS的serviceDoneExecuting方法</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法执行完毕之后，这次IPC过程就结束了。但是AMS那边的方法还没有执行完毕呢？<br>我们接着分析realStartServiceLocked方法。<br>在这个方法中实际上还会尝试通过requestServiceBindingsLocked进而来调用bindService的方法，不过因为我们是以start方式启动的，因此ServiceRecord中是没有bind意图的，因此也不会调用bind方法，这里我们就不分析它了，留到在bind方式启动的时候再来看它。<br>在方法中还会调用sendServiceArgsLocked方法，该方法中会通过IPC过程调动Service的onStartCommand方法，还记得我们之前说过吗，如果Service已经创建的话实际上ActiveServices就是会直接调用sendServiceArgsLocked这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">                                          ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">...</span><br><span class="line">        // 1 通过IPC过程创建Service</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    // 2 请求调用bindService</span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">  </span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    // If the service is in the started state, and there are no</span><br><span class="line">    // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">    // be called.</span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3 在该方法中会通过IPC过程调动Service的onStartCommand方法</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下ActiveServices的sendServiceArgsLocked方法，在该方法中会调用r.app.thread.scheduleServiceArgs方法，这是一个IPC过程，调用ApplicationThread的 scheduleServiceArgs方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,</span><br><span class="line">                                         boolean oomAdjusted) throws TransactionTooLargeException &#123;</span><br><span class="line">    final int N = r.pendingStarts.size();</span><br><span class="line">    if (N == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (r.pendingStarts.size() &gt; 0) &#123;</span><br><span class="line">        Exception caughtException = null;</span><br><span class="line">        ServiceRecord.StartItem si = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            si = r.pendingStarts.remove(0);</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Sending arguments to: &quot;</span><br><span class="line">                    + r + &quot; &quot; + r.intent + &quot; args=&quot; + si.intent);</span><br><span class="line">            if (si.intent == null &amp;&amp; N &gt; 1) &#123;</span><br><span class="line">                // If somehow we got a dummy null intent in the middle,</span><br><span class="line">                // then skip it.  DO NOT skip a null intent when it is</span><br><span class="line">                // the only one in the list -- this is to support the</span><br><span class="line">                // onStartCommand(null) case.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.deliveredStarts.add(si);</span><br><span class="line">            si.deliveryCount++;</span><br><span class="line">            if (si.neededGrants != null) &#123;</span><br><span class="line">                mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                        si.getUriPermissionsLocked());</span><br><span class="line">            &#125;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</span><br><span class="line">            if (!oomAdjusted) &#123;</span><br><span class="line">                oomAdjusted = true;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line">            int flags = 0;</span><br><span class="line">            if (si.deliveryCount &gt; 1) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            if (si.doneExecutingCount &gt; 0) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">            &#125;</span><br><span class="line">           // 1 通过IPC调用ApplicationThread的 scheduleServiceArgs方法</span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line">        &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,</span><br><span class="line">                                      int flags ,Intent args) &#123;</span><br><span class="line">    ServiceArgsData s = new ServiceArgsData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.taskRemoved = taskRemoved;</span><br><span class="line">    s.startId = startId;</span><br><span class="line">    s.flags = flags;</span><br><span class="line">    s.args = args;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">...</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case SERVICE_ARGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">   ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下ActivityThread的handleServiceArgs方法，该方法比较简单</p>
<ol>
<li>就是首先通过token从mServices中获取对应的Service</li>
<li>给Intent设置extrasClassLoader，主要是为了反序列化Intent中携带的一个Parcelable类型的对象</li>
<li>调用Service的onStartCommand方法，获取其返回值</li>
<li>通过IPC告知AMS调用结果，注意这个时候把onStartCommand的返回值传递过去了，结果类型type为SERVICE_DONE_EXECUTING_START。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    // 1 获取Service</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 2. 给Intent设置extrasClassLoader，主要是为了反序列化Intent中携带的一个Parcelable类型的对象</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            // 3 调用Service的onStartCommand方法</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            </span><br><span class="line">            // 4 通过IPC告知AMS调用结果，注意这个时候把onStartCommand的返回值传递过去了</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to start service &quot; + s</span><br><span class="line">                                + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下ActivityManagerService的serviceDoneExecuting方法，其实也就是做了一下中转，中间做了一下校验，要保证客户端传递来的token是正确的类型。之后会调用ActiveServices的serviceDoneExecutingLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, &quot;serviceDoneExecuting: Invalid service token=&quot; + token);</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 serviceDoneExecutingLocked方法中会根据传递过来的type，来进行对应的处理，此时传递的是SERVICE_DONE_EXECUTING_START，然后就会根据对应的res来进行处理。正常情况下这个res就是Service的onStartCommand的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123;</span><br><span class="line">    boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            // This is a call from a service start...  take care of</span><br><span class="line">            // book-keeping.</span><br><span class="line">            r.callStart = true;</span><br><span class="line">            switch (res) &#123;</span><br><span class="line">                case Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                case Service.START_STICKY: &#123;</span><br><span class="line">                    // We are done with the associated start arguments.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    // Don&apos;t stop if killed.</span><br><span class="line">                    r.stopIfKilled = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_NOT_STICKY: &#123;</span><br><span class="line">                    // We are done with the associated start arguments.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    if (r.getLastStartId() == startId) &#123;</span><br><span class="line">                        // There is no more work, and this service</span><br><span class="line">                        // doesn&apos;t want to hang around if killed.</span><br><span class="line">                        r.stopIfKilled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line">                    // We&apos;ll keep this item until they explicitly</span><br><span class="line">                    // call stop for it, but keep track of the fact</span><br><span class="line">                    // that it was delivered.</span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, false);</span><br><span class="line">                    if (si != null) &#123;</span><br><span class="line">                        si.deliveryCount = 0;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line">                        // Don&apos;t stop if killed.</span><br><span class="line">                        r.stopIfKilled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line">                    // Special processing for onTaskRemoved().  Don&apos;t</span><br><span class="line">                    // impact normal onStartCommand() processing.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default:</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                            &quot;Unknown service start result: &quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">            if (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            // This is the final call from destroying the service...  we should</span><br><span class="line">            // actually be getting rid of the service at this point.  Do some</span><br><span class="line">            // validation of its state, and ensure it will be fully removed.</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                // Not sure what else to do with this...  if it is not actually in the</span><br><span class="line">                // destroying list, we don&apos;t need to make sure to remove it from it.</span><br><span class="line">                // If the app is null, then it was probably removed because the process died,</span><br><span class="line">                // otherwise wtf</span><br><span class="line">                if (r.app != null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Service done with onDestroy, but not inDestroying: &quot;</span><br><span class="line">                            + r + &quot;, app=&quot; + r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (r.executeNesting != 1) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Service done with onDestroy, but executeNesting=&quot;</span><br><span class="line">                        + r.executeNesting + &quot;: &quot; + r);</span><br><span class="line">                // Fake it to keep from ANR due to orphaned entry.</span><br><span class="line">                r.executeNesting = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Done executing unknown service from pid &quot;</span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onStartCommand方法的返回值是int型，返回值有4种。</p>
<ol>
<li><p>START_STICKY_COMPATIBILITY = 0，这个是START_STICKY的兼容版本，被杀死后重启并不保证一定调用onStartCommand方法。这个一般是在android系统小于5 的时候使用。</p>
</li>
<li><p>START_STICKY = 1，当Service已经启动后，如果onStartCommand方法返回值是这个，表示的是如果因内存不足Service被系统杀掉，系统会在后续内存空闲时尝试着重新创建这个Service，但是不会再传递上次启动Service的Intent，onStartCommand中的Intent参数会为null。</p>
</li>
<li><p>START_NOT_STICKY = 2，系统把Service杀死后，不会尝试重新创建这个Service。</p>
</li>
<li><p>START_REDELIVER_INTENT = 3，系统把Service杀死后，会尝试重新创建这个Service，并且会把之前启动Service的最后一个Intent重新传递回来。</p>
</li>
</ol>
<p>到此，我们就分析完Service的start方式启动的过程了。我们小结一下</p>
<p><strong>小结</strong></p>
<ol>
<li><p>startService启动Service调用的是ContextImpl的startService方法，在ContextImpl中通过一个IPC过程调用到AMS端的startService方法，AMS再去委托ActiveServices去对Service的启动进行管理。ActiveServices首先回去校验Service的合法性，如果合法的话判断Service所在进程是否已经启动，如果没有启动的话会先去创建进程再来启动Service。如果Service所在进程已经启动，就会通过一个IPC过程调用ApplicationThread的scheduleCreateService方法，进而调用ActivityThread的handleCreateService方法，完成Service的创建以及绑定上下文环境并调用Service的onCreate方法。</p>
</li>
<li><p>创建Service的IPC过程结果之后，会返回ActiveServices的方法调用处接着执行方法，然后会再通过一个IPC过程来调用Service的onStartCommand方法，并且该方法结束之后会把onStartCommand的返回值告知AMS，AMS又会通知ActiveServices去进行处理。当Service因空间不足被系统杀死后，会根据不同的返回值来对Service进行相应处理。</p>
</li>
</ol>
<h1 id="bind方式启动Service"><a href="#bind方式启动Service" class="headerlink" title="bind方式启动Service"></a>bind方式启动Service</h1><p>前面也说了，startService、bindService均是通过ContextImpl进行。直接看一下ContextImpl的bindService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">                           int flags) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindService方法有3个参数，第一个参数Intent，不同说就是表示启动的Service对应的意图，第2个参数ServiceConnection是一个接口用来监控bind方式启动的Service的连接状态。第3个参数是一个flag，一般传递的是Context.BIND_AUTO_CREATE。</p>
<p>需要说明的是，ServiceConnection的onServiceConnected会在Service的onBind方法返回IBinder对象之后调用，而其onServiceDisconnected是在Service意外挂掉，比如Service被系统杀死的时候才会被回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ServiceConnection</span><br><span class="line">public interface ServiceConnection &#123;</span><br><span class="line">    public void onServiceConnected(ComponentName name, IBinder service);</span><br><span class="line">    public void onServiceDisconnected(ComponentName name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextImpl的bindService方法会调用其bindServiceCommon方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler</span><br><span class="line">        handler, UserHandle user) &#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    if (conn == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;connection is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 1 调用LoadedApk的getServiceDispatcher方法</span><br><span class="line">    if (mPackageInfo != null) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        // 2 通过IPC过程调用AMS的bindService方法</span><br><span class="line">        int res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line">        return res != 0;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package android.app;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line"></span><br><span class="line">oneway interface IServiceConnection &#123;</span><br><span class="line">    void connected(in ComponentName name, IBinder service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindServiceCommon方法中主要完成两件事情。<br>首先会调用LoadedApk的getServiceDispatcher方法，该方法会创建一个IServiceConnection对象，IServiceConnection是用AIDL写的，在这里实际上就是ServiceDispatcher.InnerConnection对象。这是因为ServiceConnection必须借助Binder来让远端server回调自己的方法，但是ServiceConnection不具有跨进程通信的能力，而ServiceDispatcher.InnerConnection是一个Binder对象，刚好可以充当这个跨进程通信的角色。ServiceDispatcher在ServiceDispatcher.InnerConnection和ServiceConnection之间起着桥梁的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk</span><br><span class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</span><br><span class="line">                                                     Context context, Handler handler, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sd == null) &#123;</span><br><span class="line">            sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            if (map == null) &#123;</span><br><span class="line">                map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        return sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法中mServices是一个ArrayMap，存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系。键表示一个Context，说明每个Context对象中是可以存放一组映射关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span><br><span class="line">        = new ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>系统首先会搜索ServiceConnection对应 ServiceDispatcher是否存在，如果不存在的话会创建一个ServiceDispatcher对象，在ServiceDispatcher的构造方法中会创建一个InnerConnection对象并持有ServiceDispatcher的引用，而ServiceDispatcher中又持有ServiceConnection的引用，因此当服务端回调的时候可以通过InnerConnection间接的找到ServiceConnection，回调它的方法。</p>
<p>接着分析ContextImpl的bindServiceCommon方法，LoadedApk的getServiceDispatcher返回一个IServiceConnection对象（InnerConnection类型），接着通过一个IPC过程调用了AMS的bindService方法来完成Service的绑定过程，注意此时把IServiceConnection对象传递到了服务端，当然了，服务端拿到的实际上是IServiceConnection的代理对象。</p>
<p>看一下AMS的bindService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int bindService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">                       String resolvedType, IServiceConnection connection, int flags, String callingPackage,</span><br><span class="line">                       int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;bindService&quot;);</span><br><span class="line"></span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callingPackage == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindService中主要做了一些校验，接下来，AMS会调用ActiveServices的bindServiceLocked方法。bindServiceLocked方法会调用bringUpServiceLocked，bringUpServiceLocked会调用realStartServiceLocked方法，realStartServiceLocked方法和之前讲的start方式启动Service的逻辑一致，均是通过ApplicationThread来完成Service的创建并执行其onCreate方法，这里就不重复讲解了。和start方式不同的是，在realStartServiceLocked方法中，当执行完<code>app.thread.scheduleCreateService</code>过程，完成Service的创建和onCreate方法回调之后，还会接着调用ActiveServices的requestServiceBindingsLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">                                                  boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">    if (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">        // If service is not currently running, can&apos;t yet bind.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            if (!rebind) &#123;</span><br><span class="line">                i.requested = true;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = true;</span><br><span class="line">            i.doRebind = false;</span><br><span class="line">        &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r, e);</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r);</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service有一个特性，同一个ServiceConnection多次绑定一个Service，Service的onBind方法只会被调用一次。一个ServiceConnection对应AMS端的一个IntentBindRecord。在上面的代码中也可以看出，对于同一个IntentBindRecord只会调用onBind一次。</p>
<p>在ActiveServices的bindServiceLocked方法中会调用ServiceRecord的retrieveAppBindingLocked方法，在这里会用一个Map集合bindings存放bind信息。Intent.FilterComparison是键，它实际上包裹了一个请求Service的Intent，比较两个Intent.FilterComparison是否相等是根据Intent的filterHashCode方法，这个与Intent的mAction、mType、mType、mPackage、mComponent、mCategories有关。我们知道，5.0以上的系统，Service只能够显式启动。具体的是在ContextImpl的validateServiceIntent方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings</span><br><span class="line">            = new ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;();</span><br></pre></td></tr></table></figure>
<p>在requestServiceBindingLocked中， <code>r.app.thread</code>指的就是ApplicationThread的本地代理对象，通过一个IPC过程调用到ApplicationThread的scheduleBindService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">                                      boolean rebind, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    BindServiceData s = new BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;scheduleBindService token=&quot; + token + &quot; intent=&quot; + intent + &quot; uid=&quot;</span><br><span class="line">                + Binder.getCallingUid() + &quot; pid=&quot; + Binder.getCallingPid());</span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种套路我们已经分析太多了，通过Handler H来发送一个H.BIND_SERVICE消息。然后会交给ActivityThread的handleBindService方法。在该方法中首先根据token获取对应的Service，然后给Intent设置extrasClassLoader， 如果不是重新绑定，就调用Service的onBind方法，并且返回IBinder对象，并传递给AMS。如果是重新绑定，调用Service的onRebind方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">    // 1 根据token获取Service</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 2. 给Intent设置extrasClassLoader</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 3 如果不是重新绑定，就调用Service的onBind方法，并且返回IBinder对象，并传递给AMS</span><br><span class="line">                if (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 4 如果是重新绑定，直接调用Service的onRebind方法</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to bind to service &quot; + s</span><br><span class="line">                                + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Service的onBind方法调用之后，会通过IPC过程调用AMS的publishService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，AMS的publishService方法将具体的工作交给了ActiveServices来完成，调用了它的publishServiceLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r</span><br><span class="line">                + &quot; &quot; + intent + &quot;: &quot; + service);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = new Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            if (b != null &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = true;</span><br><span class="line">                b.received = true;</span><br><span class="line">                for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    for (int i=0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        if (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                         ...</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Publishing to: &quot; + c);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                           ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>publishServiceLocked方法中看起来很多，核心点就一个地方<code>c.conn.connected(r.name, service)</code>。c的类型是ConnectionRecord，c.conn返回的是IServiceConnection对象，实际上就是一个本地代理。真实的对象是ServiceDispatcher.InnerConnection。<code>c.conn.connected</code>实际上就是一个IPC过程调用到ServiceDispatcher.InnerConnection的connected方法。参数中的service就是调用Service的onBind方法返回的Ibinder对象。</p>
<p>来看一下ServiceDispatcher.InnerConnection的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher.InnerConnection</span><br><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">    final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void connected(ComponentName name, IBinder service) throws RemoteException &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">        if (sd != null) &#123;</span><br><span class="line">            sd.connected(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InnerConnection的connected方法中会调用ServiceDispatcher的connected方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher</span><br><span class="line">public void connected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    if (mActivityThread != null) &#123;</span><br><span class="line">        mActivityThread.post(new RunConnection(name, service, 0));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mActivityThread是一个Handler，实际上就是ActivityThread的H这个Handler，是在ContextImpl的bindService方法中一路传递过来的，作为了ServiceDispatcher的成员变量。所以mActivityThread不为null，就会调用Handler的post方法来切换到主线程中。后面RunConnection的run方法会执行。注意此时传递的第三个参数为0。</p>
<p>看一下RunConnection。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher.RunConnection</span><br><span class="line">private final class RunConnection implements Runnable &#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, int command) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (mCommand == 0) &#123;</span><br><span class="line">            doConnected(mName, mService);</span><br><span class="line">        &#125; else if (mCommand == 1) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ComponentName mName;</span><br><span class="line">    final IBinder mService;</span><br><span class="line">    final int mCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunConnection是ServiceDispatcher的非静态内部类，在run方法中又调用了ServiceDispatcher的doConnected方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher</span><br><span class="line">public void doConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mForgotten) &#123;</span><br><span class="line">            // We unbound before receiving the connection; ignore</span><br><span class="line">            // any connection received.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        if (old != null &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            // Huh, already have this one.  Oh well!</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (service != null) &#123;</span><br><span class="line">            // A new service is being connected... set it all up.</span><br><span class="line">            info = new ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = new DeathMonitor(name, service);</span><br><span class="line">            try &#123;</span><br><span class="line">                service.linkToDeath(info.deathMonitor, 0);</span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                // This service was dead before we got it...  just</span><br><span class="line">                // don&apos;t do anything with it.</span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // The named service is being disconnected... clean up.</span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (old != null) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If there was an old service, it is not disconnected.</span><br><span class="line">    if (old != null) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    // If there is a new service, it is now connected.</span><br><span class="line">    if (service != null) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ServiceDispatcher的doConnected方法最后，调用了mConnection的onServiceConnected方法，也就是调用了在bindService的时候传递的ServiceConnection的onServiceConnected方法。</p>
<p>到此，Service的bind启动过程也分析完毕了。</p>
<p>至于Service的unBind过程，会调用到ActiveServices的unbindServiceLocked方法，在该方法中又调用removeConnectionLocked方法。会去移除ServiceConnetion，当Service上所有的bind 的ServiceConnetion都移除的时候，会通过IPC调用ApplicationThread的scheduleUnbindService方法，然后调用Service的unBind方法。接下来，unbindServiceLocked中还会调用其bringDownServiceLocke方法，在该方法中调用ApplicationThread的scheduleStopService方法，进而调用Service的onDestory方法。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>关于Service的onBind方法只会被调用一次，每一个App对应一个AppBindeRecord，我们要知道一个问题就是一个App是可以bind多个Service的，但是一个App只会对应一个AppBindRecord。</p>
<p>考虑一个问题，App可以bind多个Service，同时一个Service也可以被多个App绑定，这是多对多的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class AppBindRecord &#123;</span><br><span class="line">    final ServiceRecord service;    // The running service.</span><br><span class="line">    final IntentBindRecord intent;  // The intent we are bound to.</span><br><span class="line">    final ProcessRecord client;     // Who has started/bound the service.</span><br><span class="line"></span><br><span class="line">    final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;&gt;();</span><br><span class="line">                                    // All ConnectionRecord for this client.</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final class IntentBindRecord &#123;</span><br><span class="line">    /** The running service. */</span><br><span class="line">    final ServiceRecord service;</span><br><span class="line">    /** The intent that is bound.*/</span><br><span class="line">    final Intent.FilterComparison intent; // </span><br><span class="line">    /** All apps that have bound to this Intent. */</span><br><span class="line">    final ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps</span><br><span class="line">            = new ArrayMap&lt;ProcessRecord, AppBindRecord&gt;();</span><br><span class="line">    /** Binder published from service. */</span><br><span class="line">    IBinder binder;</span><br><span class="line">    /** Set when we have initiated a request for this binder. */</span><br><span class="line">    boolean requested;</span><br><span class="line">    /** Set when we have received the requested binder. */</span><br><span class="line">    boolean received;</span><br><span class="line">    /** Set when we still need to tell the service all clients are unbound. */</span><br><span class="line">    boolean hasBound;</span><br><span class="line">    /** Set when the service&apos;s onUnbind() has asked to be told about new clients. */</span><br><span class="line">    boolean doRebind;</span><br><span class="line">    </span><br><span class="line">    String stringName;      // caching of toString</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/Activity启动过程之生命周期方法回调分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/Activity启动过程之生命周期方法回调分析/" itemprop="url">Activity启动过程之生命周期方法回调分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T21:25:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前的文章<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>和<a href="https://www.jianshu.com/p/61807be57916" target="_blank" rel="noopener">Hook一个Activity的启动过程</a>中均分析了Activity的启动过程，不过前者的分析侧重点在AMS这块，而后者侧重寻找启动过程的Hook点。</p>
<p>而本文要分析一下Activity的具体创建过程和需要关注的一些地方，这也为了理解插件化机制打下一个好的基础。AMS通过Binder调用ApplicationThread的scheduleLaunchActivity方法，我们就以这个方法开始分析。</p>
<p>scheduleLaunchActivity方法中的第2个参数，还记得我们上文<a href="https://www.jianshu.com/p/61807be57916" target="_blank" rel="noopener">Hook一个Activity的启动过程</a>讲的吗，这个token就是用于标示Activity启动相关的一个记录，AMS就是通过这个token来控制Activity的生命周期方法的调用，ActivityThread这端就是通过token来获取对应的ActivityClientRecord，进而对对应的Activity进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationThread的scheduleLaunchActivity方法是在Binder线程池中调用，所以通过发送一个H.LAUNCH_ACTIVITY的消息通过H 和这个Hander来切换到主线程，在其handleMessage方法中会调用ActivityThread的handleLaunchActivity方法。注意在此之前调用了ActivityThread的getPackageInfoNoCheck方法，该方法用于获取一个LoadedApk对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadedApk对象的注释是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local state maintained about a currently loaded .apk.</span><br></pre></td></tr></table></figure>
<p>意思就是LoadedApk表示的是当前被加载的Apk文件对应的一个数据对象。<br>getPackageInfoNoCheck方法这里我们先不介绍，回头再介绍插件化相关知识的时候再来说明。</p>
<p>接下来看一下ActivityThread的handleLaunchActivity方法，在该方法中主要干了两件事，一件是调用performLaunchActivity方法创建Activity，attach上下文，并执行Activity的onCreate、onStart、onRestoreInstanceState等方法。在handleResumeActivity方法中回调Activity的onResume方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看一下performLaunchActivity方法，先从ActivityClientRecord获取ActivityInfo，这个ActivityInfo表示的就是在AndroidManifest.xml中一个activity标签所代表的Activity信息。r.packageInfo 表示的是LoadedApk对象，如果该对象为null就会调用一个public的getPackageInfo方法来获取LoadedApk，还记得我们之前说的getPackageInfoNoCheck方法吗，其实他们最终都是调用一个private的getPackageInfo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">// ActivityInfo表示的就是在AndroidManifest.xml中一个activity标签所代表的Activity信息。</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 在该方法中，下面这段代码表示的是如果是隐式调用，需要通过PackageManager来进行解析，获取正确的跳转对象。</span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 通过LoadedApk中的ClassLoader来创建Activity</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">       // 通过LoadedApk来穿件Application对象</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                        + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                        + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                        + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                        + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            // 实际上创建的是ComtextImpl对象</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (r.overrideConfig != null) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            Window window = null;</span><br><span class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = null;</span><br><span class="line">                r.mPendingRemoveWindowManager = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 调用attach方法，关联一些必要的对象，比如创建Window对象，绑定上下文等</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            // 调用Instrumentation的callActivityOnCreate方法，会回调Activity的onCreate方法</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">          // 如果还没有调用Finish方法，就接着调用Activity的performStart方法，其实还是通过Instrumentation来调用Activity的onStart方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         // 如果还没有调用Finish方法，就接着调用Instrumentation的callActivityOnRestoreInstanceState方法，会回调Activity的onRestoreInstanceState方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           // 如果还没有调用Finish方法，就接着调用Instrumentation的callActivityOnPostCreate方法，会回调Activity的onPostCreate方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                            &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                    &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line">        </span><br><span class="line">        // 到这里把token和对应的ActivityClientRecord放在ArrayMap mActivities中</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to start activity &quot; + component</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们在注释中大致讲了一下Activity的创建流程，下面我们来关注一下细节，Instrumentation通过调用newActivity方法来创建Activity，我们来看一下这个方法干了什么。代码很简单，就是通过ClassLoader去加载Class并创建对象。注意这个ClassLoader是从LoadedApk中获取的。这个LoadedApk表示的是当前正在运行的App。</p>
<p>那么我们在这里想一想，如果要加载一个未安装的Apk，该怎么去加载呢，可不可以想办法构造一个未安装的Apk对应的LoadedApk对象，并让它的ClassLoader变为DexClassLoader，而DexClassLoader是可以加载一个未安装的Apk文件中的dex的，这样不就可以实现一个加载未安装Apk中的代码了吗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public Activity newActivity(ClassLoader cl, String className,</span><br><span class="line">                            Intent intent)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们接着分析，创建完Activity对象之后，会调用LoadedApk的makeApplication方法来创建一个Application对象，看一下这个方法。首先Application如果已经创建过的话会赋值给mApplication变量，那么就直接返回mApplication。然后还需要判断需要创建哪个Application对象，如果我们App中没有指定Application，就直接创建android.app.Application对象。如果自定义了Application，就创建指定的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">                                   Instrumentation instrumentation) &#123;</span><br><span class="line">    // 如果已经创建过，直接返回</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    // 根据条件判断创建哪个Application对象</span><br><span class="line">    Application app = null;</span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 也是通过LoadedApk中的ClassLoader来创建Application</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            // 如果包名不是android，还需要初始化上下文ClassLoader</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建ContextImpl对象</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用Instrumentation的newApplication方法来创建Application对象</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 调用Instrumentation的callApplicationOnCreate方法，会回调Application的onCreate方法</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instrumentation的newApplication方法，最后会调用到它的一个静态的newApplication方法，我们来看一下。就是根据传递的className，来创建Application对象，创建完对象之后，还会调用Application的attach方法，在attach方法中会调用attachBaseContext方法，而该方法也是我们应用开发层面能够最早接收到Application的一个回调方法，所以像MultiDex等都要在这个方法中调用比较合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void attach(Context context) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在performLaunchActivity中，当创建完Activity对象和拿到Application对象之后，调用createBaseContextForActivity方法返回一个Context对象，该对象实际上是一个ContextImpl对象。后面会调用Activity的attach方法，这个方法很重要，调用了attachBaseContext方法，设置Activity的baseContext为ContextImpl对象。创建了Window对象并设置Callback为当前的Activity对象，因此Activity可以接收到Window的回调，并且Window对象设置了WindowManager。拿到ActivityThread和Instrumentation的引用，需要说明的是，在整个App进程中，只有一个ActivityThread和Instrumentation对象，所有的Activity中拿到的都是同一个引用。在这个方法中也可以看到，Activity拿到了表示它自身的一个IBinder对象 token。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">                  Instrumentation instr, IBinder token, int ident,</span><br><span class="line">                  Application application, Intent intent, ActivityInfo info,</span><br><span class="line">                  CharSequence title, Activity parent, String id,</span><br><span class="line">                  NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                  Window window) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.uiOptions != 0) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    if (voiceInteractor != null) &#123;</span><br><span class="line">        if (lastNonConfigurationInstances != null) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的attach方法调用之后，紧接着调用了Instrumentation的callActivityOnCreate方法，我们只看两个参数的就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在callActivityOnCreate方法中又调用了Activity的performCreate方法，在performCreate方法中又调用了Activity自身的onCreate方法，在onCreate方法中会把mCalled设置为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">    if (mLastNonConfigurationInstances != null) &#123;</span><br><span class="line">        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mActivityInfo.parentActivityName != null) &#123;</span><br><span class="line">        if (mActionBar == null) &#123;</span><br><span class="line">            mEnableDefaultActionBarUp = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (savedInstanceState != null) &#123;</span><br><span class="line">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null</span><br><span class="line">                ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    getApplication().dispatchActivityCreated(this, savedInstanceState);</span><br><span class="line">    if (mVoiceInteractor != null) &#123;</span><br><span class="line">        mVoiceInteractor.attachActivity(this);</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Activity生命周期方法中，任何一个方法都可能调用finish来结束。所以，在执行onStart、onRestoreInstanceState、onPostCreate等之前，都会判断是否结束了。根据的就是Activity的一个变量mFinished，当Activity中调用finish方法，该变量会为true。后面的生命周期方法就不会再执行了。</p>
<p>在performLaunchActivity方法中其它生命周期方法的回调也很简单，这里就不多讲了，有兴趣的可以自行查看。我们只需要记住一些关键过程就好了。</p>
<p>下面来分析一下ActivityThread的handleResumeActivity方法，该方法先根据传递的参数token来获取对应的ActivityClientRecord，之后就会调用performResumeActivity方法，注意这个返回值是ActivityClientRecord对象，相当于要更新这个记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">    // TODO Push resumeArgs into the activity for consideration</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一下performResumeActivity方法，在该方法中如果ActivityClientRecord 的pendingIntents不为null，就会调用 <code>deliverNewIntents(r, r.pendingIntents)</code> ，最终会回调Activity的onNewIntent方法。后面<code>r.activity.performResume()</code>会调用到Activity的performResume方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token,</span><br><span class="line">                                                        boolean clearHide, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r</span><br><span class="line">            + &quot; finished=&quot; + r.activity.mFinished);</span><br><span class="line">    if (r != null &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">        if (clearHide) &#123;</span><br><span class="line">            r.hideForNow = false;</span><br><span class="line">            r.activity.mStartedActivity = false;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            r.activity.onStateNotSaved();</span><br><span class="line">            r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">            if (r.pendingIntents != null) &#123;</span><br><span class="line">                // 回调Activity的onNewIntent方法</span><br><span class="line">                deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">                r.pendingIntents = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.pendingResults != null) &#123;</span><br><span class="line">                deliverResults(r, r.pendingResults);</span><br><span class="line">                r.pendingResults = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 调用Activity的performResume方法</span><br><span class="line">            r.activity.performResume();</span><br><span class="line"></span><br><span class="line">            // If there is a pending local relaunch that was requested when the activity was</span><br><span class="line">            // paused, it will put the activity into paused state when it finally happens.</span><br><span class="line">            // Since the activity resumed before being relaunched, we don&apos;t want that to happen,</span><br><span class="line">            // so we need to clear the request to relaunch paused.</span><br><span class="line">            for (int i = mRelaunchingActivities.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                final ActivityClientRecord relaunching = mRelaunchingActivities.get(i);</span><br><span class="line">                if (relaunching.token == r.token</span><br><span class="line">                        &amp;&amp; relaunching.onlyLocalRequest &amp;&amp; relaunching.startsNotResumed) &#123;</span><br><span class="line">                    relaunching.startsNotResumed = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(),</span><br><span class="line">                    r.activity.getComponentName().getClassName(), reason);</span><br><span class="line"></span><br><span class="line">            r.paused = false;</span><br><span class="line">            r.stopped = false;</span><br><span class="line">            r.state = null;</span><br><span class="line">            r.persistentState = null;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to resume activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Activity的performResume方法中会执行performRestart方法，但是也是通过Instrumentation来执行具体的onRestart、onStart方法，不过该方法执行的前提是已经执行了onStop方法。这里面没有什么难点，无非就是通过Instrumentation执行Activity的生命周期方法，后面接着会执行onResume、onPostResume方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">    performRestart();</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">    mCalled = false;</span><br><span class="line">    // mResumed is set by the instrumentation</span><br><span class="line">    mInstrumentation.callActivityOnResume(this);</span><br><span class="line">    if (!mCalled) &#123;</span><br><span class="line">        throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onResume()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // invisible activities must be finished before onResume() completes</span><br><span class="line">    if (!mVisibleFromClient &amp;&amp; !mFinished) &#123;</span><br><span class="line">        Log.w(TAG, &quot;An activity without a UI must call finish() before onResume() completes&quot;);</span><br><span class="line">        if (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt; android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                            &quot; did not call finish() prior to onResume() completing&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now really resume, and install the current status bar and menu.</span><br><span class="line">    mCalled = false;</span><br><span class="line"></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    onPostResume();</span><br><span class="line">    if (!mCalled) &#123;</span><br><span class="line">        throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostResume()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续来分析ActivityThread的handleResumeActivity方法，执行完performResumeActivity方法之后，还有一部分主要用于处理Window的，从Window中取出DecorView，并且调用WindowManager的addView方法，这个具体的调用时通过WindowManager的实现类WindowManagerImpl，实际上这个它也是个不干事的，会继续委托给WindowManagerGlobal来处理，最终会创建ViewRootImpl，并触发整个View视图的绘制流程，这里过程在这里就不详细分析了。不过我们从这个也可以看出，当Activity的onResume方法执行之后，才会开始触发整个View的绘制流程，也就是说实际上在onResume方法中我们是无法获取View的宽高的。在Activity的onWindowFocusChanged方法中如果参数为true，表明Actvity中的视图全部绘制完毕，可以正确的拿到宽高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"> ...</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                        a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                        + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line"></span><br><span class="line">        final int forwardBit = isForward ?</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line"></span><br><span class="line">        // If the window hasn&apos;t yet been added to the window manager,</span><br><span class="line">        // and this guy didn&apos;t finish itself or start another activity,</span><br><span class="line">        // then go ahead and add the window.</span><br><span class="line">        boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">        if (!willBeVisible) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(</span><br><span class="line">                        a.getActivityToken());</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            if (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                r.mPreserveWindow = false;</span><br><span class="line">                // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                // the decor view we have to notify the view root that the</span><br><span class="line">                // callbacks may have changed.</span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                if (impl != null) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the window has already been added, but during resume</span><br><span class="line">            // we started another activity, then don&apos;t yet make the</span><br><span class="line">            // window visible.</span><br><span class="line">        &#125; else if (!willBeVisible) &#123;</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">            r.hideForNow = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Get rid of anything left hanging around.</span><br><span class="line">        cleanUpPendingRemoveWindows(r, false /* force */);</span><br><span class="line"></span><br><span class="line">        // The window is now visible if it has been added, we are not</span><br><span class="line">        // simply finishing, and we are not starting another activity.</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            if (r.newConfig != null) &#123;</span><br><span class="line">                performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig);</span><br><span class="line">                r.newConfig = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;</span><br><span class="line">                    + isForward);</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            if ((l.softInputMode</span><br><span class="line">                    &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                    != forwardBit) &#123;</span><br><span class="line">                l.softInputMode = (l.softInputMode</span><br><span class="line">                        &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                        | forwardBit;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    ViewManager wm = a.getWindowManager();</span><br><span class="line">                    View decor = r.window.getDecorView();</span><br><span class="line">                    wm.updateViewLayout(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.mVisibleFromServer = true;</span><br><span class="line">            mNumVisibleActivities++;</span><br><span class="line">            if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!r.onlyLocalRequest) &#123;</span><br><span class="line">            r.nextIdle = mNewActivities;</span><br><span class="line">            mNewActivities = r;</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">            Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">        &#125;</span><br><span class="line">        r.onlyLocalRequest = false;</span><br><span class="line"></span><br><span class="line">        // Tell the activity manager we have resumed.</span><br><span class="line">        if (reallyResume) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If an exception was thrown when trying to resume, then</span><br><span class="line">        // just end this activity.</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的生命周期方法回调就分析到这里了，在这里我们可以做一下小结：</p>
<ul>
<li>Application和Activity都是通过LoadedApk中的ClassLoader以及className创建。</li>
<li>LoadedApk对象是根据ActivityThread的getPackageInfo方法创建</li>
<li>Application和Activity都要attach一个ContextImpl对象。</li>
<li>在Activity的attach方法中会创建Window对象，也就是说一个Activity对应一个Window对象。</li>
<li>onResume方法之后才开始View视图的绘制</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/JVM的垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/JVM的垃圾回收机制/" itemprop="url">JVM的垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T21:04:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java虚拟机会在执行Java程序的时候把它所管理的内存区域分为若干个不同的数据区域。</p>
<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆区</li>
<li>方法区，方法区中包含运行时常量池</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-235b3bccd4c4bbd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存结构.png"></p>
<p>程序计数器、虚拟机栈、本地方法栈随线程而生随线程而灭。栈中的栈帧，随方法的进入和退出有条不紊的进行入栈出栈操作。每一个栈帧分配多少内存基本上是在类结构确定的时候就知道了。这3个地方不用考虑内存回收的问题，因为方法或者线程退出的时候，内存自然就被回收了。而Java堆和方法区则不一样，内存的分配和回收都是动态的，垃圾回收器所关注的是这部分内存。</p>
<p>Jvm的垃圾回收机制，本质上就是做3件事：</p>
<ol>
<li>确定哪些对象可以被回收</li>
<li>什么时候回收</li>
<li>怎么回收这些对象</li>
</ol>
<h1 id="判断对象时候可以被回收"><a href="#判断对象时候可以被回收" class="headerlink" title="判断对象时候可以被回收"></a>判断对象时候可以被回收</h1><ol>
<li><p>引用计数法，给每个对象增加一个引用计数器，例如一个对象A，每增加一个引用，它的引用计数就加1，每减少一个引用，引用计数就减1。如果该对象的引用计数为0，那么垃圾回收器就认为该对象可以被回收了。这种算法实现起来简单，判定效率也很高，但是有一个缺点，例如，A和B如果互相引用，那它们的引用计数器就永远不为0，也就意味着垃圾回收器永远不会回收它们了，这明显的不合理。</p>
</li>
<li><p>可达性分析算法<br>该算法是在主流的商用领域采用，算法的思想是通过一系列的称为“GC Root”的对象作为起始点，从这个起始点向下搜索，搜索所走过的路径称为引用链，当一个对象到达GC Root没有任何引用链可用，就认为该对象是不可达的，将会被回收。</p>
</li>
</ol>
<p>例如，在下图中，Object5、Object6、Object7到GC Root之间没有引用链，尽管它们之间存在着引用关系，但是它们还是会被回收。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-92323ba50676a96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p>
<p>GC Root实际上也是对象，那么哪些对象可以作为GC Root呢？</p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p><strong>标记-清除算法 Mark-Sweep</strong> ，算法分为标记和清除阶段，首先标记需要被回收的对象，在标记完成后统一回收所有被标记的对象。不足之处有两个：一是效率问题，两个阶段效率都不高，二是空间问题，标记清除之后会产生大量的空间碎片，后面如果需要分配较大对象时有可能因为连续内存空间不足而导致需要重新出发一次垃圾回收。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-5c112c3d15e44222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p>
<p><strong>复制算法 Coping</strong>，把内存区域按容量分为两个相等的部分，每次只使用一块，当空间使用完毕之后就把还存活的对象赋值到另一块内存区域上，并把使用过的内存空间清空。不用考虑碎片问题，使用简单，但是浪费空间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-015486f96314ec1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p>
<p><strong>标记整理算法 Mark-Compact</strong>，标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有的存活对象都向一端移动，然后直接清理掉端边界以外的对象，也就是需要被回收的对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-e89f0915d56e8903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p>
<p>分代垃圾回收算法，Generational Collection，商用的JVM、DVM均使用该算法。根据对象存活周期的不同将内存划分几块，一般把Java堆分为新生代和老年代，不同的代采用不同的垃圾回收算法，在新生代中每次垃圾回收都会有大量的对象死去，只有少量存活，就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中对象存活时间较长，没有额外空间进行担保，就必须使用标记-清除或者标记-整理算法来进行回收。</p>
<p>新生代中将内存分为一块较大的Eden和两块较小的Survivor区域，每次对象分配只使用Eden和其中一块Survivor区域，当进行GC的时候会有大量的对象死去，少部分存活的对象复制到空闲的Survivor区域。空闲的这个区域相当于是个担保，避免了纯粹的复制算法那样需要一半的空闲区域，浪费空间。<br>那么为什么需要两块Survivor区域呢，一块就不行吗？如果只有一块的话，相当于在下次复制存活对象的时候，Survivor区域上已经有了对象，这一点是有问题的，要么复制算法复杂，要么造成空间碎片。（这点是我自己理解的，有误的话还请指正）</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾回收算法只是内存回收的方法论，提供理论指导，真正的具体实现是垃圾收集器。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚 拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/sinat_36246371/article/details/52998505" target="_blank" rel="noopener">垃圾回收算法之分代回收算法</a></li>
<li>深入理解Java虚拟机——JVM高级特性与最佳实践，周志明</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/Hook一个Activity的启动过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/Hook一个Activity的启动过程/" itemprop="url">Hook一个Activity的启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T09:33:00+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前一篇文章<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>中，通过源码分析的方式介绍了Activity的大致启动过程。今天就来实战一下，一个是加深对Activity启动过程的理解，另外一个就是让我们知道阅读源码有助于拓宽视野，提升开发能力。</p>
<p>首先先抛出需求：</p>
<ol>
<li><p>我们想启动一个Activity A页面，但是想要进入这个A页面必须是已经登录过的，如果没有登录的话就启动登录页面B，并且在B页面登录成功之后需要跳转到页面A</p>
</li>
<li><p>提升一下难度，Activity页面A、B均没有在清单文件中注册，但是要完成正常的跳转（这是为插件化的研究做准备）</p>
</li>
</ol>
<blockquote>
<p>在阅读本文之前，可以先clone一份  <strong><a href="https://github.com/sososeen09/apk-plugin-technology" target="_blank" rel="noopener">apk-plugin-technology</a></strong>，参考此项目的<code>binder-hook</code>模块。运行一下Demo，让你有个更感性的认识</p>
</blockquote>
<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook，就是钩子，也就是说可以干预某些代码的正常执行流程。关于Hook的详细介绍，可以自行搜索相关文章。</p>
<p>完成Hook过程，需要注意3点，也可以说是3个步骤：</p>
<ol>
<li><p>寻找Hook点，Hook点一般要选择类的静态成员变量，因为静态成员变量一般不容易发生变化，只需要Hook一次就好了。如果想要Hook的成员变量不是静态的，那么可以找这个变量所持有的引用中是否有静态的成员变量。而且最好是public的，public的一般不容易发生变化。如果是非public的，就要考虑适配问题了。</p>
</li>
<li><p>选择合适的代理方式，一般来说我们不可能Hook一个对象的所有方法，所以就要通过代理的方式来Hook，如果是想要Hook的方法，就要走我们自己的逻辑，如果是不需要Hook的方法，还是要调用原对象的方法。</p>
</li>
<li><p>用代理对象替换原始对象</p>
</li>
</ol>
<p>这个过程可能还有点不是很清晰，没关系，继续往下看就明白了。</p>
<h1 id="Activity启动过程寻找Hook点"><a href="#Activity启动过程寻找Hook点" class="headerlink" title="Activity启动过程寻找Hook点"></a>Activity启动过程寻找Hook点</h1><p>我们知道，启动一个Activity，可以通过Activity本身的startActivity方法，也可以调用Context的startActivity方法，虽然Activity也是继承自Context，但是Activity重写了相关的启动方法，这是因为Activity本身有Activity任务栈，而其它的Context，比如Service中并没有任务栈，所以启动的时候需要加上一个flag <code>Intent.FLAG_ACTIVITY_NEW_TASK</code>，Context是一个抽象类，其启动Activity的方法，实际上调用的是ContextImpl的startActivity方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line"></span><br><span class="line">    // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is</span><br><span class="line">    // generally not allowed, except if the caller specifies the task id the activity should</span><br><span class="line">    // be launched in.</span><br><span class="line">    if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0</span><br><span class="line">            &amp;&amp; options != null &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) &#123;</span><br><span class="line">        throw new AndroidRuntimeException(</span><br><span class="line">                &quot;Calling startActivity() from outside of an Activity &quot;</span><br><span class="line">                + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span><br><span class="line">                + &quot; Is this really what you want?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), null,</span><br><span class="line">            (Activity) null, intent, -1, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果不加<code>FLAG_ACTIVITY_NEW_TASK</code>标记的话会抛出异常。<br>另外，从这个方法结合我们之前<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>中所分析的，不管是通过Activity调用还是通过Context调用，最终调用的均是Instrumentation的execStartActivity方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">   ...</span><br><span class="line">    try &#123;</span><br><span class="line">      ... </span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>execStartActivity中会调用ActivityManagerNative.getDefault()方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">    return gDefault.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">        &#125;</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in != null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerNative的gDefault 是一个静态变量，它是Singleton的一个匿名类，Singleton类其实就是用于获取单例对象的，gDefault的get方法获取的是IActivityManager的一个实现类。知道Binder的应该知道，这个获取的实际上是ActivityManagerProxy对象，如果不明白的建议先去看看 <a href="https://www.jianshu.com/p/a50d3f2733d6" target="_blank" rel="noopener">Binder学习概要</a>这篇文章。</p>
<p>ActivityManagerProxy对应的server端就是ActivityManagerService，也就是真正负责管理启动Activity的地方。我们启动一个Activity就是调用的ActivityManagerService的startActivity方法。</p>
<p>那么我们想一想，是否可以在gDefault这个方法做点文章呢。我们推理一下这个逻辑：</p>
<ol>
<li>hook 的是Activity的启动过程</li>
<li>ActivityManagerService负责管理启动，但是它在Server端，我们拿不到，但是通过gDefault我们可以拿到它在本地的代理对象ActivityManagerProxy对象。</li>
<li>我们需要为这个ActivityManagerProxy对象创建一个代理对象，当它调用startActivity方法的时候，需要做一些处理，比如按照需求1，判断被跳转的页面是否需要登录，如果需要登录的话就更改这个Intent，跳转到登录页面。当调用其它的方法的时候，直接使用原始的ActivityManagerProxy对象去处理。</li>
</ol>
<p>讲到这，其实我们就可以解决需求1了。但是我想把需求2一起解决了，这样的话上面的逻辑就有点不够完善，毕竟我们所要启动的Activity A和登录页面B都是没有在AndroidManifest.xml中声明的，启动一个未声明的Activity肯定会报一个ActivityNotFoundException。</p>
<p>再来回想一下Activity的启动过程：</p>
<p>调用startActivity方法启动一个目标Activity的时候，实际上会通过Instrumentation进行启动，再通过ActivityManagerService的本地代理对象调用ActivityManagerService的方法来启动一个Activity，这是一个IPC过程，在ActivityManagerService中会校验被启动的Activity的合法性，如果合法，会通过IPC过程调用ApplicationThread的方法，进而调用ActivityThread的handleLaunchActivity方法创建Activity，并执行Activity的生命周期方法。</p>
<p>看到没，Activity的启动过程是分两步的</p>
<ul>
<li>ActivityManagerService去校验被启动Activity合法性，并做好启动Activity的必要准备</li>
<li>在ActivityThread中真正的创建Activity，并完成Activity的启动阶段的生命周期回调。</li>
</ul>
<p>既然没法办通过AMS去启动一个未注册的Activity，那么我们换一个思路来：</p>
<ol>
<li>我们找一个在AndroidManifest.xml中声明一个代理页面ProxyActivity，当发起请求A页面的时候，我们hook ActivityManagerProxy的startActivity方法，把A页面的Intent替换为请求启动ProxyActivity页面的Intent，这样的话至少可以通过ActivityManagerService校验这一关。</li>
<li>当调用回我们ActivityThread的内部中的时候，做一下处理，把代理页面ProxyActivity对应的Intent替换成我们想要启动的Activity A对应的Intent，当然了，在这一过程还需要判断是否需要登录，如果需要登录的话，就需要替换成B页面。示例代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private void hookActivityManagerApi25() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 反射获取ActivityManagerNative的静态成员变量gDefault, 注意，在8.0的时候这个已经更改了</span><br><span class="line">        Class&lt;?&gt; activityManagerNativeClass = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</span><br><span class="line">        Field gDefaultField = activityManagerNativeClass.getDeclaredField(&quot;gDefault&quot;);</span><br><span class="line">        gDefaultField.setAccessible(true);</span><br><span class="line">        Object gDefaultObj = gDefaultField.get(null);</span><br><span class="line">        </span><br><span class="line">        // 我们在这里拿到的instanceObj对象一定不为空，如果为空的话就没办法使用</span><br><span class="line">        Class&lt;?&gt; singletonClass = Class.forName(&quot;android.util.Singleton&quot;);</span><br><span class="line">        Field mInstanceField = singletonClass.getDeclaredField(&quot;mInstance&quot;);</span><br><span class="line">        mInstanceField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        Object instanceObj = mInstanceField.get(gDefaultObj);</span><br><span class="line"></span><br><span class="line">        // 需要动态代理IActivityManager，把Singleton的成员变量mInstance的值设置为我们的这个动态代理对象</span><br><span class="line">        // 但是有一点，我们不可能完全重写一个IActivityManager的实现类</span><br><span class="line">        // 所以还是需要用到原始的IActivityManager对象，只是在调用某些方法的时候做一些手脚</span><br><span class="line">        Class&lt;?&gt; iActivityManagerClass = Class.forName(&quot;android.app.IActivityManager&quot;);</span><br><span class="line">        InterceptInvocationHandler interceptInvocationHandler = new InterceptInvocationHandler(instanceObj);</span><br><span class="line">        Object iActivityManagerObj = Proxy.newProxyInstance(context.getClassLoader(), new Class[]&#123;iActivityManagerClass&#125;, interceptInvocationHandler);</span><br><span class="line">        mInstanceField.set(gDefaultObj, iActivityManagerObj);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterceptInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    Object originalObject;</span><br><span class="line">    public InterceptInvocationHandler(Object originalObject) &#123;</span><br><span class="line">        this.originalObject = originalObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        LogUtils.d(&quot;method:&quot; + method.getName() + &quot; called with args:&quot; + Arrays.toString(args));</span><br><span class="line">        //如果是startActivity方法，需要做一些手脚</span><br><span class="line">        if (METHOD_START_ACTIVITY.equals(method.getName())) &#123;</span><br><span class="line">            Intent newIntent = null;</span><br><span class="line">            int index = 0;</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                Object arg = args[i];</span><br><span class="line">                if (arg instanceof Intent) &#123;</span><br><span class="line">                    Intent wantedIntent = (Intent) arg;</span><br><span class="line">                    // 加入目标Activity没有在清单文件中注册，我们就欺骗ActivityManagerService，启动一个代理页面</span><br><span class="line">                    // 真正启动页面，会开始回调ActivityThread的handleLaunchActivity方法</span><br><span class="line">                    // 调用这个方法前可以做点文章，启动我们想要启动的页面</span><br><span class="line">                    newIntent = new Intent();</span><br><span class="line">                    ComponentName componentName = new ComponentName(context, ProxyActivity.class);</span><br><span class="line">                    newIntent.setComponent(componentName);</span><br><span class="line">                    //把原始的跳转信息当作参数携带给代理类</span><br><span class="line">                    newIntent.putExtra(EXTRA_REAL_WANTED_INTENT, wantedIntent);</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args[index] = newIntent;</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(originalObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在ActivityThread中怎么找Hook点呢？<br>首先要明确一点，我们找找个Hook点是要为了替换之前代理ProxyActivity的Intent的，有了找个思路，我们就可以有目的的去寻找了。</p>
<p>AMS启动一个Activity，会调用ApplicationThread的scheduleLaunchActivity方法，这个方法应该是在Activity启动过程中我们的App最先被AMS调用的了，在这个方法中第一个参数就是Intent，这个Intent就是我们发起请求启动ProxyActivity的Intent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">// 注意这个参数</span><br><span class="line">    r.intent = intent;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationThread继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口。我们考虑一下，能否像Hook ActivityManagerProxy那样，采用一个动态代理的方式，创建IApplicationThread的代理类，当调用IApplicationThread的scheduleLaunchActivity方法的时候，我们更改这个方法的Intent参数，变为我们想要的那个Intent，然后就可以按照我们的需求来跳转了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends ApplicationThreadNative</span><br><span class="line"></span><br><span class="line">public abstract class ApplicationThreadNative extends Binder</span><br><span class="line">        implements IApplicationThread</span><br></pre></td></tr></table></figure>
<p>想法是很好的，但是很遗憾，我们做不到，至于为什么，请接着往下看。</p>
<p>我们想要Hook ApplicationThread的scheduleLaunchActivity，那么我们先看一下这个ApplicationThread对象是什么时候创建的。ApplicationThread是ActivityThread的非静态内部类，在ActivityThread中，它的创建时机是在ActivityThread对象初始化的时候，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ApplicationThread mAppThread = new ApplicationThread();</span><br></pre></td></tr></table></figure>
<p>由于它没有采用多态的方式来创建ApplicationThread，我们创建的动态代理对象实际上是没有办法赋值给mAppThread这个变量的，也就是说实际上这个点我们是没有办法hook的。</p>
<p>那么我们接着这个方法来看，在scheduleLaunchActivity方法中，通过ActivityThread的一个H类型的成员mH来发送一个类型为 H.LAUNCH_ACTIVITY （int 型，值为100）的消息，这个H是ActivityThread的非静态内部类，实际上是继承自Handler的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class H extends Handler</span><br></pre></td></tr></table></figure>
<p>至于为什么需要用Handler来切换，在<a href="https://www.jianshu.com/p/a50d3f2733d6" target="_blank" rel="noopener">Binder学习概要</a><br>已经介绍过，因为scheduleLaunchActivity是在Binder线程池中被调用的，需要用Hander来切换到主线程。H.LAUNCH_ACTIVITY类型的消息发送之后，H的handleMessage方法会被调用，在这里就会根据msg.what的来处理，对应LAUNCH_ACTIVITY类型的，会调用ActivityThread的handleLaunchActivity来创建Activity并完成Activity启动过程的生命周期回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">// 调用ActivityThread的方法来启动Activity</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往下就要走到ActivityThread的handleLaunchActivity方法中了，难道我们要去Hook ActivityThread的handleLaunchActivity方法？</p>
<p>首先，获取这个ActivityThread对象是没有难度的，ActivityThread对象可以在它的类成员变量sCurrentActivityThread获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static volatile ActivityThread sCurrentActivityThread;</span><br></pre></td></tr></table></figure>
<p>应用的启动入口是ActivityThread的main方法，在这个方法中会创建ActivityThread对象，接着又会调用它的attach方法，在这个方法中，把ActivityThread对象赋值给其类的静态成员变量sCurrentActivityThread。静态成员变量就很好说了，通过反射就可以获取这个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> ...</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然获取了这个ActivityThread对象，但是我们怎么准备一个代理对象来代理ActivityThread对象呢？</p>
<p>由于ActivityThread没有继承或实现任何类或接口，好像为它准备代理对象有点难度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityThread</span><br></pre></td></tr></table></figure>
<p>难道没有办法了吗？<br>当然不是，否则我还写这篇文章干嘛？</p>
<p>想一想Handler那块，从发送消息到处理消息，实际上中间是有一个消息分发过程的，也就是Handler的dispatchMessage方法会被调用，在这个方法中实际上Handler本身的handleMessage方法是最后才可能会被调用到的。<code>msg.callback</code> 这块我们没办法处理，因为消息创建是我们控制不了，而在else中，<code>mCallback != null</code> 这块，我们似乎可以给Hander设置一个mCallback，由这个Callback先一步处理消息，替换Intent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下mCallBack的类型，它是Handler内部的一个接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">    public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们赶紧去找找怎么设置Callback，不过很遗憾的是设置Callback只有一种方式就是作为Handler构造方法参数传递，但我们的mH对象已经创建了。既然正常的路径没办法了，那只要采用反射的方式来设置成员变量了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void hookActivityThreadHandler() &#123;</span><br><span class="line">    //需要hook ActivityThread</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取ActivityThread的成员变量 sCurrentActivityThread</span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">        Field sCurrentActivityThread = activityThreadClass.getDeclaredField(&quot;sCurrentActivityThread&quot;);</span><br><span class="line">        sCurrentActivityThread.setAccessible(true);</span><br><span class="line">        Object activityThreadObj = sCurrentActivityThread.get(null);</span><br><span class="line"></span><br><span class="line">        //获取ActivityThread的成员变量 mH</span><br><span class="line">        Field mHField = activityThreadClass.getDeclaredField(&quot;mH&quot;);</span><br><span class="line">        mHField.setAccessible(true);</span><br><span class="line">        Handler mHObj = (Handler) mHField.get(activityThreadObj);</span><br><span class="line"></span><br><span class="line">        Field mCallbackField = Handler.class.getDeclaredField(&quot;mCallback&quot;);</span><br><span class="line">        mCallbackField.setAccessible(true);</span><br><span class="line">        mCallbackField.set(mHObj, new ActivityCallback(mHObj));</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class ActivityCallback implements Handler.Callback &#123;</span><br><span class="line">    private Handler mH;</span><br><span class="line">    public ActivityCallback(Handler mH) &#123;</span><br><span class="line">        this.mH = mH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean handleMessage(Message msg) &#123;</span><br><span class="line">        if (msg.what == LAUNCH_ACTIVITY) &#123;</span><br><span class="line">            handleLaunchActivity(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleLaunchActivity(Message msg) &#123;</span><br><span class="line">        //替换我们真正想要的intent</span><br><span class="line">        try &#123;</span><br><span class="line">            Object activityClientRecord = msg.obj;</span><br><span class="line">            Field intentField = activityClientRecord.getClass().getDeclaredField(&quot;intent&quot;);</span><br><span class="line">            intentField.setAccessible(true);</span><br><span class="line">            //这个是代理ProxyActivity</span><br><span class="line">            Intent interceptedIntent = (Intent) intentField.get(activityClientRecord);</span><br><span class="line"></span><br><span class="line">            //真正想要跳转的 SecondActivity</span><br><span class="line">            Intent realWanted = interceptedIntent.getParcelableExtra(EXTRA_REAL_WANTED_INTENT);</span><br><span class="line">            if (realWanted != null) &#123;</span><br><span class="line">                //如果不需要登录</span><br><span class="line">                Class&lt;?&gt; real = Class.forName(realWanted.getComponent().getClassName());</span><br><span class="line">                NeedLogin annotation = real.getAnnotation(NeedLogin.class);</span><br><span class="line"></span><br><span class="line">                if (annotation != null &amp;&amp; !SPHelper.getBoolean(&quot;login&quot;, false)) &#123;</span><br><span class="line">                    //如果需要登录并且没有登录，跳转登录页面</span><br><span class="line">                    Intent loginIntent = new Intent(context, LoginActivity.class);</span><br><span class="line">                    loginIntent.putExtra(EXTRA_REAL_WANTED_INTENT, realWanted);</span><br><span class="line">                    interceptedIntent.setComponent(loginIntent.getComponent());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptedIntent.setComponent(realWanted.getComponent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，就可以通过Hook的方式来启动一个未在AndroidManifest.xml声明的Activity了，并且可以根据是否需要登录来跳转到不同的页面。</p>
<h1 id="继承AppCompatActivity会遇到的问题"><a href="#继承AppCompatActivity会遇到的问题" class="headerlink" title="继承AppCompatActivity会遇到的问题"></a>继承AppCompatActivity会遇到的问题</h1><p>如果你所有的Activity均继承的是Activity，上面的代码逻辑已经是没有问题了。但是，如果你的Activity类继承的是AppCompatActivity，是会报一个异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.content.pm.PackageManager$NameNotFoundException</span><br></pre></td></tr></table></figure></p>
<p>报这个异常的原因是在AppCompatActivity的onCreate方法中经过层层调用，会调用到NavUtils的getParentActivityName方法。在这个方法中会调用到PackageManager的getActivityInfo方法，返回的ActivityInfo对象是Activity在AndroidManifest.xml中注册信息对应的一个JavaBean对象，调用这个方法实际上会再检查一次Activity的合法性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.NavUtils</span><br><span class="line">public static String getParentActivityName(Context context, ComponentName componentName)</span><br><span class="line">        throws NameNotFoundException &#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    ActivityInfo info = pm.getActivityInfo(componentName, PackageManager.GET_META_DATA);</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 16) &#123;</span><br><span class="line">        String result = info.parentActivityName;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.metaData == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String parentActivity = info.metaData.getString(PARENT_ACTIVITY);</span><br><span class="line">    if (parentActivity == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (parentActivity.charAt(0) == &apos;.&apos;) &#123;</span><br><span class="line">        parentActivity = context.getPackageName() + parentActivity;</span><br><span class="line">    &#125;</span><br><span class="line">    return parentActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面方法中，context.getPackageManager()实际上会调用ContextImpl的getPackageManager方法，而这个实际上返回的是ApplicationPackageManager对象，这个类是把IPackageManager进行了包装，实际上的功能还是由PackageManagerService调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">public PackageManager getPackageManager() &#123;</span><br><span class="line">    if (mPackageManager != null) &#123;</span><br><span class="line">        return mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    if (pm != null) &#123;</span><br><span class="line">        // Doesn&apos;t matter if we make more than one instance.</span><br><span class="line">        return (mPackageManager = new ApplicationPackageManager(this, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ApplicationPackageManager 调用getActivityInfo实际上调用的IPackageManagerd的getActivityInfo方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ApplicationPackageManager</span><br><span class="line">@Override</span><br><span class="line">public ActivityInfo getActivityInfo(ComponentName className, int flags)</span><br><span class="line">        throws NameNotFoundException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityInfo ai = mPM.getActivityInfo(className, flags, mContext.getUserId());</span><br><span class="line">        if (ai != null) &#123;</span><br><span class="line">            return ai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new NameNotFoundException(className.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程就是经过一个IPC过程调用PackageManagerService的getActivityInfo方法。</p>
<p>为了不报NameNotFoundException异常，我们需要Hook这个IPackageManager，当调用PackageManager的getActivityInfo的时候，不让它进行IPC调用，而是直接返回一个不为null的ActivityInfo对象，这样就可以解决问题了。</p>
<h1 id="Hook-PMS"><a href="#Hook-PMS" class="headerlink" title="Hook PMS"></a>Hook PMS</h1><p>我们要去Hook PMS，还是遵循之前讲的3个步骤，那么就先来找这个Hook点，上面我们在贴出的代码中也看到了，ContextImpl的getPackageManager方法中首先会获取调用ActivityThread的静态方法getPackageManager来获取一个IPackageManager对象。我们来看一下这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">public static IPackageManager getPackageManager() &#123;</span><br><span class="line">    if (sPackageManager != null) &#123;</span><br><span class="line">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</span><br><span class="line">        return sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(&quot;package&quot;);</span><br><span class="line">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</span><br><span class="line">    return sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里有一个静态变量sPackageManager，如果不为空的话直接就返回了，这个静态变量的类型是接口类型，那么这个Hook点就很好，静态的很好获取对象，而接口类型更容易使用代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static volatile IPackageManager sPackageManager;</span><br></pre></td></tr></table></figure>
<p>前面讲了那么多，怎么去Hook应该也知道 了，我们目前只Hook IPackageManager的getActivityInfo方法，废话也不多说了，直接贴代码，更直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void HookPackageManager() &#123;</span><br><span class="line">    //需要hook ActivityThread</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取ActivityThread的成员变量 sCurrentActivityThread</span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">        Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);</span><br><span class="line">        sPackageManagerField.setAccessible(true);</span><br><span class="line">        Object iPackageManagerObj = sPackageManagerField.get(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; iPackageManagerClass = Class.forName(&quot;android.content.pm.IPackageManager&quot;);</span><br><span class="line">        InterceptPackageManagerHandler interceptInvocationHandler = new InterceptPackageManagerHandler(iPackageManagerObj);</span><br><span class="line">        Object iPackageManagerObjProxy = Proxy.newProxyInstance(context.getClassLoader(), new Class[]&#123;iPackageManagerClass&#125;, interceptInvocationHandler);</span><br><span class="line"></span><br><span class="line">        sPackageManagerField.set(null, iPackageManagerObjProxy);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class InterceptPackageManagerHandler implements InvocationHandler &#123;</span><br><span class="line">    Object originalObject;</span><br><span class="line"></span><br><span class="line">    public InterceptPackageManagerHandler(Object originalObject) &#123;</span><br><span class="line">        this.originalObject = originalObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        LogUtils.d(&quot;method:&quot; + method.getName() + &quot; called with args:&quot; + Arrays.toString(args));</span><br><span class="line">        if (METHOD_GET_ACTIVITY_INFO.equals(method.getName())) &#123;</span><br><span class="line">            return new ActivityInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(originalObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AMS与ActivityThread通过token进行通信"><a href="#AMS与ActivityThread通过token进行通信" class="headerlink" title="AMS与ActivityThread通过token进行通信"></a>AMS与ActivityThread通过token进行通信</h1><p>虽然我们启动了Activity A或者B，但是AMS实际上还是以为我们启动的是ProxyActivity。不信的话，可以使用命令行查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure>
<p>结果如下，可以看到，在AMS端记录的Activity实际上是ProxyActivity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mFocusedActivity: ActivityRecord&#123;4ff4194 u0 com.sososeen09.binder.hook/.ProxyActivity t5057&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么通过这种Hook方式启动的Activity ，还具有完整的生命周期吗？</p>
<p>答案是肯定的。</p>
<p>我们知道Activity是不具有跨进程通讯的能力的，那么AMS是如何管理Activity，控制Activity的声明周期的呢？答案就是一个通过一个Ibinder类型的token变量来控制。ASM通过这个token来与ApplicationThread进行通讯，进行控制Activity的声明周期。在AMS那边，它以为token表示的是ProxyActivity，但是在客户端这边，token实际上指的是Activity A或者B。</p>
<p>这个token是在AMS在回到IApplicationThread的scheduleLaunchActivity方法中传递过来的第二个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br></pre></td></tr></table></figure>
<p>这个会存在ActivityClientRecord中。这个token和对应的ActivityClientRecord会以键值对的形式存储在ActivityThread的变量mActivities中。后面再对Activity进行生命周期方法调用的时候，均可以通过AMS端传过来的token来获取正确的Activity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-5ab48799a2bf09ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS与ActivityThread中相同token对应不同的Activity.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前面讲了一大堆，我们现在来总结概括一下这个过程和原理。<br>再来看一下需求：</p>
<ol>
<li><p>我们想启动一个Activity A页面，但是想要进入这个A页面必须是已经登录过的，如果没有登录的话就启动登录页面B，并且在B页面登录成功之后需要跳转到页面A</p>
</li>
<li><p>Activity页面A、B均没有在清单文件中注册，但是要完成正常的跳转</p>
</li>
</ol>
<p>为什么我们可以跳转到一个未在AndroidManifest.xml中声明的Activity中，而且可以根据不同的逻辑跳转到不同的页面呢？</p>
<p>调用startActivity方法启动一个目标Activity的时候，实际上会通过Instrumentation进行启动，再通过ActivityManagerService的本地代理对象调用ActivityManagerService的方法来启动一个Activity，这是一个IPC过程，在ActivityManagerService中会校验被启动的Activity的合法性，如果合法，会通过IPC过程调用ApplicationThread的方法，ApplicationThread是一个Binder对象，它的方法运行是在Binder线程池中的，所以需要采用一个Handler把方法调用切换到主线程，ApplicationThread通过发送消息，进而调用ActivityThread的handleLaunchActivity方法创建Activity，并执行Activity的生命周期方法。</p>
<p>传递到ActivityManagerService的被启动的Activity信息必须是声明过的，而如果我们想要启动一个没有在AndroidManifest.xml中声明的Activity，可以通过欺上瞒下的方法，hook ActivityManagerService在本地的代理对象，如果调用的是ActivityManagerProxy的startActivity方法，那么就更改这个Intent，替换成启动一个声明过的ProxyActivity，当ActivityManagerService校验完启动的合法性之后，会通过ApplicationThread调用到ActivityThread的一个叫做mH的Handler中来。当Handler收到消息的时候，会有一个消息分发的过程，如果给Handler设置了一个Callback，这个Callback的handleMessage方法就会先于Handler本身的handleMessage方法调用。所以可以想办法给这个叫做mH的Handler对象设置Callback，并且在Callback的handleMessage方法中从Message上面拿到相关的Intent信息，此时的Intent还是跳转到代理页面，可以根据当前是否登录，是否需要重定向到登录页面等对这个Intent进行相应的处理，比如设置为跳转到登录页或者真正想要跳转的页面，并由后续的mH的handleMessage来调用。</p>
<blockquote>
<p>更多细节，请查看项目 <strong><a href="https://github.com/sososeen09/apk-plugin-technology" target="_blank" rel="noopener">apk-plugin-technology</a></strong></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a></li>
<li><a href="https://blog.csdn.net/lmj623565791/article/details/79278864" target="_blank" rel="noopener">从一道面试题开始说起 枚举、动态代理的原理</a></li>
<li><a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>（推荐）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/Activity启动过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/Activity启动过程分析/" itemprop="url">Activity启动过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T13:23:41+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常我们在Activity中启动一个另一个Activity，就是调用Activity的startActivity方法，这个最终会调用到Activity的startActivityForResult方法。那你有没有想过Activity的启动到底经历了哪些过程，我们今天就来分析一下。</p>
<p>在具体分析之前，要先说明一下，Activity的启动流程在细节挺繁琐的，比如启动另一个App的Activity或者启动不同的launchMode的Activity，在细节上都会有不同。我们这次的源码分析着重分析一下流程，为了简单起见，就以分析一个Activity启动app内部另一个standard模式的Activity为主。</p>
<p>Activity启动另一个Activity之前，当前的Activity先要执行onPause，被启动的Activity才会执行到onResume方法。这中间实际上是会执行4次IPC过程的：</p>
<ul>
<li>当前Activity发起启动另一个Activity的请求——&gt;ActivityManagerService</li>
<li>ActivityManagerService——&gt; 通知App暂停当前Activity</li>
<li>当前App告知已经暂停了当前的Activity——&gt; ActivityManagerService</li>
<li>ActivityManagerService ——&gt; 通知App启动新的Activity</li>
</ul>
<blockquote>
<p>注：本次源码分析采用Android7.0，不同版本的源码在细节上会有不同，比如，在Android8.0上ActivityManagerService就改成了以AIDL的方式来写，请不要太纠结API的不同。</p>
<p>注：本文Activity启动过程源码分析过程比较长，代码较繁琐，请做好心理准备。</p>
</blockquote>
<h3 id="Activity启动涉及到的类"><a href="#Activity启动涉及到的类" class="headerlink" title="Activity启动涉及到的类"></a>Activity启动涉及到的类</h3><p>首先要简单介绍一下Activity启动过程涉及到的类，以便于更好的理解这个启动过程。</p>
<ul>
<li>ActivityThread：App启动的入口</li>
<li>ApplicationThread：ActivityThread的内部类，继承Binder，可以进程跨进程通信。</li>
<li>ApplicationThreadProxy：ApplicationThread的一个本地代理，其它的client端通过这个对象调用server端ApplicationThread中方法。</li>
<li>Instrumentation：负责发起Activity的启动、并具体负责Activity的创建以及Activity生命周期的回调。一个应用进程只会有一个Instrumentation对象，App内的所有Activity都持有该对象的引用。</li>
<li>ActivityManagerService：简称AMS，是service端对象，负责管理系统中所有的Activity</li>
<li>ActivityManagerProxy：是ActivityManagerService的本地代理</li>
<li>ActivityStack：Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li>ActivityRecord：ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li>TaskRecord：AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。</li>
</ul>
<p>介绍完这些，我们开始进入正题</p>
<h3 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h3><p>Activity启动最终会调用到startActivityForResult方法，我们只需要关注mParent == null中的逻辑即可。mParent代表的是ActivityGroup，其最开始是为了在一个界面中嵌入多个子Activity，在API13的时候就已经废弃了，可以使用Fragment表示一个界面的多个区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">                                   @Nullable Bundle options) &#123;</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                        this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                        intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了Instrumentation的execStartActivity方法，在这里通过<code>ActivityManagerNative.getDefault()</code>方法获取ActivityManagerService的一个本地代理对象ActivityManagerProxy，然后调用了其startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">       ... </span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下ActivityManagerNative，继承了Binder并实现了IActivityManager接口，ActivityManagerService就是继承了ActivityManagerNative。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager</span><br></pre></td></tr></table></figure>
<p>ActivityManagerNative实际上获取的就是其内部类ActivityManagerProxy对象。ActivityManagerProxy只是ActivityManagerService的本地代理对象，其startActivity方法会调用到AMS的startActivity方法。而且要注意，这个startActivity方法会把ApplicationThread对象传递到AMS所在进程，当然了AMS拿到的实际上是ApplicationThread的代理对象ApplicationThreadProxy，AMS就要通过这个代理对象与我们的App进程进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityManagerNative</span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">        &#125;</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in != null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">    return gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在Android8.0，由于使用AIDL的方式来写ActivityManagerService，ActivityManagerNative已经过期。</p>
<p>我们接着看一下AMS的startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">                               Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">                               int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startActivity方法紧接着调用了其startActivityAsUser方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">                                     Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">                                     int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, null, null, bOptions, false, userId, null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着调用了ActivityStarter的startActivityMayWait方法，由于方法很长，我们只保留关键的流程部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">        String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span><br><span class="line">        Bundle bOptions, boolean ignoreTargetSecurity, int userId,</span><br><span class="line">        IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">   </span><br><span class="line">        ...</span><br><span class="line">        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">                inTask);</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStarter调用了自身的startActivityLocked方法，这又是一个很长的方法，保留关键的流程如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line"></span><br><span class="line">final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">        TaskRecord inTask) &#123;</span><br><span class="line">    int err = ActivityManager.START_SUCCESS;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true, options, inTask);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStarter又调用了自身的startActivityUnchecked方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line"></span><br><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mDoResume) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!mTargetStack.isFocusable()</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityStarter中调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line"></span><br><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityStackSupervisor的resumeFocusedStackTopActivityLocked中又调用了ActivityStack的resumeTopActivityUncheckedLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line"></span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">   ...</span><br><span class="line">    boolean result = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Protect against recursion.</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">        ...</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStack在resumeTopActivityUncheckedLocked又调用了其自身的resumeTopActivityInnerLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">     ..</span><br><span class="line">    // We need to start pausing the current activity so the top one can be resumed...</span><br><span class="line">    ...</span><br><span class="line">    if (mResumedActivity != null) &#123;</span><br><span class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于当前的Activity执行了onResume，所以mResumedActivity != null 条件满足，就会调用startPausingLocked方法先暂停当前的Activity。注意：这个过程必然是一个IPC过程。我们看一下startPausingLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,</span><br><span class="line">        ActivityRecord resuming, boolean dontWait) &#123;</span><br><span class="line"></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (prev.app != null &amp;&amp; prev.app.thread != null) &#123;</span><br><span class="line">        if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line">            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                    userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> prev.app.thread表示的是IApplicationThread对象，在这里就是指的发起启动的Activity所在进程的ApplicationThread的本地代理ApplicationThreadProxy。调用它的schedulePauseActivity方法，很明显是一次IPC过程，最终调用到server端，也就是发起启动的Activity所在进程ApplicationThread的schedulePauseActivity方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$$ApplicationThread</span><br><span class="line"></span><br><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">    int seq = getLifecycleSeq();</span><br><span class="line">    if (DEBUG_ORDER) Slog.d(TAG, &quot;pauseActivity &quot; + ActivityThread.this</span><br><span class="line">            + &quot; operation received seq: &quot; + seq);</span><br><span class="line">    sendMessage(</span><br><span class="line">            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">            token,</span><br><span class="line">            (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0),</span><br><span class="line">            configChanges,</span><br><span class="line">            seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Hander的转发，接着会调用到ActivityThread的handlePauseActivity方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line"></span><br><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ...</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">        performPauseActivity(token, finished, r.isPreHoneycomb(), &quot;handlePauseActivity&quot;);</span><br><span class="line">    ...</span><br><span class="line">        // Tell the activity manager we have paused.</span><br><span class="line">        if (!dontReport) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityThread的handlePauseActivity中，首先会调用performPauseActivity来暂停当前的Activity，经过层层调用，会调用到Intrumentation的callActivityOnPause方法，最终调用Activity的onPause方法，这一块的流程比较简单，在这里就不再详细分析了，感兴趣的可以自己研究下。</p>
<p>暂停之后，会调动<code>ActivityManagerNative.getDefault().activityPaused(token)</code>，这个很明显又是一次IPC过程，就是告诉AMS，已经暂停当前的Activity，可以启动新的Activity 了。</p>
<p>我们来看一下AMS的的activityPaused方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">@Override</span><br><span class="line">public final void activityPaused(IBinder token) &#123;</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        if (stack != null) &#123;</span><br><span class="line">            stack.activityPausedLocked(token, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS中的activityPaused又调用了ActivityStack的activityPausedLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line"></span><br><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final ActivityRecord r = isInStackLocked(token);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);</span><br><span class="line">        if (mPausingActivity == r) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r</span><br><span class="line">                    + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));</span><br><span class="line">            completePauseLocked(true, null);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中又调用了ActivityStack自身的completePauseLocked方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line">    if (resumeNext) &#123;</span><br><span class="line">        final ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        if (!mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法，这视乎又重新调用了一遍，真复杂啊。</p>
<p>这个流程我们上面讲过了，ActivityStackSupervisor会继续调用ActivityStack的resumeTopActivityUncheckedLocked方法，然后ActivityStack又调用其resumeTopActivityInnerLocked方法，调来调去，又到这个方法里面了，上次在这里是执行了前一个Activity的onPause方法。这次会调用到ActivityStackSupersivor的startSpecificActivityLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    </span><br><span class="line">    // We need to start pausing the current activity so the top one can be resumed...</span><br><span class="line">    final boolean dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0;</span><br><span class="line">    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause);</span><br><span class="line">    if (mResumedActivity != null) &#123;</span><br><span class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">    if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析到这里，好像我们的就要开始启动我们的目标Activity了，好激动有木有！</p>
<p>在ActivityStackSupersivor的startSpecificActivityLocked方法中会判断Activity所在进程是否存在，如果不存在的话就要创建一个新的进程。在这里，我们是Activity启动其App内部的另一个Activity，所以进程肯定是存在的，会走到realStartActivityLocked方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    ... </span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">    ...</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下ActivityStackSupersivor的realStartActivityLocked方法，这次似乎真的要启动一个Activity了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line"></span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</span><br><span class="line">                new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了代码，果然，调用了app.thread.scheduleLaunchActivity方法，app.thread我们前面讲过，就是IApplicationThread对象，实际上就是ApplicationThreadProxy对象，经过IPC过程会调用到ApplicationThread的scheduleLaunchActivity方法，我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$$ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Hander的转发，接着会调用到ActivityThread的handlePauseActivity方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handlePauseActivity内部调用performLaunchActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            ...</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在performLaunchActivity内部，创建了Activity对象，并调用了activity的attach方法，在这个方法中绑定一些属性，并且创建了Activity所属的Window对象。接着Instrumentation会调用callActivityOnCreate、callActivityOnRestoreInstanceState、callActivityOnPostCreate等来完成Activity生命周期的回调。不过有一点很有意思，在这个方法中Activity自己调用了其performStart方法，但这个方法内部又调用了Instrumentation的callActivityOnStart方法，进而又调用了Activity的onStart方法。绕过来绕过去，总之，Activity生命周期方法的调用均是通过Instrumentation来控制的。</p>
<p>至此，Activity的启动过程算是分析完了，太费脑筋了，需要来一瓶营养快线补补身体。流程太多，不好记，但是有句话说的好 “一图胜千言”，下面我们来看一下Activity启动的一个时序图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-ca51f7c43a1cc209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity启动过程.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>源码分析过程是比较绕，比较烧脑的过程，不要太纠结去API的调用，尽量侧重流程。分析源码，最好带着问题去分析，不要为了分析而分析，尽量在分析过程中寻找自己想要的答案。比如：</p>
<ul>
<li>Activity对象是怎么创建的？</li>
<li>Window对象是什么时候创建的？</li>
<li>LayoutInflater什么时候创建的？</li>
<li>为什么在Activity中的布局中或者Fragment的中View获取的Context都是其所在的Activity对象？</li>
<li>为什么自定义View一定要有两个参数的构造函数？</li>
<li>Activity的生命周期方法是被谁回调的？</li>
<li>Application是什么时候创建的？</li>
<li>ClassLoader对象是什么时候创建的？</li>
<li>子线程可以启动Activity、Service吗？</li>
<li>下拉通知栏，会影响Activity生命周期吗？</li>
</ul>
<p>笔者初入Android开发没多久的时候，有次面试，面试官问我在子线程中启动Activity可以吗？我回答可以，因为我试过，但是问我为什么我却不知道。如果那时候看了Activity启动过程的源码，看了Binder机制的话，应该很容易的就回答出来了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/qian520ao/article/details/78156214#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">Android Launcher 启动 Activity 的工作过程</a></li>
<li><a href="https://www.jianshu.com/p/6037f6fda285" target="_blank" rel="noopener">【凯子哥带你学Framework】Activity启动过程全解析</a></li>
<li><a href="https://blog.csdn.net/qq_30379689/article/details/79611217" target="_blank" rel="noopener">Android进阶——Android四大组件启动机制之Activity启动过程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/Binder学习概要/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/Binder学习概要/" itemprop="url">Binder学习概要</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T12:03:00+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很早就想写一篇Binder的文章了，但是迟迟没写出来，因为Binder机制牵涉到的知识点太多了，有Java层的Binder，也有底层的binder驱动。通常我们在Java层面做应用开发牵涉到Binder的，有AIDL、Messenger等。如何写AIDL、Messenger相关的代码并不难，难点在于理解Binder的原理。如果想要系统地学习Binder，推荐看《Android开发艺术探索》的相关章节以及老罗《Android进程间通信（IPC）机制Binder简要介绍和学习计划》系列，分别对应的是Java层的Binder机制和底层的Binder机制。还有一些其它的优秀的文章，文后会有推荐。</p>
<p>本文不打算深入地介绍Binder 机制的原理，毕竟这不是一两篇文章能介绍的清楚的，而且现在网上也有很多优秀的文章。本文想介绍的是我个人通过对Binder地学习，对Binder机制和Android系统的一些理解。</p>
<p>限于水平，难免有误，还请指正。</p>
<h1 id="Binder基本介绍"><a href="#Binder基本介绍" class="headerlink" title="Binder基本介绍"></a>Binder基本介绍</h1><p>Binder是Android系统运行的一个重要基石，做Android开发的应该没有没听说过Binder的吧，那么Binder到底是个什么东西呢？</p>
<p>Binder，最简单来说就是一个Java类，全路径名是 <code>android.os.Binder</code> ，一般我们看到包名是 <code>android.os</code> 的，就应该想到它是系统运行相关的类。这个Binder类实现了IBinder接口，代表这个类的对象具有跨进程通讯的能力。从IPC角度上讲，Binder是Android中一种跨进程通讯方式。Binder还可以理解为一个虚拟的物理设备，这是因为它是有驱动的，但是又不像一般的硬件那样有物理实体，它的设备驱动是/dev/binder，这个驱动是Android特有的，Linux中没有。从Framework层讲，是ServiceManager与各种manager，比如ActivityManagerService、WindowManagerService和各种ManagerService进行通讯的桥梁；从应用层来说，Binder是客户端和服务端进行通讯的媒介。</p>
<p>我觉得不管从什么角度来看Binder，Binder的作用就是用来进行跨进程通讯 (IPC) 的。这里，我们需要简单介绍下IPC，以便于更好的理解Binder的作用。</p>
<h1 id="IPC方式"><a href="#IPC方式" class="headerlink" title="IPC方式"></a>IPC方式</h1><p>任何一个系统都需要有相应的IPC机制，Linux上面可以通过管道、System V IPC，即消息队列/共享内存/信号量，或者Socket的方式来进行跨进程通讯，Android是基于Linux的，也就是说Android也可以使用这些IPC方式，那么Android系统为什么还要再引入Binder这种IPC方式呢？这个问题，我觉得可以从三个方面来回答：使用方便、传输性能、安全。</p>
<ul>
<li>使用方便： Binder是基于C/S架构的，利用了面向对象的思想，对于开发者使用来说，很方便。从这个角度来说，共享内存这种方式就不适合，因为它使用太复杂。</li>
<li>传输性能：Android毕竟是移动设备，移动设备就要考虑内存占用和耗电量的问题，Binder只需要拷贝内存1次，而管道、消息队列、Socket都需要对数据拷贝2次。</li>
<li>安全：传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</li>
</ul>
<table>
<thead>
<tr>
<th>IPC</th>
<th>数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/消息队列</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>基于以上这些原因，Android引入了Binder这种IPC方式，基于C/S架构，传输过程只需要1次拷贝，为发送方添加UID/PID身份验证，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h1 id="Binder中的4种角色"><a href="#Binder中的4种角色" class="headerlink" title="Binder中的4种角色"></a>Binder中的4种角色</h1><ul>
<li>Client：客户端，使用服务的一端</li>
<li>Server：服务端，提供服务的一端</li>
<li>ServerManager：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。其实ServiceManager端也是一个Server端，也有自己的Binder实体，对于ServerManager端来说，其它端都是client端。它是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力。</li>
<li>Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-fb7acce231ab846f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自老罗的Binder简要介绍和学习计划.png"></p>
<p>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中。 Client和Server之间的进程间通信通过Binder驱动程序间接实现。Binder驱动程序和Service Manager在Android平台中已经实现，对于我们应用开发者来说，只需要实现自己的Client和Server就行，常见的就是使用AIDL的方式来实现IPC。</p>
<h1 id="应用开发中的Binder使用"><a href="#应用开发中的Binder使用" class="headerlink" title="应用开发中的Binder使用"></a>应用开发中的Binder使用</h1><p>Binder的那些概念介绍是挺枯燥乏味的，在Android开发中我们无时不刻不在使用Binder，那么我们就结合平时的开发来了解一些使用的Binder机制的地方。</p>
<p>1 Activity启动</p>
<p>Activity的启动需要用到ActivityManagerService，但是我们的App进程和ActivityManagerService所在的进程不是同一个进程，所以就需要用到进程间通讯了。在App进程中我们拿到的是ActivityManagerService的一个分身，也就是ActivityManagerProxy，这个ActivityManagerProxy与ActivityManagerService都实现了IActivityManager接口，因此它们具有相同的功能，但是ActivityManagerProxy只是做了一个中转，创建两个Parcel对象，一个用于携带请求的参数，一个用于拿到请求结果，然后调用transact方法，通过Binder驱动，ActivityManagerService的onTransact方法会被调用，然后根据相应的code，调用相应的方法，并把处理结果返回。</p>
<p><strong>在这个过程中，我们的App进程就是Client，ActivityManagerService所在的进程是Service。</strong></p>
<p>但是Activity的启动过程还没有完，ActivityManagerService还会调用我们App所在进程的ApplicationThread来最终完成Activity的启动，其实ActivityManagerService拿到的也是ApplicationThread的一个分身ApplicationThreadProxy，通过这个分身，ApplicationThread相应的方法会被调用。</p>
<p><strong>在这个过程中，我们的App端是Server，ActivityManagerService所在的进程是Client。</strong></p>
<p>还有一个问题我们要注意，ActivityThread有一个内部类H（一个Hander），ApplicationThread方法内部都会通过这个Handler来发送消息，最终调用到ActivityThread的方法。为什么要这么做呢？</p>
<p>在分析源码的过程中，很长一段时间，这个问题都困扰着我，直到有一天对Binder的理解加深了，我才明白：<strong>Binder服务端的方法都是运行在Binder线程池的一个线程中的，所以要通过Hander，把方法的调用切换到主线程中来</strong>。</p>
<p>2 Intent携带数据</p>
<p>我们都知道Intent可以传递的数据包含：基本类型、String、实现了Serializable接口或者Parcelable接口的类以及对应的数组或者集合类。其实Intent中的数据都是通过Bundle来携带的，那么我们就要有个疑问了，为什么限定只能是这些类型的数据，而不是任意的数据类型呢？</p>
<p>归根结底，限制这些类型的是Parcel这个类。如果我们查看源码的话就会看到，Bundle其实也是用到了Parcel这个类。</p>
<p>Parcel ，“包裹的意思”，它的作用就是为了在IPC过程中存放数据。我们要知道一点，进程间传递数据，实际上就是二进制数据，所以对于非基本类型，必然存在着序列化和反序列过程，这也是为什么要求Intent传递的非基本类型数据必须实现Serializable或者Parcelable接口的原因。</p>
<p>至于Parcel在IPC过程中使用到的地方，我们可以看一段代码，这个是我仿造着AIDL生成的文件，自己手写的一个Binder服务端。看一下Proxy类的add方法，实际上就是先创建两个Parcel对象，一个通过调用 writexxx 方法用于存放请求数据，一个是通过调用 readxxx 方法获取结果。Proxy真正干的就是这些，真正计算的还是服务端Stub的实现类。当Proxy调用 <code>mRemote.transact(TRANSACTION_add, _data, _reply, 0);</code> 方法后，Stub的onTransact方法会被调用，进而调用真正的add方法。</p>
<p>在这里，我们就可以看到Parcel的一系列 writexxx、readxxx方法的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public interface ICalculateInterface extends IInterface &#123;</span><br><span class="line"></span><br><span class="line">    public abstract class Stub extends Binder implements ICalculateInterface &#123;</span><br><span class="line">        private static final String DESCRIPTOR = &quot;com.sososeen09.knowledge.ipc.handipc.ICalculateInterface&quot;;</span><br><span class="line"></span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static ICalculateInterface asInterface(IBinder obj) &#123;</span><br><span class="line">            if (obj == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IInterface iInterface = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">            if (iInterface != null &amp;&amp; iInterface instanceof ICalculateInterface) &#123;</span><br><span class="line">                return (ICalculateInterface) iInterface;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new Proxy(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    int _arg0, _arg1, _result;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    _result = this.add(_arg0, _arg1);</span><br><span class="line"></span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements ICalculateInterface &#123;</span><br><span class="line"></span><br><span class="line">            private IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            public Proxy(IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int add(int a, int b) throws RemoteException &#123;</span><br><span class="line">                Parcel _data = Parcel.obtain();</span><br><span class="line">                Parcel _reply = Parcel.obtain();</span><br><span class="line">                int result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line"></span><br><span class="line">                    mRemote.transact(TRANSACTION_add, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line"></span><br><span class="line">                    result = _reply.readInt();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final int TRANSACTION_add = (IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    int add(int a, int b) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Binder的介绍和Java层的使用，先介绍到这里，这些内容会持续更新。</p>
<h1 id="Binder使用的一些注意事项"><a href="#Binder使用的一些注意事项" class="headerlink" title="Binder使用的一些注意事项"></a>Binder使用的一些注意事项</h1><ul>
<li>Binder方法是在Binder线程池中被调用的，所以不需要再次new一个线程了，Client调用Server端方法，当前线程会被调起，太耗时的话记得用一个线程来调用。</li>
<li>Intent携带的数据大小是限制了，不要超过1M，否则就会报一个TransactionTooLargeException的异常。这是因为Binder数据的缓存大小就是1M。有的时候，即使一次携带的数据不到1M，还是可能会报异常，因为存在并发的情况。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></li>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a></li>
<li><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">田维术-Binder学习指南</a></li>
<li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">小米系统工程师gityuan——Binder系列</a></li>
<li><a href="http://www.jianshu.com/p/c7bcb4c96b38" target="_blank" rel="noopener">Android面试一天一题（Day 35：神秘的Binder机制</a></li>
<li><a href="https://www.qcloud.com/community/article/546217" target="_blank" rel="noopener">Binder 总体架构及相关代码浅析</a></li>
<li><a href="http://blog.csdn.net/qian520ao/article/details/78089877" target="_blank" rel="noopener">Android Binder之应用层总结与分析</a></li>
<li><a href="https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78433798" target="_blank" rel="noopener">Android Binder之应用层精彩解析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T21:20:17+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/类加载机制系列3——MultiDex原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/类加载机制系列3——MultiDex原理解析/" itemprop="url">类加载机制系列3——MultiDex原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T11:06:00+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MultiDex的由来"><a href="#MultiDex的由来" class="headerlink" title="MultiDex的由来"></a>MultiDex的由来</h1><p>Android中由于一个dex文件最多存储65536个方法，也就是一个short类型的范围，所以随着应用的类不断增加，当一个dex文件突破这个方法数的时候就会报出异常。虽然可以通过混淆等方式来减少无用的方法，但是随着APP功能的增多，突破方法数限制还是不可避免的。因此在Android5.0时，Android推出了官方的解决方案：MultiDex。打包的时候，把一个应用分成多个dex，例如：classes.dex、classes2.dex、classes3.dex…，加载的时候把这些dex都追加到DexPathList对应的数组中，这样就解决了方法数的限制。</p>
<p>5.0后的系统都内置了加载多个dex文件的功能，而在5.0之前，系统只可以加载一个主dex，其它的dex就需要采用一定的手段来加载。这也就是我们今天要讲的MultiDex。</p>
<p>MultiDex存放在<code>android.support.multidex包下</code>。</p>
<h1 id="MultiDex的使用"><a href="#MultiDex的使用" class="headerlink" title="MultiDex的使用"></a>MultiDex的使用</h1><p>Gradle构建环境下，在主应用的build.gradle文件夹添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    multiDexEnabled true</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support:multidex:1.0.1&apos;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在最新的multidex版本是1.0.2。</p>
<p>在AndroidManifest.xml中的app节点下，使用<code>MultiDexApplication</code>作为应用入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package android.support.multidex;</span><br><span class="line">...</span><br><span class="line">public class MultiDexApplication extends Application &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然了，大部分情况下，我们都会自定义一个自己的Application对应用做一些初始化。这种情况下，可以在我们自定义的Application中的attachBaseContext()方法中调用MultiDex.install()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自定义的Applicaiton中</span><br><span class="line">  @Override</span><br><span class="line">  protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：MultiDex.install()方法的调用时机要尽可能的早，防止加载后面的dex文件中的类时报ClassNotFoundException。</p>
<h1 id="MultiDex源码分析"><a href="#MultiDex源码分析" class="headerlink" title="MultiDex源码分析"></a>MultiDex源码分析</h1><p>分析MultiDex的的入口就是它的静态方法install()。<br>这个方法的作用就是把从应用的APK文件中的dex添加到应用的类加载器PathClassLoader中的DexPathList的Emlement数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public static void install(Context context) &#123;</span><br><span class="line">    Log.i(TAG, &quot;install&quot;);</span><br><span class="line">    //判断Android系统是否已经支持了MultiDex，如果支持了就不需要再去安装了，直接返回</span><br><span class="line">    if (IS_VM_MULTIDEX_CAPABLE) &#123;</span><br><span class="line">        Log.i(TAG, &quot;VM has multidex support, MultiDex support library is disabled.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果Android系统低于MultiDex最低支持的版本就抛出异常</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Multi dex installation failed. SDK &quot; + Build.VERSION.SDK_INT</span><br><span class="line">                + &quot; is unsupported. Min SDK version is &quot; + MIN_SDK_VERSION + &quot;.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取应用信息</span><br><span class="line">        ApplicationInfo applicationInfo = getApplicationInfo(context);</span><br><span class="line">        // 如果应用信息为空就返回，比如说运行在一个测试的Context下。</span><br><span class="line">        if (applicationInfo == null) &#123;</span><br><span class="line">            // Looks like running on a test Context, so just return without patching.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同步方法</span><br><span class="line">        synchronized (installedApk) &#123;</span><br><span class="line">            // 获取已经安装的APK的全路径</span><br><span class="line">            String apkPath = applicationInfo.sourceDir;</span><br><span class="line">            if (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 把路径添加到已经安装的APK路径中</span><br><span class="line">            installedApk.add(apkPath);</span><br><span class="line">            // 如果编译版本大于最大支持版本，报一个警告</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</span><br><span class="line">                Log.w(TAG, &quot;MultiDex is not guaranteed to work in SDK version &quot;</span><br><span class="line">                        + Build.VERSION.SDK_INT + &quot;: SDK version higher than &quot;</span><br><span class="line">                        + MAX_SUPPORTED_SDK_VERSION + &quot; should be backed by &quot;</span><br><span class="line">                        + &quot;runtime with built-in multidex capabilty but it&apos;s not the &quot;</span><br><span class="line">                        + &quot;case here: java.vm.version=\&quot;&quot;</span><br><span class="line">                        + System.getProperty(&quot;java.vm.version&quot;) + &quot;\&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /* The patched class loader is expected to be a descendant of</span><br><span class="line">             * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">             * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">             * file entries.</span><br><span class="line">             */</span><br><span class="line">            ClassLoader loader;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 获取ClassLoader，实际上是PathClassLoader</span><br><span class="line">                loader = context.getClassLoader();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                /* Ignore those exceptions so that we don&apos;t break tests relying on Context like</span><br><span class="line">                 * a android.test.mock.MockContext or a android.content.ContextWrapper with a</span><br><span class="line">                 * null base Context.</span><br><span class="line">                 */</span><br><span class="line">                Log.w(TAG, &quot;Failure while trying to obtain Context class loader. &quot; +</span><br><span class="line">                        &quot;Must be running in test mode. Skip patching.&quot;, e);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 在某些测试环境下ClassLoader为null</span><br><span class="line">            if (loader == null) &#123;</span><br><span class="line">                // Note, the context class loader is null when running Robolectric tests.</span><br><span class="line">                Log.e(TAG,</span><br><span class="line">                        &quot;Context class loader is null. Must be running in test mode. &quot;</span><br><span class="line">                                + &quot;Skip patching.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 清除老的缓存的Dex目录，来源的缓存目录是&quot;/data/user/0/$&#123;packageName&#125;/files/secondary-dexes&quot;</span><br><span class="line">                clearOldDexDir(context);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Something went wrong when trying to clear old MultiDex extraction, &quot;</span><br><span class="line">                        + &quot;continuing without cleaning.&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            // 新建一个存放dex的目录，路径是&quot;/data/user/0/$&#123;packageName&#125;/code_cache/secondary-dexes&quot;，用来存放优化后的dex文件</span><br><span class="line">            File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">            // 使用MultiDexExtractor这个工具类把APK中的dex抽取到dexDir目录中，返回的files集合有可能为空，表示没有secondaryDex</span><br><span class="line">            // 不强制重新加载，也就是说如果已经抽取过了，可以直接从缓存目录中拿来使用，这么做速度比较快</span><br><span class="line">            List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);</span><br><span class="line">            if (checkValidZipFiles(files)) &#123;</span><br><span class="line">                // 如果抽取的文件是有效的，就安装secondaryDex</span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.w(TAG, &quot;Files were not valid zip files. Forcing a reload.&quot;);</span><br><span class="line">                // Try again, but this time force a reload of the zip file.</span><br><span class="line">                // 如果抽取出的文件是无效的，那么就强制重新加载，这么做的话速度就慢了一点，有一些IO开销</span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);</span><br><span class="line">                if (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    // 强制加载后，如果文件有效就安装，否则就抛出异常</span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Second time didn&apos;t work, give up</span><br><span class="line">                    throw new RuntimeException(&quot;Zip files were not valid.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Multidex installation failure&quot;, e);</span><br><span class="line">        throw new RuntimeException(&quot;Multi dex installation failed (&quot; + e.getMessage() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, &quot;install done&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于dex文件抽取逻辑和校验逻辑我们先不管，我们看一下MultiDex是如何安装secondaryDex文件的。<br>由于不同版本的Android系统，类加载机制有一些不同，所以分为了V19、V14和V4等三种情况下的安装。V19、V14和V4都是MultiDex的private的静态内部类。V19支持Andorid19版本(20是只支持可穿戴设备的)，V14支持14,、15、16、17 和 18版本，V4支持从4到13的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDex</span><br><span class="line">private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span><br><span class="line">        throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span><br><span class="line">        InvocationTargetException, NoSuchMethodException, IOException &#123;</span><br><span class="line">    if (!files.isEmpty()) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下V19的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Installer for platform versions 19.</span><br><span class="line"> */</span><br><span class="line">private static final class V19 &#123;</span><br><span class="line">    private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">            File optimizedDirectory)</span><br><span class="line">                    throws IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                    NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        /* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span><br><span class="line">        // 传递的loader是PathClassLoader，findFidld()方法是遍历loader及其父类找到pathList字段</span><br><span class="line">        // 实际上就是找到BaseClassLoader中的DexPathList</span><br><span class="line">        Field pathListField = findField(loader, &quot;pathList&quot;);</span><br><span class="line">        // 获取PathClassLoader绑定的DexPathList对象</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">        // 扩展DexPathList对象的Element数组，数组名是dexElements</span><br><span class="line">        // makeDexElements()方法的作用就是调用DexPathList的makeDexElements()方法来创建dex元素</span><br><span class="line">        expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList,</span><br><span class="line">                new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        // 后面就是添加一些IO异常信息，因为调用DexPathList的makeDexElements会有一些IO操作，相应的可能就会有一些异常情况</span><br><span class="line">        if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">            for (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Exception in makeDexElement&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Field suppressedExceptionsField =</span><br><span class="line">                    findField(loader, &quot;dexElementsSuppressedExceptions&quot;);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</span><br><span class="line">            if (dexElementsSuppressedExceptions == null) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions =</span><br><span class="line">                        suppressedExceptions.toArray(</span><br><span class="line">                                new IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                IOException[] combined =</span><br><span class="line">                        new IOException[suppressedExceptions.size() +</span><br><span class="line">                                        dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, 0, combined,</span><br><span class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * A wrapper around</span><br><span class="line">     * &#123;@code private static final dalvik.system.DexPathList#makeDexElements&#125;.</span><br><span class="line">     */</span><br><span class="line">    // 通过反射的方式调用DexPathList#makeDexElements()方法</span><br><span class="line">    // dexPathList 就是一个DexPathList对象</span><br><span class="line">    private static Object[] makeDexElements(</span><br><span class="line">            Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">                    throws IllegalAccessException, InvocationTargetException,</span><br><span class="line">                    NoSuchMethodException &#123;</span><br><span class="line">        // 获取DexPathList的makeDexElements()方法</span><br><span class="line">        Method makeDexElements =</span><br><span class="line">                findMethod(dexPathList, &quot;makeDexElements&quot;, ArrayList.class, File.class,</span><br><span class="line">                        ArrayList.class);</span><br><span class="line">        // 调用makeDexElements()方法，根据外界传递的包含dex文件的源文件和优化后的缓存目录返回一个Element[]数组</span><br><span class="line">        return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory,</span><br><span class="line">                suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MultiDex的expandFieldArray()方法作用是扩展一个对象中的数组中的元素。实际上就是一个工具方法。简单看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDex</span><br><span class="line">private static void expandFieldArray(Object instance, String fieldName,</span><br><span class="line">        Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException,</span><br><span class="line">        IllegalAccessException &#123;</span><br><span class="line">    Field jlrField = findField(instance, fieldName);</span><br><span class="line">    Object[] original = (Object[]) jlrField.get(instance);</span><br><span class="line">    Object[] combined = (Object[]) Array.newInstance(</span><br><span class="line">            original.getClass().getComponentType(), original.length + extraElements.length);</span><br><span class="line">    System.arraycopy(original, 0, combined, 0, original.length);</span><br><span class="line">    System.arraycopy(extraElements, 0, combined, original.length, extraElements.length);</span><br><span class="line">    jlrField.set(instance, combined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>V19的install()方法调用完毕之后，就把APK文件中的主dex文件之外的dex文件追加到PathClassLoader（也就是BaseClassLoader）中DexPathListde Element[]数组中。这样在加载一个类的时候就会遍历所有的dex文件，保证了打包的类都能够正常加载。</p>
<p>至于V14和V4中的install()方法，主要的思想都是一致的，在细节上有一些不同，有兴趣的可以自行查看相关源码。</p>
<p>小结一下：<br>MultiDex的install()方法实际上是先抽取出APK文件中的.dex文件，然后利用反射把这个.dex文件生成对应的数组，最后把这些dex路径追加到PathClassLoader加载dex的路径中，从而保证了APK中所有.dex文件中类都能够被正确的加载。</p>
<p>分析完了，MultiDex加载secondartDex的逻辑，我们再来看一下从APK文件中抽取出.dex文件的逻辑。<br>看一下MultiDexExtractor的load()方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">static List&lt;File&gt; load(Context context, ApplicationInfo applicationInfo, File dexDir,</span><br><span class="line">        boolean forceReload) throws IOException &#123;</span><br><span class="line">    Log.i(TAG, &quot;MultiDexExtractor.load(&quot; + applicationInfo.sourceDir + &quot;, &quot; + forceReload + &quot;)&quot;);</span><br><span class="line">    // sourceDir 路径为&quot;/data/app/&#125;$&#123;packageName&#125;-1/base.apk&quot;</span><br><span class="line">    final File sourceApk = new File(applicationInfo.sourceDir);</span><br><span class="line">    // 获取APK文件的CRC（循环冗余校验）</span><br><span class="line">    long currentCrc = getZipCrc(sourceApk);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files;</span><br><span class="line">    // 如果不需要重新加载并且文件没有被修改过</span><br><span class="line">    // isModified()方法是根据SharedPreference中存放的APK文件上一次修改的时间戳和currentCrc来判断是否修改过文件</span><br><span class="line">    if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 从缓存目录中加载已经抽取过的文件</span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Failed to reload existing extracted secondary dex files,&quot;</span><br><span class="line">                    + &quot; falling back to fresh extraction&quot;, ioe);</span><br><span class="line">            // 如果从缓存中加载失败就需要冲APK文件中去加载，这个过程时间会长一点</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            // 把抽取信息保存到SharedPreferences中，方便下次使用</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果强制加载或者APK文件已经修改过就重新抽取dex文件</span><br><span class="line">        Log.i(TAG, &quot;Detected that extraction must be performed.&quot;);</span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, &quot;load found &quot; + files.size() + &quot; secondary dex files&quot;);</span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前后顺序的话，App第一次运行的时候需要从APK冲抽取dex文件，我们先来看一下MultiDexExtractor的performExtractions()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">private static List&lt;File&gt; performExtractions(File sourceApk, File dexDir)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    // 抽取出的dex文件名前缀是&quot;$&#123;apkName&#125;.classes&quot;</span><br><span class="line">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line"></span><br><span class="line">    // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that</span><br><span class="line">    // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,</span><br><span class="line">    // multi-process race conditions can cause a crash loop where one process deletes the zip</span><br><span class="line">    // while another had created it.</span><br><span class="line">    // 由于这个dexDir缓存目录可能不止一个APK在使用，在抽取一个APK之前如果有缓存过的与APK相关的dex文件就需要先删除掉，如果dexDir目录不存在就需要创建</span><br><span class="line">    prepareDexDir(dexDir, extractedFilePrefix);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">    final ZipFile apk = new ZipFile(sourceApk);</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        int secondaryNumber = 2;</span><br><span class="line">        // 获取&quot;classes$&#123;secondaryNumber&#125;.dex&quot;格式的文件</span><br><span class="line">        ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</span><br><span class="line">        // 如果dexFile不为null就一直遍历</span><br><span class="line">        while (dexFile != null) &#123;</span><br><span class="line">            // 抽取后的文件名是&quot;$&#123;apkName&#125;.classes$&#123;secondaryNumber&#125;.zip&quot;</span><br><span class="line">            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">            // 创建文件</span><br><span class="line">            File extractedFile = new File(dexDir, fileName);</span><br><span class="line">            // 添加到集合中</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, &quot;Extraction is needed for file &quot; + extractedFile);</span><br><span class="line">            // 抽取过程中存在失败的可能，可以多次尝试，使用isExtractionSuccessful作为是否成功的标志</span><br><span class="line">            int numAttempts = 0;</span><br><span class="line">            boolean isExtractionSuccessful = false;</span><br><span class="line">            while (numAttempts &lt; MAX_EXTRACT_ATTEMPTS &amp;&amp; !isExtractionSuccessful) &#123;</span><br><span class="line">                numAttempts++;</span><br><span class="line"></span><br><span class="line">                // Create a zip file (extractedFile) containing only the secondary dex file</span><br><span class="line">                // (dexFile) from the apk.</span><br><span class="line">                // 抽出去apk中对应序号的dex文件，存放到extractedFile这个zip文件中，只包含它一个</span><br><span class="line">                // extract方法就是一个IO操作</span><br><span class="line">                extract(apk, dexFile, extractedFile, extractedFilePrefix);</span><br><span class="line"></span><br><span class="line">                // Verify that the extracted file is indeed a zip file.   </span><br><span class="line">                // 判断是够抽取成功</span><br><span class="line">                isExtractionSuccessful = verifyZipFile(extractedFile);</span><br><span class="line"></span><br><span class="line">                // Log the sha1 of the extracted zip file</span><br><span class="line">                Log.i(TAG, &quot;Extraction &quot; + (isExtractionSuccessful ? &quot;success&quot; : &quot;failed&quot;) +</span><br><span class="line">                        &quot; - length &quot; + extractedFile.getAbsolutePath() + &quot;: &quot; +</span><br><span class="line">                        extractedFile.length());</span><br><span class="line">                if (!isExtractionSuccessful) &#123;</span><br><span class="line">                    // Delete the extracted file</span><br><span class="line">                    extractedFile.delete();</span><br><span class="line">                    if (extractedFile.exists()) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;Failed to delete corrupted secondary dex &apos;&quot; +</span><br><span class="line">                                extractedFile.getPath() + &quot;&apos;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isExtractionSuccessful) &#123;</span><br><span class="line">                throw new IOException(&quot;Could not create zip file &quot; +</span><br><span class="line">                        extractedFile.getAbsolutePath() + &quot; for secondary dex (&quot; +</span><br><span class="line">                        secondaryNumber + &quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 继续下一个dex的抽取</span><br><span class="line">            secondaryNumber++;</span><br><span class="line">            dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            apk.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Failed to close resource&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当MultiDexExtractor的performExtractions()方法调用完毕的时候就把APK中所有的dex文件抽取出来，并以一定文件名格式的zip文件保存在缓存目录中。然后再把一些关键的信息通过调用<code>putStoredApkInfo(Context context, long timeStamp, long crc,
            int totalDexNumber)</code>方法保存到SP中。</p>
<p>当APK之后再启动的时候就会从缓存目录中去加载已经抽取过的dex文件。我们接着来看一下MultiDexExtractor的loadExistingExtractions()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">private static List&lt;File&gt; loadExistingExtractions(Context context, File sourceApk, File dexDir)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    Log.i(TAG, &quot;loading existing secondary dex files&quot;);</span><br><span class="line">    // 抽取出的dex文件名前缀是&quot;$&#123;apkName&#125;.classes&quot;</span><br><span class="line">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line">    // 从SharedPreferences中获取.dex文件的总数量，调用这个方法的前提是已经抽取过dex文件，所以SP中是有值的</span><br><span class="line">    int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);</span><br><span class="line">    final List&lt;File&gt; files = new ArrayList&lt;File&gt;(totalDexNumber);</span><br><span class="line"></span><br><span class="line">    // 从第2个dex开始遍历，这是因为主dex由Android系统自动加载的，从第2个开始即可</span><br><span class="line">    for (int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">        // 文件名，格式是&quot;$&#123;apkName&#125;.classes$&#123;secondaryNumber&#125;.zip&quot;</span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">        // 根据缓存目录和文件名得到抽取后的文件</span><br><span class="line">        File extractedFile = new File(dexDir, fileName);</span><br><span class="line">        // 如果是一个文件就保存到抽取出的文件列表中</span><br><span class="line">        if (extractedFile.isFile()) &#123;</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            if (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">                Log.i(TAG, &quot;Invalid zip file: &quot; + extractedFile);</span><br><span class="line">                throw new IOException(&quot;Invalid ZIP file.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Missing extracted secondary dex file &apos;&quot; +</span><br><span class="line">                    extractedFile.getPath() + &quot;&apos;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这，MultiDex安装多个dex的原理应该介绍清楚了，无非就是通过一定的方式把dex文件抽取出来，然后把这些dex文件追加到DexPathList的Element[]数组的后面，这个过程要尽可能的早，所以一般是在Application的attachBaseContext()方法中。<br>一些热修复技术，就是通过一定的方式把修复后的dex插入到DexPathList的Element[]数组<strong>前面</strong>，实现了修复后的class抢先加载。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="noopener">美团Android DEX自动拆包及动态加载简介</a></li>
<li><a href="https://neyoufan.github.io/2017/01/20/android/Multidex%E5%8A%A0%E9%80%9F/" title="谈谈MultiDex启动优化" target="_blank" rel="noopener">谈谈MultiDex启动优化</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24305296" target="_blank" rel="noopener">MultiDex工作原理分析和优化方案</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/类加载机制系列2——深入理解Android中的类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/类加载机制系列2——深入理解Android中的类加载器/" itemprop="url">类加载机制系列2——深入理解Android中的类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T10:53:00+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android中的ClassLoader"><a href="#Android中的ClassLoader" class="headerlink" title="Android中的ClassLoader"></a>Android中的ClassLoader</h1><p>Java中的ClassLoader是加载class文件，而Android中的虚拟机无论是dvm还是art都只能识别dex文件。因此Java中的ClassLoader在Android中不适用。Android中的<code>java.lang.ClassLoader</code>这个类也不同于Java中的<code>java.lang.ClassLoader</code>。<br>Android中的ClassLoader类型也可分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括3种分别是：</p>
<ul>
<li>BootClassLoader，Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的Bootstrap ClassLoader不同的是，它并不是由C/C++代码实现，而是由Java实现的。BootClassLoader是ClassLoader的一个内部类。</li>
<li>PathClassLoader，全名是<code>dalvik/system.PathClassLoader</code>，可以加载已经安装的Apk，也就是<code>/data/app/package</code> 下的apk文件，也可以加载<code>/vendor/lib, /system/lib</code>下的nativeLibrary。</li>
<li>DexClassLoader，全名是<code>dalvik/system.DexClassLoader</code>，可以加载一个未安装的apk文件。</li>
</ul>
<p><code>PathClassLoader</code>和<code>DexClasLoader</code>都是继承自 <code>dalviksystem.BaseDexClassLoader</code>，它们的类加载逻辑全部写在<code>BaseDexClassLoader</code>中。<br>下图展示了Android中的ClassLoader中的继承体系，其中SecureClassLoader和UrlClassLoader是在Java中的类加载器，在Android中是没法办使用的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-64e93a71d99c1459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android中的ClassLoader.png"></p>
<p>在MainActivity中打印当前的ClassLoader，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ClassLoader classLoader = getClassLoader();</span><br><span class="line">        while (classLoader != null) &#123;</span><br><span class="line">            System.out.println(&quot;classLoader: &quot; + classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.sososeen09.classloadtest-1/base.apk&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">java.lang.BootClassLoader@aced87d</span><br></pre></td></tr></table></figure>
<p>从打印的结果也可以证实：App系统类加载器是PathClassLoader，而BootClassLoader是其parent类加载器。</p>
<h1 id="ClassLoader源码分析"><a href="#ClassLoader源码分析" class="headerlink" title="ClassLoader源码分析"></a>ClassLoader源码分析</h1><p>在Android中我们主要关心的是PathClassLoader和DexClassLoader。<br>PathClassLoader用来操作本地文件系统中的文件和目录的集合。并不会加载来源于网络中的类。Android采用这个类加载器一般是用于加载系统类和它自己的应用类。这个应用类放置在data/data/包名下。<br>看一下PathClassLoader的源码，只有2个构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, String libraryPath,</span><br><span class="line">            ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexClassLoader可以加载一个未安装的APK，也可以加载其它包含dex文件的JAR/ZIP类型的文件。DexClassLoader需要一个对应用私有且可读写的文件夹来缓存优化后的class文件。而且一定要注意不要把优化后的文件存放到外部存储上，避免使自己的应用遭受代码注入攻击。看一下它的源码，只有1个构造方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line">import java.io.File;</span><br><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, new File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，PathClassLoader和DexClassLoader除了构造方法传参不同，其它的逻辑都是一样的。要注意的是DexClassLoader构造方法第2个参数指的是dex优化缓存路径，这个值是不能为空的。而PathClassLoader对应的dex优化缓存路径为null是因为Android系统自己决定了缓存路径。</p>
<p>先提前漏一嘴，Android中具体负责类加载的并不是哪个ClassLoader，而是通过DexFile的defineClassNative()方法来加载的。</p>
<p><strong>接下来我们看一下BaseDexClassLoader这个类：</strong></p>
<p>BaseDexClassLoader的构造方法有四个参数：</p>
<ul>
<li>dexPath，指的是在Androdi包含类和资源的jar/apk类型的文件集合，指的是包含dex文件。多个文件用“：”分隔开，用代码就是<code>File.pathSeparator</code>。</li>
<li>optimizedDirectory，指的是odex优化文件存放的路径，可以为null，那么就采用默认的系统路径。</li>
<li>libraryPath，指的是native库文件存放目录，也是以“：”分隔。</li>
<li>parent，parent类加载器</li>
</ul>
<p>可以看到，在BaseDexClassLoader类中初始化了DexPathList这个类的对象。这个类的作用是存放指明包含dex文件、native库和优化目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.BaseDexClassLoader</span><br><span class="line">    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>dalvik.system.DexPathList</code>封装了dex路径，是一个final类，而且访问权限是包权限，也就是说外界不可继承，也不可访问这个类。<br>BaseDexClassLoader在其构造方法中初始化了DexPathList对象，我们来看一下DexPathList的源码，我们需要重点关注一下它的成员变量dexElements，它是一个Element[]数组，是包含dex的文件集合。Element是DexPathList的一个静态内部类。DexPathList的构造方法有4个参数。从其构造方法中也可以看到传递过来的classLoade对象和dexPath不能为null，否则就抛出空指针异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line"></span><br><span class="line">private final Element[] dexElements;</span><br><span class="line"></span><br><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">        String libraryPath, File optimizedDirectory) &#123;</span><br><span class="line">    if (definingContext == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;definingContext == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexPath == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;dexPath == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (optimizedDirectory != null) &#123;</span><br><span class="line">        if (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory doesn&apos;t exist: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果文件不是可读可写的也会抛出异常</span><br><span class="line">        if (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory not readable/writable: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.definingContext = definingContext;</span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">    // 通过makeDexElements方法来获取Element数组</span><br><span class="line">    // splitDexPath(dexPath)方法是用来把我们之前按照“：”分隔的路径转为File集合。</span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions);</span><br><span class="line">    if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">        this.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeDexElements方法的作用是获取一个包含dex文件的元素集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    // 遍历打开所有的文件并且加载直接或者间接包含dex的文件。</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        File zip = null;</span><br><span class="line">        DexFile dex = null;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            // We support directories for looking up resources.</span><br><span class="line">            // This is only useful for running libcore tests.</span><br><span class="line">            // 可以发现它是支持传递目录的，但是说只测试libCore的时候有用</span><br><span class="line">            elements.add(new Element(file, true, null, null));</span><br><span class="line">        &#125; else if (file.isFile())&#123;</span><br><span class="line">            // 如果文件名后缀是.dex，说明是原始dex文件</span><br><span class="line">            if (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                // Raw dex file (not inside a zip/jar).</span><br><span class="line">                try &#123;</span><br><span class="line">                    //调用loadDexFile()方法，加载dex文件，获得DexFile对象</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    System.logE(&quot;Unable to load dex file: &quot; + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // dex文件包含在其它文件中</span><br><span class="line">                zip = file;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 同样调用loadDexFile()方法</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; catch (IOException suppressed) &#123;</span><br><span class="line">                    // 和加载纯dex文件不同的是，会把异常添加到异常集合中</span><br><span class="line">                    /*</span><br><span class="line">                     * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if</span><br><span class="line">                     * the zip file turns out to be resource-only (that is, no classes.dex file</span><br><span class="line">                     * in it).</span><br><span class="line">                     * Let dex == null and hang on to the exception to add to the tea-leaves for</span><br><span class="line">                     * when findClass returns null.</span><br><span class="line">                     */</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果zip或者dex二者一直不为null，就把元素添加进来</span><br><span class="line">        // 注意，现在添加进来的zip存在不为null也不包含dex文件的可能。</span><br><span class="line">        if ((zip != null) || (dex != null)) &#123;</span><br><span class="line">            elements.add(new Element(file, false, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return elements.toArray(new Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码也可以看到，加载一个dex文件调用的是loadDexFile()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    // 如果缓存存放目录为null就直接创建一个DexFile对象返回</span><br><span class="line">    if (optimizedDirectory == null) &#123;</span><br><span class="line">        return new DexFile(file);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 根据缓存存放目录和文件名得到一个优化后的缓存文件路径</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        // 调用DexFile的loadDex()方法来获取DexFile对象。</span><br><span class="line">        return DexFile.loadDex(file.getPath(), optimizedPath, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexFile的loadDex()方法如下，内部也做了一些调用。抛开这些细节来讲，它的作用就是加载DexFile文件，而且会把优化后的dex文件缓存到对应目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexFile </span><br><span class="line">static public DexFile loadDex(String sourcePathName, String outputPathName,</span><br><span class="line">    int flags) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * TODO: we may want to cache previously-opened DexFile objects.</span><br><span class="line">     * The cache would be synchronized with close().  This would help</span><br><span class="line">     * us avoid mapping the same DEX more than once when an app</span><br><span class="line">     * decided to open it multiple times.  In practice this may not</span><br><span class="line">     * be a real issue.</span><br><span class="line">     */</span><br><span class="line">    //loadDex方法内部就是调用了DexFile的一个构造方法</span><br><span class="line">    return new DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private DexFile(String sourceName, String outputName, int flags) throws IOException &#123;</span><br><span class="line">    if (outputName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String parent = new File(outputName).getParent();</span><br><span class="line">            if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent</span><br><span class="line">                        + &quot; is not owned by the current user. Shared storage cannot protect&quot;</span><br><span class="line">                        + &quot; your application from code injection attacks.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ErrnoException ignored) &#123;</span><br><span class="line">            // assume we&apos;ll fail with a more contextual error later</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">    mFileName = sourceName;</span><br><span class="line">    guard.open(&quot;close&quot;);</span><br><span class="line">    //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static long openDexFile(String sourceName, String outputName, int flags) throws IOException &#123;</span><br><span class="line">    // Use absolute paths to enable the use of relative paths when testing on host.</span><br><span class="line">    return openDexFileNative(new File(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == null) ? null : new File(outputName).getAbsolutePath(),</span><br><span class="line">                             flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native long openDexFileNative(String sourceName, String outputName, int flags);</span><br></pre></td></tr></table></figure>
<p>分析到这，我们可以小结一下：在BaseDexClassLoader对象构造方法内，创建了PathDexList对象。而在PathDexList构造方法内部，通过调用一系列方法，把直接包含或者间接包含dex的文件解压缩并缓存优化后的dex文件，通过PathDexList的成员变量 <code>Element[] dexElements</code>来指向这个文件。</p>
<p>到此我们就分析完了BaseDexClassLoader的构造方法。</p>
<p>我们在之前讲Java类加载器的时候已经说了，类加载是按需加载，也就是说当明确需要使用class文件的时候才会加载。我们来看一下在Android中ClassLoader的loadeClass()方法。<br>与在Java中的loadClass()方法主要流程是类似的，不过因为Android中BootClassLoader是用Java代码写的，所以可以直接当作系统类加载器的parent类加载器。在Android中如果parent类加载器找不到类，最终还是会调用ClassLoader对象自己的findClass()方法。这个与在Java中逻辑是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    if (clazz == null) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = parent.loadClass(className, false);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clazz == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以去看一下BaseDexClassLoader类的findClass()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.BaseDexClassLoader</span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();</span><br><span class="line">    // 调用DexPathList对象的findClass()方法</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    if (c == null) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</span><br><span class="line">        for (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上BaseDexClassLoader调用的是其成员变量<code>DexPathList pathList</code>的findClass()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    // 遍历Element</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        // 获取DexFile，然后调用DexFile对象的loadClassBinaryName()方法来加载Class文件。</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">       </span><br><span class="line">        if (dex != null) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dexElementsSuppressedExceptions != null) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们也可以看到，实际上DexPathList最终还是遍历其自身的Element[]数组，获取DexFile对象来加载Class文件。我们之前讲DexPathList构造方法内是调用其makeDexElements()方法来创建Element[]数组的，而且也提到了如果zip文件或者dex文件二者之一不为null，就把元素添加进来，而添加进来的zip存在不为null也不包含dex文件的可能。从上面的代码中也可以看到，获取Class的时候跟这个zip文件没什么关系，调用的是dex文件对应的DexFile的方法来获取Class。</p>
<p>数组的遍历是有序的，假设有两个dex文件存放了二进制名称相同的Class，类加载器肯定就会加载在放在数组前面的dex文件中的Class。现在很多热修复技术就是把修复的dex文件放在DexPathList中Element[]数组的前面，这样就实现了修复后的Class抢先加载了，达到了修改bug的目的。</p>
<p>Android加载一个Class是调用DexFile的defineClass()方法。而不是调用ClassLoader的defineClass()方法。这一点与Java不同，毕竟Android虚拟机加载的dex文件，而不是class文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexFile</span><br><span class="line">public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    return defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class defineClass(String name, ClassLoader loader, long cookie,</span><br><span class="line">                                 List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    Class result = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = defineClassNative(name, loader, cookie);</span><br><span class="line">    &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">        if (suppressed != null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        if (suppressed != null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Android中ClassLoader的defineClass()方法已经不能用了。可以看到它的方法体里直接抛出异常了，而且在BaseDexClassLoader中也没有重写这个方法，毕竟BaseDexClassLoader加载类的逻辑已经变了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># java.lang.ClassLoader</span><br><span class="line">protected final Class&lt;?&gt; defineClass(String className, byte[] classRep, int offset, int length,</span><br><span class="line">        ProtectionDomain protectionDomain) throws java.lang.ClassFormatError &#123;</span><br><span class="line">    throw new UnsupportedOperationException(&quot;can&apos;t load this type of class file&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，分析到此我们可以小结一下：<br>Android中加载一个类是遍历PathDexList的Element[]数组，这个Element包含了DexFile，调用DexFile的方法来获取Class文件，如果获取到了Class，就跳出循环。否则就在下一个Element中寻找Class。</p>
<h1 id="使用DexClassLoader加载类"><a href="#使用DexClassLoader加载类" class="headerlink" title="使用DexClassLoader加载类"></a>使用DexClassLoader加载类</h1><p>写一个Test类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;this is Test Class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>javac</code>命令生成class文件，然后通过Android中的<code>dex</code>工具生成dex文件。<br>为了方便测试，我把生成的dex文件放在了assets文件中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-9a448c7910a74af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex文件.png"></p>
<p>测试的时候，先把assets中的classes.dex文件复制到本地一个目录。<br>主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 1. 先把assets中的classes.dex文件复制到一个本地目录中</span><br><span class="line">File originDex = null;</span><br><span class="line">try &#123;</span><br><span class="line">    InputStream open = getAssets().open(&quot;classes.dex&quot;);</span><br><span class="line">    File dexOutputDir = getCacheDir();</span><br><span class="line">    originDex = new File(dexOutputDir, &quot;classes.dex&quot;);</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(originDex);</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len = open.read(bytes)) != -1) &#123;</span><br><span class="line">        fileOutputStream.write(bytes, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    open.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 创建DexClassLoader加载dex文件中的类</span><br><span class="line">if (originDex != null) &#123;</span><br><span class="line">    File dexOptimizeDir = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);</span><br><span class="line">    String dexOutputPath = dexOptimizeDir.getAbsolutePath();</span><br><span class="line">    DexClassLoader dexClassLoader = new DexClassLoader(originDex.getAbsolutePath(), dexOutputPath, null, getClassLoader());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = dexClassLoader.loadClass(&quot;com.sososeen09.Test&quot;);</span><br><span class="line">        System.out.println(&quot;loaded class: &quot; + clazz);</span><br><span class="line">        System.out.println(&quot;class loader: &quot; + clazz.getClassLoader());</span><br><span class="line">        System.out.println(&quot;class loader parent: &quot; + clazz.getClassLoader().getParent());</span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Object o = constructor.newInstance();</span><br><span class="line">        Method print = clazz.getDeclaredMethod(&quot;print&quot;);</span><br><span class="line">        print.setAccessible(true);</span><br><span class="line">        print.invoke(o);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/System.out: loaded class: class com.sososeen09.Test</span><br><span class="line">I/System.out: class loader: dalvik.system.DexClassLoader[DexPathList[[dex file &quot;/data/data/com.sososeen09.android_basic_knowledge/cache/classes.dex&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">I/System.out: class loader parent: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/base.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_dependencies_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_0_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_1_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_2_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_3_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_4_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_5_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_6_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_7_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_8_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_9_apk.apk&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">I/System.out: this is Test Class</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过DexClassLoader对象正确的加载到了我们自己的dex文件中的类。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android中的类加载器是BootClassLoader、PathClassLoader、DexClassLoader，其中BootClassLoader是虚拟机加载系统类需要用到的，PathClassLoader是App加载自身dex文件中的类用到的，DexClassLoader可以加载直接或间接包含dex文件的文件，如APK等。</p>
<p>PathClassLoader和DexClassLoader都继承自BaseDexClassLoader，它的一个DexPathList类型的成员变量pathList很重要。DexPathList中有一个Element类型的数组dexElements，这个数组中存放了包含dex文件（对应的是DexFile）的元素。BaseDexClassLoader加载一个类，最后调用的是DexFile的方法进行加载的。</p>
<p>无论是热修复还是插件化技术中都利用了类加载机制，所以深入理解Android中的类加载机制对于理解这些技术的原理很有帮助。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://liuwangshu.cn/application/classloader/2-android-classloader.html" target="_blank" rel="noopener">Android解析ClassLoader（二）Android中的ClassLoader</a></li>
<li><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></li>
<li><a href="http://www.jianshu.com/p/a620e368389a" target="_blank" rel="noopener">Android动态加载之ClassLoader详解</a></li>
<li><a href="https://segmentfault.com/a/1190000004062952" target="_blank" rel="noopener">Android动态加载入门 简单加载模式</a></li>
<li><a href="http://blog.csdn.net/yulong0809/article/details/78426280" target="_blank" rel="noopener">唯一插件化Replugin源码及原理深度剖析–唯一Hook点原理</a></li>
<li><a href="http://www.jianshu.com/p/57fc356b9093" target="_blank" rel="noopener">Android插件化框架系列之类加载器</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/类加载机制系列1——深入理解Java中的类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/类加载机制系列1——深入理解Java中的类加载器/" itemprop="url">类加载机制系列1——深入理解Java中的类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T10:50:00+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h1><p>Java类加载器是Java运行时环境（Java Runtime Environment）的一部分，它负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。</p>
<p>Java中的类加载器是<code>java.lang.ClassLoader</code>，它是一个抽象类。给定一个类名，ClassLoader就负责把这个类从特定的文件系统中加载到虚拟机中。</p>
<p>Class类有一个方法<code>getClassLoader()</code>，每一个类的Class对象都可以调用这个方法来获取把这个类加载到虚拟机中的ClassLoader。</p>
<p>对于数组来说，它们不是由ClassLoader来创建，而是由Java运行时创建，数组的ClassLoader就是加载该数组元素类的ClassLoader。如果元素类型是基本类型，那么数组就没有ClassLoader。</p>
<p>ClassLoader采用的是代理模式来加载类，每一个ClassLoader实例都有一个父ClassLoader（并不是继承关系），当一个类加载器需要加载一个类的时候，它会首先传递这个类的信息到parent 类加载器，请求parent来加载，然后依次传递，直到该类被成功加载或者失败。如果失败了，那么就由最开始的那个类加载器来进行加载。在Java虚拟机中有一个内置的类加载器是<code>bootstrap class loader</code>，它是没有parent的，但是可以作为所有ClassLoader实例的parent。这种加载方式也叫作双亲委派机制或者父委托机制。</p>
<p>通常来讲，类加载器都是加载本地的Class文件，但是它也可以加载其它来源的文件，比如从网络下载下来的。可以通过继承<code>java.lang.ClassLoader</code>类的方式实现自己的类加载器，以满足一些特殊的需求而不需要完全了解Java虚拟机的类加载的细节。ClassLoader的一个方法<code>defineClass</code>可以把一个字节数组转为Class实例。然后可以根据<code>Class.newInstance()</code>方法来创建一个对象。被ClassLoader创建的类的方法或者构造方法可能还会引用其它的类，为了确定引用的类，虚拟机会调用最开始加载引用类的ClassLoader的<code>loadClass</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br></pre></td></tr></table></figure>
<p>例如，想要自定义一个NetworkClassLoader，来加载从网络传来的Class类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = new NetworkClassLoader(host, port);</span><br><span class="line">Object main = loader.loadClass(&quot;Main&quot;, true).newInstance();</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>NetworkClassLoader必须重写<code>findClass</code>方法，，然后定义一个方法来返回Class类的字节数组。当下载完毕，需要调用defineClass方法，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">    String host;</span><br><span class="line">    int port;</span><br><span class="line"></span><br><span class="line">    public Class findClass(String name) &#123;</span><br><span class="line">        byte[] b = loadClassData(name);</span><br><span class="line">        return defineClass(name, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        // load the class data from the connection</span><br><span class="line">          . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JVM中的ClassLoader"><a href="#JVM中的ClassLoader" class="headerlink" title="JVM中的ClassLoader"></a>JVM中的ClassLoader</h1><p>JVM中有3个默认的类加载器：</p>
<ul>
<li>引导（Bootstrap）类加载器。用C/C++写的，在Java代码中无法获取到。主要是加载存储在<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录下的核心Java库，对应的加载路径是<code>sun.boot.class.path</code>。</li>
<li>扩展（Extensions）类加载器.用来加载<code>&lt;JAVA_HOME&gt;/jre/lib/e。t</code>目录下或者对应的加载路径<code>java.ext.dirs</code>中指明的Java扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。该类由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li>Apps类加载器（也称系统类加载器）。根据 Java应用程序的类路径（java.class.path或CLASSPATH环境变量）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。该类由<code>sun.misc.Launcher$AppClassLoader</code>实现，它的parent类加载器是ExtClassLoader。</li>
</ul>
<p>下面通过一个示例来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package classLoader;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		ClassLoaderTest clt=new ClassLoaderTest();</span><br><span class="line">		ClassLoader cl=clt.getClass().getClassLoader();</span><br><span class="line">		System.out.println(cl);</span><br><span class="line">		System.out.println(cl.getParent());</span><br><span class="line">		System.out.println(cl.getParent().getParent());</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">		System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">		System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">		System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@7852e922</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/resources.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/sunrsasign.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jsse.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jce.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/charsets.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jfr.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/classes</span><br><span class="line"></span><br><span class="line">/Users/jason/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/ext:</span><br><span class="line">/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line">/works/EclipseWorkSpace/classLoader/bin</span><br></pre></td></tr></table></figure>
<p><code>java.lang.ClassLoader</code>继承关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-7adfb842ce5f4ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java中ClassLoader继承关系.png"></p>
<p>其中AppClassLoader和ExtClassLoader都是在Laucher中的内部类。而这个Laucher是JVM的入口。</p>
<p><strong>注意: 并不是说子加载器继承自父加载器</strong></p>
<h1 id="ClassLoader源码分析"><a href="#ClassLoader源码分析" class="headerlink" title="ClassLoader源码分析"></a>ClassLoader源码分析</h1><p>前面已经讲了，类的加载使用的是双亲委派机制。那我们启动一个Java应用程序，它的类加载顺序是从AppClassLoader委托ExtClassLoader，如果ExtClassLoader也找不到就会去委托Bootstrap类加载器加载。如果父加载器没有找到的话，再从子加载器中加载，加载到的类会被缓存起来，如果最终都没有找到这个类，就会报一个异常<code>ClassNotFoundException</code>。</p>
<p>我们先看一下ClassLoader的构造方法，它有3个构造方法，但是其中有一个私有的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//最终调用的还是这个私有的方法</span><br><span class="line">private ClassLoader(Void unused, ClassLoader parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//有参构造，传递parent类加载器</span><br><span class="line">protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">   this(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 无参构造，默认采用getSystemClassLoader()方法获取的ClassLoader作为parent类加载器</span><br><span class="line">protected ClassLoader() &#123;</span><br><span class="line">    this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看getSystemClassLoader()这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    // 初始化系统类加载器</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    if (scl == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 做一些安全方面的校验</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    if (sm != null) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initSystemClassLoader()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl != null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        //获取Launcher对象</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l != null) &#123;</span><br><span class="line">            Throwable oops = null;</span><br><span class="line">            //调用Launcher对象的getClassLoader()方法，这个获取的就是AppClassLoader，详细内容可以看下面对Launcher的分析</span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops != null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们就ClassLoader加载一个类的过程来进行一下分析。ClassLoader加载一个类，调用的方法是<code>loadClass()方法</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//通常外界是调用ClassLoader的这个loadClass方法</span><br><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ClassLoader的默认加载方式，如果需要自定义ClassLoader最好不要重写这个方法。</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    // 同步代码块</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // findLoadedClass是一个native方法，如果已经加载过的类是会被缓存起来的，直接从缓存获取即可</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">        // c为null，说明没有缓存，就需要初次加载</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    // 如果parent不为null就委托parent去加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 如果parent为null就委托bootstrap class loader去加载</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // 如果非空的父加载器找不到类会抛出异常，在这里try-catch住了</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // 如果父加载器和bootstrap加载器都没有找到，就会调用ClassLoader实例自身的findClass()方法。</span><br><span class="line">                // 其方法体是抛出一个ClassNotFoundException异常，</span><br><span class="line">                // 所以继承ClassLoader的子类加载器需要重写这个findClass()方法</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            // 使Classloader链接指定的类，如果这个类已经被链接过了，那么这个方法只做一个简单的返回。</span><br><span class="line">            // 否则，这个类将被按照 Java™规范中的Execution描述进行链接</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是第一个参数，name表示的是二进制名称(Binary name)，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.lang.String&quot;</span><br><span class="line">&quot;javax.swing.JSpinner$DefaultEditor&quot;</span><br><span class="line">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;</span><br><span class="line">&quot;java.net.URLClassLoader$3$1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>需要指出：类加载过程是同步的</strong></p>
<p>简单总结一下类加载器的工作过程：</p>
<ol>
<li>如果当前加载的类已经加载过，直接从缓存获取。</li>
<li>之前没有加载过，如果该ClassLoader对象的parent不为null就委托父加载器加载，父加载器会重新开始走第1步。如果parent为null，那么就采用根加载器bootstrap class loader进行加载。</li>
<li>如果之前还是没有成功加载类，那么就会调用当前ClassLoader的findClass()方法去加载。</li>
</ol>
<p><strong>类加载器采用双亲委派机制的好处：</strong></p>
<ol>
<li>加载的类会被缓存起来，下次加载就快了。</li>
<li>安全，比如我们自定义一个与系统String包名类型一致的类，然后想要把这个String类加载进来干点坏事的话实际上是做不到的，由于父委托机制，真正的String类会被bootstrap class loader 加载（String类是存放在bootstrap class loader 负责加载的区域），就不会再调用我们这个假的String类。实际上，如果你自定义了一个类加载器并且重写了loadClass的逻辑，最终还是不能加载假的String类，因为ClassLoader有一个preDefineClass方法，该方法会检测类的包名，如果是’java’开头就会抛出一个SecurityException异常。</li>
</ol>
<p>那么AppClassLoader和ExtClassLoader是什么时候初始化的呢？下面我们再去看一下Launcher的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># sun.misc.Launcher</span><br><span class="line">//构造方法</span><br><span class="line">public Launcher() &#123;</span><br><span class="line">    ClassLoader extcl;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建ExtClassLoader对象</span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create extension class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建AppClassLoader对象loader，这个loader就是上面讲到的，Launcher的getClassLoader()方法返回的对象。 </span><br><span class="line">    //AppClassLoader.getAppClassLoader()方法的参数为extcl，实际上就是把ExtClassLoader对象当作其父加载器</span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create application class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置上下文的类加载器，也就是AppClassLoader对象。</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    // Finally, install a security manager if requested</span><br><span class="line">    String s = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        SecurityManager sm = null;</span><br><span class="line">        if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;</span><br><span class="line">            sm = new java.lang.SecurityManager();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(</span><br><span class="line">                &quot;Could not create SecurityManager: &quot; + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于ExtClassLoader和AppClassLoader的源码我们这里就不做多余的介绍了，感兴趣的可以去看一下<a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java?av=f" target="_blank" rel="noopener">Launcher</a>这个类，ExtClassLoader和AppClassLoader都是其静态内部类。</p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>我们完全可以通过自定义类加载器来加载我们想要加载的类，这个类可能来源于网络，也可能来源于文件系统。<br>从前面的分析我们知道，加载一个类的过程调用的是ClassLoader的loadClass()方法。自定义类加载器通常不要重写loadClass()方法的逻辑。在这个方法内部，如果所有的父加载器都没有成功加载，就会调用ClassLoader对象自身的findClass()方法，自定义类加载器可以实现这个findClass()方法即可。</p>
<p>还有一个关键的方法就是调用ClassLoader对象的defineClass()方法，这样就可以创建一个Class对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String dirPath;</span><br><span class="line"></span><br><span class="line">    public CustomClassLoader(String dirPath) &#123;</span><br><span class="line">        this.dirPath = dirPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        //注意这个name一定要是二进制名称，如&apos;java.lang.String&apos;</span><br><span class="line">        //根据类的二进制名称,获得该class文件的字节码数组</span><br><span class="line">        byte[] classData = getClassDataBytes(name);</span><br><span class="line">        if (classData == null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用define()方法将class的字节码数组转换成Class类的实例</span><br><span class="line">        clazz = defineClass(name, classData, 0, classData.length);</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassDataBytes(String name) &#123;</span><br><span class="line">        FileInputStream is = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = classNameToPath(name);</span><br><span class="line">            is = new FileInputStream(path);</span><br><span class="line">            byte[] buff = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            while ((len = is.read(buff)) != -1) &#123;</span><br><span class="line">                baos.write(buff, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String classNameToPath(String name) &#123;</span><br><span class="line">        return dirPath + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的类加载器已经写好了，下面我们来演示一下如何加载一个类，首先我们编写一个java类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen09;</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    public Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;this is Test Class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>javac</code>命令把java文件编译为对应的class文件。这个Test.class文件的二进制名称就是<code>com.sososeen09.Test</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String srcPath = &quot;/test/bin&quot;;</span><br><span class="line">        CustomClassLoader customClassLoader = new CustomClassLoader(srcPath);</span><br><span class="line">        String classname = &quot;com.sososeen09.Test&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = customClassLoader.loadClass(classname);</span><br><span class="line">            System.out.println(&quot;loaded class: &quot; + clazz);</span><br><span class="line">            System.out.println(&quot;class loader: &quot; + clazz.getClassLoader());</span><br><span class="line">            System.out.println(&quot;class loader parent: &quot; + clazz.getClassLoader().getParent());</span><br><span class="line">            Constructor constructor = clazz.getConstructor();</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            Object o = constructor.newInstance();</span><br><span class="line">            Method print = clazz.getDeclaredMethod(&quot;print&quot;);</span><br><span class="line">            print.setAccessible(true);</span><br><span class="line">            print.invoke(o);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>运行一下可以查看打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaded class: class com.sososeen09.Test</span><br><span class="line">class loader: com.sososeen09.javamodule.classloaders.CustomClassLoader@14ae5a5</span><br><span class="line">class loader parent: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">this is Test Class</span><br></pre></td></tr></table></figure>
<p>可以看到我们自定义的类加载器已经成功的把一个文件系统中的class加载了。</p>
<p><strong>需要注意：我们是把二进制文件前面的包名转为路径了，所以我们传递的srcPath是<code>&quot;/test/bin&quot;</code>，那么实际上class文件存放路径应该是<code>&quot;/test/bin/com/sososeen09/&quot;</code></strong>。</p>
<h1 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h1><p>在Java中，类的加载时按需加载，也就是需要的时候才会把class文件加载到内存中。可以分为隐式加载和显示加载。</p>
<ul>
<li>隐式加载：由当new一个Java对象，或者调用类的静态方法或者使用静态成员变量的时候，会加载当前的Class。</li>
<li>显示加载，显示的调用Class.forName()方法，或者调用ClassLoader的loadClass()方法。</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul>
<li><a href="http://liuwangshu.cn/application/classloader/1-java-classloader-.html" target="_blank" rel="noopener">Android解析ClassLoader（一）Java中的ClassLoader</a></li>
<li><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></li>
<li><a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">深入分析Java ClassLoader原理</a></li>
<li><a href="http://www.hollischuang.com/archives/199" target="_blank" rel="noopener">深度分析Java的ClassLoader机制（源码级别）</a></li>
<li><a href="http://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">深入理解Java类加载器(ClassLoader)</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
