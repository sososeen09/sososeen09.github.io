<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Dagger," />










<meta name="description" content="本文的分析基于dagger2的2.7版本。  谷歌开发维护的Dagger2出来有很长时间了，目前在很多开源项目上也能看到它的身影。看了一些文章和项目，发现Dagger2的入门虽然有些难，但还是有一些规律可循的。 对于开源的第三方项目，我认为都是有套路可循的，找到这个套路，入门就不会难了，难的是如何更好的在实际开发项目中灵活运用。而灵活运用必然是建立在对这些开源框架深刻理解的基础之上。 关于Dag">
<meta name="keywords" content="Dagger">
<meta property="og:type" content="article">
<meta property="og:title" content="都是套路——Dagger2没有想象的那么难">
<meta property="og:url" content="http://yoursite.com/2016/10/30/都是套路——Dagger2没有想象的那么难/index.html">
<meta property="og:site_name" content="sososeen09 的博客">
<meta property="og:description" content="本文的分析基于dagger2的2.7版本。  谷歌开发维护的Dagger2出来有很长时间了，目前在很多开源项目上也能看到它的身影。看了一些文章和项目，发现Dagger2的入门虽然有些难，但还是有一些规律可循的。 对于开源的第三方项目，我认为都是有套路可循的，找到这个套路，入门就不会难了，难的是如何更好的在实际开发项目中灵活运用。而灵活运用必然是建立在对这些开源框架深刻理解的基础之上。 关于Dag">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2083810-33f9ffeb9c6436a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2083810-049a5487c6769ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-07-18T01:46:54.006Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="都是套路——Dagger2没有想象的那么难">
<meta name="twitter:description" content="本文的分析基于dagger2的2.7版本。  谷歌开发维护的Dagger2出来有很长时间了，目前在很多开源项目上也能看到它的身影。看了一些文章和项目，发现Dagger2的入门虽然有些难，但还是有一些规律可循的。 对于开源的第三方项目，我认为都是有套路可循的，找到这个套路，入门就不会难了，难的是如何更好的在实际开发项目中灵活运用。而灵活运用必然是建立在对这些开源框架深刻理解的基础之上。 关于Dag">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2083810-33f9ffeb9c6436a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/10/30/都是套路——Dagger2没有想象的那么难/"/>





  <title>都是套路——Dagger2没有想象的那么难 | sososeen09 的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sososeen09 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/30/都是套路——Dagger2没有想象的那么难/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sososeen09">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ic_avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sososeen09 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">都是套路——Dagger2没有想象的那么难</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-30T17:24:41+08:00">
                2016-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文的分析基于<a href="https://github.com/google/dagger" target="_blank" rel="noopener">dagger2的2.7版本</a>。</p>
</blockquote>
<p>谷歌开发维护的Dagger2出来有很长时间了，目前在很多开源项目上也能看到它的身影。看了一些文章和项目，发现Dagger2的入门虽然有些难，但还是有一些规律可循的。</p>
<p><strong>对于开源的第三方项目，我认为都是有套路可循的，找到这个套路，入门就不会难了，难的是如何更好的在实际开发项目中灵活运用。而灵活运用必然是建立在对这些开源框架深刻理解的基础之上。</strong></p>
<p>关于Dagger2这种依赖注入框架的好处在这只简单的提一下</p>
<ul>
<li>依赖的注入和配置独立于组件之外</li>
<li>依赖对象是在一个独立、不耦合的地方初始化。当初始化方式改变的时候修改的代码少。</li>
<li>依赖注入使得单元测试更加简单。</li>
</ul>
<p>那么Dagger2相对于其他的依赖注入框架，有哪些有点和缺点呢？</p>
<p><strong>优点：</strong></p>
<ul>
<li>编译期生成代码，生成的代码像手写的一样。而且如果有错误会在编译期报出。</li>
<li>错误可追踪</li>
<li>易于调试。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>缺少灵活性，很多代码要按照既定的规则写</li>
<li>没有动态机制。</li>
</ul>
<p>下面会展开对Dagger2的介绍，看看Dagger2都有哪些套路。文中的代码都是从自己写的一个Demo中提取，文末会给出项目地址。</p>
<h1 id="1-Dagger2的注解"><a href="#1-Dagger2的注解" class="headerlink" title="1 Dagger2的注解"></a>1 Dagger2的注解</h1><p>想要理解Dagger2，首先要理解Dagger2中的注解，至少先了解一下，否则理解Dagger2会有障碍。Dagger2的注解比较多，但主要的会有下面7种。</p>
<ul>
<li><p><strong>@Inject：</strong>@Inject注解有两个作用，1是在需要依赖的类（下面这样的类都会称为目标类）中标记成员变量告诉Dagger这个类型的变量需要一个实例对象。2是标记类中的构造方法，告诉Dagger我可以提供这种类型的依赖实例。</p>
</li>
<li><p><strong>@Provide:</strong> 对方法进行注解，都是有返回类型的。用来告诉Dagger我们想如何创建并提供该类型的依赖实例（一般会在方法中new出实例）。用@Provide标记的方法，谷歌推荐采用provide为前缀。</p>
</li>
<li><p><strong>@Module:</strong> @Module这个注解用来标记类（一般类名以Module结尾）。Module主要的作用是用来集中管理@Provide标记的方法。我们定义一个被@Module注解的类，Dagger就会知道在哪里找到依赖来满足创建类的实例。<strong>modules的一个重要特征是被设计成区块并可以组合在一起。</strong>（例如可以在App中看到多个组合在一起的modules）</p>
</li>
<li><p><strong>@Component:</strong>Components是组件，也可以称为注入器。是<strong>@Inject</strong>和<strong>@Module</strong>之间的桥梁，主要职责是把二者组合在一起。@Component注解用来标记接口或者抽象类。所有的components都可以通过它的modules知道它所提供的依赖范围。一个Component可以依赖一个或多个Component，并拿到被依赖Component暴露出来的实例，Component的<strong>dependencies</strong>属性就是确定依赖关系的实现。<br><img src="http://upload-images.jianshu.io/upload_images/2083810-33f9ffeb9c6436a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本原理.png"></p>
</li>
<li><p><strong>@Scope:</strong> 作用域。Scopes非常有用，Dagger2通过自定义注解来限定作用域。这是一个非常强大的功能，所有的对象都不再需要知道怎么管理它自己的实例。Dagger2中有一个默认的作用域注解@Singleton，通常在Android中用来标记在App整个生命周期内存活的实例。也可以自定义一个@PerActivity注解，用来表明生命周期与Activity一致。<strong>换句话说，我们可以自定义作用域的粒度（比如@PerFragment, @PerUser等等）。</strong></p>
</li>
<li><p><strong>@Qualifier:</strong> 限定符，也是很有用。<strong>当一个类的类型不足以标示一个依赖的时候，我们就可以用这个注解。</strong>例如，在Android中，我们需要不同类型的Context，我们可以自定义标识符注解<strong>“@ForApplication”</strong>和<strong>“@ForActivity”</strong>。这样的话，当注解一个Context的时候，我们可以用这个标识符来告诉Dagger我们想提供哪一种Context。Dagger2里面已经存在一个限定符@Named注解。</p>
</li>
<li><p><strong> @SubComponent:</strong>如果我们需要父组件全部的提供对象，这时我们可以用包含方式而不是用依赖方式，相比于依赖方式，包含方式不需要父组件显式显露对象，就可以拿到父组件全部对象。且SubComponent只需要在父Component接口中声明就可以了。</p>
</li>
</ul>
<h1 id="2-Dagger2的套路"><a href="#2-Dagger2的套路" class="headerlink" title="2 Dagger2的套路"></a>2 Dagger2的套路</h1><h2 id="2-1-最简单的运用"><a href="#2-1-最简单的运用" class="headerlink" title="2.1 最简单的运用"></a>2.1 最简单的运用</h2><p>最简单的Dagger2运用只采用两个注解@Inject和@Component即可。因为本身@Inject就自带两个作用。<br>如一个User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    //用这个@Inject表示来表示我可以提供User类型的依赖</span><br><span class="line">    @Inject</span><br><span class="line">    public User() &#123;</span><br><span class="line">        name = &quot;sososeen09&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要依赖的的目标类中标记成员变量，在这里我们这个目标类是OnlyInjectTestActivity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject //在目标类中@Inject标记表示我需要这个类型的依赖      </span><br><span class="line">User mUser;</span><br></pre></td></tr></table></figure>
<p>在Component中，Component内有一个方法是inject(OnlyInjectTestActivity onlyInjectTestActivity)，参数OnlyInjectTestActivity表示目标类，也就是把依赖实例注入该类中，必须精确，不能用父类代替。查看了一下编译后生成的代码，最后给变量赋值按照<strong>“类名.变量”</strong>来的。比如我们需要给mUser赋值，那么调用inject方法后，是按照<strong>“OnlyInjectTestActivity.mUser=xxx”</strong>来的。至于inject这个方法名是可以改的，但是谷歌推荐用inject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 没有modules和dependencies的情况下，纯粹用@Inject来提供依赖</span><br><span class="line"> */</span><br><span class="line">@Component()</span><br><span class="line">public interface OnlyInjectComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 必须有个目标让Component知道需要往哪个类中注入</span><br><span class="line">     * 这个方法名可以是其它的，但是推荐用inject</span><br><span class="line">     * 目标类OnlyInjectTestActivity必须精确，不能用它的父类</span><br><span class="line">     * 这是Dagger2的机制决定的</span><br><span class="line">     */</span><br><span class="line">    void inject(OnlyInjectTestActivity onlyInjectTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码就写好了，此时Make Project就会在build文件夹内生成对应的代码。我们的OnlyInjectComponent接口会生成一个<strong>以Dagger为前缀</strong>的DaggerOnlyInjectComponent类。<br>采用这个DaggerOnlyInjectComponent就能完成依赖对象的注入。可以在Activity的onCreate方法中调用如下代码，初始化注入。这样的话OnlyInjectTestActivity 中的成员变量mUser就完成了注入过程（也就是变量赋值过程）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerOnlyInjectComponent.builder().build().inject(this);</span><br></pre></td></tr></table></figure>
<p>整个依赖注入过程就结束了，是不是很简单。<br>@Inject提供依赖虽然很简单，但是它也有缺陷：</p>
<ul>
<li>只能标记一个构造方法，如果我们标记两个构造方法，编译的时候就会报错。因为不知道到底要用哪一个构造提供实例。</li>
<li>不能标记其它我们自己不能修改的类，如第三方库，因为我们没办法用@Inject标记它们的构造函数。</li>
</ul>
<p>举个例子，还是User类，有一个带参的构造方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    /**</span><br><span class="line">     * 用@Inject标记的构造函数如果有参数，那么这个参数也需要其它地方提供依赖。</span><br><span class="line">     * 但是@Inject有一个缺陷，就是对于第三方的类无能为力。因为我们不能修改第三方的构造函数，</span><br><span class="line">     * 所以对于String还有其他的一些我们不能修改的类，只能用@Module中的@Provides来提供实例了</span><br><span class="line">     */</span><br><span class="line">    @Inject</span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的注释写的很清楚了，如果用@Inject标记带参的构造方法，如String类型。那么这个String类参数也需要依赖，也就是说需要其它地方告诉Dagger可以提供一个String类型的对象。这个时候@Inject就无能为力了，你没办法修改String类给它的构造方法加上@Inject标记啊。所以必须要用我们另一个强大的标记@Module了。</p>
<h2 id="2-2-采用-Module提供依赖"><a href="#2-2-采用-Module提供依赖" class="headerlink" title="2.2 采用@Module提供依赖"></a>2.2 采用@Module提供依赖</h2><p>采用@Module标记的类提供依赖是一个常规套路，我们在项目中运用最多的也是这种方式。前面已经提到，@Module标记的类主要起到一个管理作用，真正提供依赖实例靠的是@Provides标记的带返回类型的方法。</p>
<p>这次以一个Person类为例，Person类如下，构造方法没有用@Inject标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public Person(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        sex = &quot;太监&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用Module提供Person实例，Module代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    Person providePerson() &#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码也算是一个固定套路了，用@Module标记类，用@Provides标记方法。如果想用Module提供实例，还要有一个Component，如我们下面的PersonComponent 。这个PersonComponent 与纯粹用@Inject方式提供依赖不同，还需要有一个modules指向DataModule 。这是告诉Component我们用DataModule 提供你想要的类型的实例。其它的方式相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = DataModule.class)</span><br><span class="line">public interface PersonComponent &#123;</span><br><span class="line">    void inject(ModuleTestActivity moduleTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModuleTestActivity 中需要一个Person类型的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">Person mPerson;</span><br></pre></td></tr></table></figure>
<p>编译之后，我们就可以在目标类ModuleTestActivity 中进行初始化注入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerPersonComponent.builder().dataModule(new DataModule()).build().inject(this);</span><br></pre></td></tr></table></figure>
<p>与纯粹用@Inject提供实例不同。新增加了一个dataModule方法，参数是DataModule类型的。因为PersonComponent需要依赖DataModule提供实例，当然也需要一个DataModule对象了。在这里，需要说明一点：<strong>如果DataModule只有一个默认的无参构造方法，我们是可以不用调用dataModule方法的</strong>，而且此时我们还可以用一个更简单的方式来替代，采用create()方法。之前讲的纯粹用@Inject提供依赖实例的方式也可以这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//如果DataModule有一个无参构造方法</span><br><span class="line">DaggerPersonComponent.create().inject(this);</span><br></pre></td></tr></table></figure>
<p>这样的话，依赖注入过程结束。mPerson已经被赋值。<br><strong>完成上面两步之后我们会不会有这样的思考：</strong>如果同时有@Module和@Inject构造方法来提供同一类型的实例，Dagger会调用哪个呢？这就牵涉到@Module和@Inject的优先级问题了。</p>
<h2 id="2-3-Module和-Inject的优先级问题"><a href="#2-3-Module和-Inject的优先级问题" class="headerlink" title="2.3 @Module和@Inject的优先级问题"></a>2.3 @Module和@Inject的优先级问题</h2><p>虽然优先级的问题，我们可以直接说出来，但还是亲手做一个实验好了，这样印象必定会更深刻。而且当你告诉别人这个结论的时候，你就可以挺直腰板的说就是这样，不然心里总虚啊。<br>新建一个实体类PriorityTestEntity，用@Inject标记构造方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityTestEntity &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public PriorityTestEntity() &#123;</span><br><span class="line">        name = &quot;我是@Inject注解提供的对象&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PriorityTestEntity(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DataModule中有一个方法，返回值类型是PriorityTestEntity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    PriorityTestEntity providePriorityTestEntity() &#123;</span><br><span class="line">        return new PriorityTestEntity(&quot;我是module提供的对象&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>新建Component，PriorityTestComponent，有一个inject()方法，注入目标类<br>PriorityTestActivity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = &#123;DataModule.class&#125;)</span><br><span class="line">public interface PriorityTestComponent &#123;</span><br><span class="line">    //注入目标类PriorityTestActivity </span><br><span class="line">    void inject(PriorityTestActivity priorityTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的就是在PriorityTestActivity 中进行初始化注入了，步骤都是跟之前讲的一样，真真的是套路啊，没什么难度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在PriorityTestActivity 中</span><br><span class="line">//@Inject标记成员变量</span><br><span class="line">@Inject</span><br><span class="line">PriorityTestEntity mPriorityTestEntity;</span><br><span class="line"></span><br><span class="line">//初始化注入</span><br><span class="line">DaggerPriorityTestComponent.create().inject(this);</span><br><span class="line"></span><br><span class="line">//调用代码验证</span><br><span class="line">mTvShowUser.setText(mPriorityTestEntity.getName());</span><br><span class="line"></span><br><span class="line">//最后TextView上会显示&quot;我是module提供的对象&quot;</span><br></pre></td></tr></table></figure>
<p>总结一句话就是：<strong>在提供依赖对象这一层面上，@Module级别高于@Inject。</strong></p>
<h2 id="2-4-初始化依赖实例的步骤"><a href="#2-4-初始化依赖实例的步骤" class="headerlink" title="2.4 初始化依赖实例的步骤"></a>2.4 初始化依赖实例的步骤</h2><p>讲完了@Mudule和@Inject的优先级问题，我们可以总结一下Dagger是如何查找所需的依赖实例进行注入了。</p>
<p><strong>步骤如下：</strong></p>
<ol>
<li><p>查找Module中是否存在创建该类型的方法（前提是@Conponent标记的接口中包含了@Module标记的Module类，如果没有则直接找@Inject对应的构造方法）</p>
</li>
<li><p>若存在方法，查看该方法是否有参数</p>
<ul>
<li>若不存在参数，直接初始化该类的实例，一次依赖注入到此结束。</li>
<li>若存在参数，则从<strong>步骤1</strong>开始初始化每个参数</li>
</ul>
</li>
</ol>
<ol>
<li>若不存在创建类方法，则查找该类型的类中有@Inject标记的构造方法，查看构造方法中是否有参数<ul>
<li>若构造方法中无参数，则直接初始化该类实例，一次依赖注入到此结束。</li>
<li>若构造方法中有参数，从<strong>步骤1</strong>依次开始初始化每个参数。</li>
</ul>
</li>
</ol>
<p>如果你要问：<strong>我既没有@Module提供的实例，也没有@Inject标记的构造方法会怎样？很简单，编译期就会报错。</strong></p>
<p><strong>Dagger2的报错提醒还是很好的，能帮你快速的查找出问题所在。</strong></p>
<h2 id="2-5-Qualifier限定符有什么神奇的作用"><a href="#2-5-Qualifier限定符有什么神奇的作用" class="headerlink" title="2.5 @Qualifier限定符有什么神奇的作用"></a>2.5 @Qualifier限定符有什么神奇的作用</h2><p>@Qualifier这个限定符在项目中也会比较有用，比如之前讲的在Android中同样的Context，有ApplicationContext还有Activity的Context，就可以用自定义的<strong>“@ForApplication”</strong>和<strong>“@ForActivity”</strong>限定符来表示。Dagger2中已经有一个定义好的限定符@Named，长的是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Named &#123;</span><br><span class="line"></span><br><span class="line">    /** The name. */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面还是以Person为例，并且我们自定义一个限定符来看看这个东西具体如何使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public Person(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        sex = &quot;太监&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，默认的Person对象是一个太监，那么我想要一个<strong>“妹子”</strong>和<strong>“汉子”</strong>，还想自定义一个，如何区分呢？</p>
<p>我们先自定义一个限定符@PersonQualifier：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PersonQualifier &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DataModule，我们额外提供“汉子”、“妹子”和”qualifier sex”，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line"></span><br><span class="line">//一个默认的</span><br><span class="line">    @Provides</span><br><span class="line">    Person providePerson() &#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//采用@Qualifier注解，表示我可以提供这种标识符的Person</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;male&quot;)</span><br><span class="line">    Person providePersonMale() &#123;</span><br><span class="line">        return new Person(&quot;汉子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;female&quot;)</span><br><span class="line">    Person providePersonFemale() &#123;</span><br><span class="line">        return new Person(&quot;妹子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @PersonQualifier</span><br><span class="line">    Person providePersonByQualifier() &#123;</span><br><span class="line">        return new Person(&quot;qualifier sex&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Component长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = DataModule.class)</span><br><span class="line">public interface PersonComponent &#123;</span><br><span class="line">    void inject(ModuleTestActivity moduleTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要依赖的类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//在ModuleTestActivity中成员变量这样标记。</span><br><span class="line">    @Inject</span><br><span class="line">    Person mPerson;</span><br><span class="line"></span><br><span class="line">    //这么多对象，如果需要特定的对象，用@Qualifier标识符注解，@Named是自定义的一个标识符注解</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;male&quot;)</span><br><span class="line">    Person mPersonMale;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;female&quot;)</span><br><span class="line">    Person mPersonFemale;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @PersonQualifier</span><br><span class="line">    Person mPersonQualifier;</span><br></pre></td></tr></table></figure>
<p>然后注入，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerPersonComponent.builder().dataModule(new DataModule()).build().inject(this);</span><br></pre></td></tr></table></figure>
<p>查看Person对象的性别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPerson.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonMale.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonFemale.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonQualifier.getSex());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>就可以看到，我们拿到了我们想要的对象。</p>
<h2 id="2-6-Scope作用域怎么用"><a href="#2-6-Scope作用域怎么用" class="headerlink" title="2.6 @Scope作用域怎么用"></a>2.6 @Scope作用域怎么用</h2><p>个人觉得，@Scope的作用主要是在组织Component和Module的时候起到一个提醒和管理的作用。<br>Dagger2中有一个默认的作用域@Singleton，是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Singleton &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看到Singleton，都会觉得Dagger2这么吊，标记一下就能创建单例了？后来研究了一下发现，这个@Singleton并没有创建单例的能力，或者也可以说不是我们常规用的那种单例，直接用AClass.getInstance()就能获取一个AClass的一个全局单例了。</p>
<p>下面我们看看，这个@Singleton怎么用，又是如何获取单例的。<br>我们有一个实体SingletonTestEntity，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTestEntity &#123;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public SingletonTestEntity(String desc) &#123;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DataModule中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Singleton</span><br><span class="line">    SingletonTestEntity provideSingletonTestEntity() &#123;</span><br><span class="line">        return new SingletonTestEntity(&quot;测试单例&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个SingletonTestComponent ，我们之前说过@Component可以标注接口，也可以标注抽象类，我们就把这个SingletonTestComponent 改成了抽象类。<br><strong>需要说明的是：</strong>DataModule中的SingletonTestEntity 使用@Singleton标注了，那么对应的Component也必须采用@Singleton标注，表明它们的作用域一致，否则编译的时候会报作用域不同的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = &#123;DataModule.class&#125;)</span><br><span class="line">@Singleton//这个Component的@Scope要和对应的Module的@Scope一致</span><br><span class="line">public abstract class SingletonTestComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * /@Component不仅可以注解接口也可以注解抽象类，为了方便测试单例，把Component改为抽象类，</span><br><span class="line">     * 实际开发中可以在Application中创建单例。</span><br><span class="line">     */</span><br><span class="line">    public abstract void inject(SingletonTestActivity singletonTestActivity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SingletonTestComponent必须是单例的，</span><br><span class="line">     * 否则怎么能保证不同的Component对象提供同一个依赖实例呢？</span><br><span class="line">     */</span><br><span class="line">    private static SingletonTestComponent sComponent;</span><br><span class="line"></span><br><span class="line">    public static SingletonTestComponent getInstance() &#123;</span><br><span class="line">        if (sComponent == null) &#123;</span><br><span class="line">            sComponent = DaggerSingletonTestComponent.builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        return sComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们新建一个SingletonTestActivity，显示mSingletonTestEntity这个对象，有一个Button用于启动一个新的SingletonTestActivity，这样我们就可以看每次这个mSingletonTestEntity是不是同一个，是的话当然就能说明我们创建的这个实体对象是单例了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//成员变量</span><br><span class="line">@Inject</span><br><span class="line">SingletonTestEntity mSingletonTestEntity;</span><br><span class="line"></span><br><span class="line">//展示mSingletonTestEntity这个对象</span><br><span class="line">mTvShowUser.setText(mSingletonTestEntity.getDesc() + &quot;: &quot; + mSingletonTestEntity);</span><br></pre></td></tr></table></figure>
<p>上面少了一步，就是初始化注入，我一开始是这么初始化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerSingletonTestComponent.builder().build().inject(this);</span><br></pre></td></tr></table></figure>
<p>然后我发现每次启动新的Activity，拿到的SingletonTestEntity不是同一个，让我很困惑，还以为是用的姿势不对。后来研究了一下生成的代码，也查了一些文章，发现真的是我用的姿势不对。初始化依赖注入应该这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingletonTestComponent.getInstance().inject(this);</span><br></pre></td></tr></table></figure>
<p>这样的话，我们的这个注入器SingletonTestComponent就首先实实在在地变成一个单例了，用这个Component去注入的依赖才是单例的。</p>
<p>说到这大家可能也看到了，这怎么能是单例呢？我们常规理解的单例是类在虚拟机中只有一个对象。而我们这个依赖实例其实只是每次都由同一个Component注入器对象提供，重新生成一个Component对象的话注入的依赖实例就不再是同一个。</p>
<p>我们还可以仿造@Singleton自定义一个作用域，如@PerActivity，用来表示跟Activity的生命周期一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PerActivity &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的用法就不再介绍了，跟@Singleton用法一样，项目中可以看。</p>
<p><strong>总结一下：想要用Component只提供同一个实例对象，就必须保证Component只初始化一次。</strong></p>
<h2 id="2-7-重点和难点——组织Component"><a href="#2-7-重点和难点——组织Component" class="headerlink" title="2.7 重点和难点——组织Component"></a>2.7 重点和难点——组织Component</h2><p>通过上述的讲解可以发现，Dagger2也没有想象的那么难啊。但是不得不说，Dagger2入门并不难，想要灵活运用就不容易了。主要的原因就是在实际开发中我们要好好的组织Component，那么多页面，那么多类，我们怎么写Component就有学问了。Component有3种组织方式：</p>
<ul>
<li>依赖方式——一个Component可以依赖一个或多个Component，采用的是@Component的<strong>dependencies</strong>属性。</li>
<li>包含方式——这里就用到了我们<strong>@SubComponent</strong>注解，用@SubComponent标记接口或者抽象类，表示它可以被包含。一个Component可以包含一个或多个Component，而且被包含的Component还可以继续包含其他的Component。说起来跟Activity包含Fragment方式很像。</li>
<li>继承方式——用一个Component继承另外一个Component。</li>
</ul>
<p>下面这张图，是<strong><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">Android-CleanArchitecture</a></strong>项目Component组织方式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083810-049a5487c6769ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组织方式.png"></p>
<p>可以看到这么划分的思想是：</p>
<ul>
<li>我们需要一个ApplicationComponent，管理在App的全局实例，保证在App生命周期内，对象只有一个。例如网络请求的全局HttpClient。</li>
<li>ActivityComponent: 负责管理生命周期跟Activity一样的组件。</li>
<li>UserComponent: 继承于ActivityComponent的组件，通常会在Activity内部的Fragment中使用。</li>
</ul>
<p>说到这，我想提一下上面为了演示@Singleton的用法，我们并没有在Application中进行初始化。个人觉得，实际开发中用@Singleton标记来表示在App生命周期内全局的对象，然后用自定义的@PerActivity、@PerFragment等来表示跟Activity、Fragment生命周期一致比较好。</p>
<p>现在我们采用依赖、包含、继承的方式来演示Component的组织方式。就提供一个全局的ApplicationContext好了，只是演示，没必要那么复杂。</p>
<p>Module类是这样的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line"></span><br><span class="line">    private final Application application;</span><br><span class="line"></span><br><span class="line">    public AppModule(Application application) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Singleton</span><br><span class="line">    Context getAppContext() &#123;</span><br><span class="line">        return application;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppComponent是这样的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Exposed to sub-graphs.</span><br><span class="line">     * 其他的依赖想要用这个Context，必须显式的暴露。</span><br><span class="line">     * 因为，其它依赖这个的Component需要Context，然后这个Context会去AppModule中找对应的Context</span><br><span class="line">     * 与方法名无关，只与返回类型有关</span><br><span class="line">     * 举个例子：小弟B依赖大哥A,A有一把杀猪刀。哪天小弟碰上事了，找大哥借一把刀，</span><br><span class="line">     * 如果大哥把刀藏起来不给小弟用，小弟会因为找不到刀用很崩溃的。（程序编译报错），</span><br><span class="line">     * 所以必须是大哥把刀拿出来给小弟用，小弟才能拿出去用啊。（代码正常）</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    Context context();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要其它依赖这个AppComponent的Component并使用使用全局的Appliation Context，我们必须显式地暴露出去。</p>
<p>这个AppComponent接口内没有inject方法，因为具体地注入哪个类，是由依赖它的Component决定的。</p>
<p>我们自定义Appliation ，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class App extends Application &#123;</span><br><span class="line">    private static AppComponent sAppComponent = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        if (sAppComponent == null) &#123;</span><br><span class="line">            sAppComponent = DaggerAppComponent.builder()</span><br><span class="line">                                              .appModule(new AppModule(this))</span><br><span class="line">                                              .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AppComponent getAppComponent() &#123;</span><br><span class="line">        //向外界的依赖提供这个AppComponent</span><br><span class="line">        return sAppComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>再次强调：这个AppConponent只能初始化一次</strong></p>
<h3 id="2-7-1-依赖"><a href="#2-7-1-依赖" class="headerlink" title="2.7.1 依赖"></a>2.7.1 依赖</h3><p>现在我们有一个ActivityComponent，需要依赖这个AppComponent ，那么写出来是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@PerActivity</span><br><span class="line">//@Singleton //不能与依赖的AppComponent的作用域相同，否则会报错</span><br><span class="line">@Component(dependencies = AppComponent.class, modules = ActModule.class)</span><br><span class="line">public interface ActivityComponent &#123;</span><br><span class="line"></span><br><span class="line">    void inject(DependenceTestActivity DependenceTestActivity);</span><br><span class="line"></span><br><span class="line">    void inject(SubComponentTestActivity subComponentTestActivity);</span><br><span class="line"></span><br><span class="line">    //包含SubComponent,这样的话该SubComponent也可以拿到ActivityComponent中能提供的依赖。</span><br><span class="line">    ActSubComponent getActSubComponent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Component依赖另一个Component，它们的作用域不能相同</strong>。所以我们自定义了一个@PerActivity作用域。<br>我们的这个ActivityComponent本身也可以需要Module提供依赖实例，如ActModule，这个ActModule没有作用域。至于ActEntity的代码，我们就不贴出来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class ActModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    ActEntity getActEntity() &#123;</span><br><span class="line">        return new ActEntity(&quot;我是ActEntity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化注入是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DaggerActivityComponent.builder()</span><br><span class="line">                       .appComponent(((App) getApplication()).getAppComponent())</span><br><span class="line">                       .build()</span><br><span class="line">                       .inject(this);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-包含"><a href="#2-7-2-包含" class="headerlink" title="2.7.2 包含"></a>2.7.2 包含</h3><p>上面的ActSubComponent 是被包含，它需要有个@Subcomponent注解，如果是包含的方式，作用域可以与包含它的Component一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Subcomponent</span><br><span class="line">@PerActivity //如果是包含的方式，作用域与上一层的Component相同也没关系。采用依赖的方式就不行。</span><br><span class="line">public interface ActSubComponent &#123;</span><br><span class="line">    void inject(SubFragment subFragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化注入是这个样子：<br>在Activity中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mActivityComponent = DaggerActivityComponent</span><br><span class="line">                    .builder()</span><br><span class="line">                    .appComponent(((App) getApplication()).getAppComponent())</span><br><span class="line">                    .actModule(new ActModule())</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>
<p>然后在Fragment中拿到这个mActivityComponent :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((SubComponentTestActivity) getActivity()).getActivityComponent()</span><br><span class="line">                                          .getActSubComponent()</span><br><span class="line">                                          .inject(this);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-3-继承"><a href="#2-7-3-继承" class="headerlink" title="2.7.3 继承"></a>2.7.3 继承</h3><p>我们的ExtendTestComponent继承了ActivityComponent，那么ActivityComponent中需要的Module我们就必须提供。有的人可能会问ActivityComponent并没有AppModule啊，那是因为ActivityComponent依赖了AppComponent，由AppComponent提供了AppModule。</p>
<p>ExtendTestComponent有@Singleton标记，这是因为AppModule中有@Singleton作用域。如果ActModule中有一个@PerActivity作用域的话，这个Component必须要再加上@PerActivity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ExtendTestComponent继承了ActivityComponent，</span><br><span class="line"> * 如果ActivityComponent中的modules定义了创建实例的方法，</span><br><span class="line"> * ExtendTestComponent中也必须提供相应的modules。</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;ActModule.class, AppModule.class&#125;)</span><br><span class="line">public interface ExtendTestComponent extends ActivityComponent &#123;</span><br><span class="line">    void inject(ExtendTestActivity extendTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化注入是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DaggerExtendTestComponent.builder()</span><br><span class="line">                         .appModule(new AppModule(getApplication()))</span><br><span class="line">                         .actModule(new ActModule())</span><br><span class="line">                         .build()</span><br><span class="line">                         .inject(this);</span><br></pre></td></tr></table></figure>
<p>哦了，先到这吧。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>通过上面的内容，至少可以了解Dagger2中常用的一些注解以及组织方式，在这里做一下简单的总结：</p>
<ul>
<li>@Module提供依赖的优先级高于@Inject</li>
<li>@Singleton并不是真的能创建单例，但我们依然可以保证在App的生命周期内一个类只存在一个对象。@Singleton更重要的作用是通过标记提醒我们自己来达到更好的管理实例的目的。</li>
<li>Component的作用域必须与对应的Module作用域一致，如果@Module没有标记作用域，就不影响。</li>
<li>Component和依赖的Component作用域范围不能一样，否则会报错。一般来讲，我们应该对每个Component都定义不同的作用域。</li>
<li>由于@Inject，@Module和@Provides注解是分别验证的，所有绑定关系的有效性是在@Component层级验证。（在这里提一下，本文没有讲这个具体过程）</li>
</ul>
<p>本文内容都是个人理解与实践，难免有错误和遗漏之处，欢迎指正，共同学习。<br><a href="https://github.com/sososeen09/ThirdPartDemo/tree/dagger2_study1/dagger2" target="_blank" rel="noopener">项目地址</a></p>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="http://google.github.io/dagger/" target="_blank" rel="noopener">dagger谷歌官方文档</a></li>
<li><a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="noopener">Tasting Dagger 2 on Android</a>    —— <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html" target="_blank" rel="noopener">对应翻译</a></li>
<li><a href="http://www.jianshu.com/p/cd2c1c9f68d4" target="_blank" rel="noopener">Android：dagger2让你爱不释手-基础依赖注入框架篇</a></li>
<li><a href="http://www.jianshu.com/p/1d42d2e6f4a5" target="_blank" rel="noopener">Android：dagger2让你爱不释手-重点概念讲解、融合篇</a></li>
<li><a href="http://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></li>
<li><a href="https://dreamerhome.github.io/2016/07/07/dagger/" target="_blank" rel="noopener">依赖注入神器：Dagger2详解系列</a></li>
<li><a href="http://zpayh.xyz/2016/07/07/Dagger2%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Dagger2使用详解</a></li>
<li><a href="http://blog.zhaiyifan.cn/2016/03/27/android-new-project-from-0-p4/" target="_blank" rel="noopener">从零开始的Android新项目4 - Dagger2篇</a></li>
<li><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="noopener">Dagger2图文完全教程</a></li>
<li><a href="http://blog.csdn.net/u012943767/article/details/51954939" target="_blank" rel="noopener">Dagger2 彻底了解如何构建依赖关系</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Dagger/" rel="tag"># Dagger</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/23/Android源码分析之消息机制Handler/" rel="next" title="Android源码分析之消息机制Handler">
                <i class="fa fa-chevron-left"></i> Android源码分析之消息机制Handler
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/14/重识OkHttp——更深入了解如何使用/" rel="prev" title="重识OkHttp——更深入了解如何使用">
                重识OkHttp——更深入了解如何使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/ic_avatar.jpeg"
                alt="sososeen09" />
            
              <p class="site-author-name" itemprop="name">sososeen09</p>
              <p class="site-description motion-element" itemprop="description">未来的不可知是前进的原动力</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sososeen09" target="_blank" title="Github">
                      
                        <i class="fa fa-fw fa-globe"></i>Github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/16925b46816d" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Dagger2的注解"><span class="nav-number">1.</span> <span class="nav-text">1 Dagger2的注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Dagger2的套路"><span class="nav-number">2.</span> <span class="nav-text">2 Dagger2的套路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-最简单的运用"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 最简单的运用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-采用-Module提供依赖"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 采用@Module提供依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Module和-Inject的优先级问题"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 @Module和@Inject的优先级问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-初始化依赖实例的步骤"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 初始化依赖实例的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Qualifier限定符有什么神奇的作用"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 @Qualifier限定符有什么神奇的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Scope作用域怎么用"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 @Scope作用域怎么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-重点和难点——组织Component"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 重点和难点——组织Component</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-依赖"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-包含"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.7.2 包含</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-继承"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.7.3 继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-总结"><span class="nav-number">3.</span> <span class="nav-text">3 总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sososeen09</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
