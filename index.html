<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/18/网络协议相关知识介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/18/网络协议相关知识介绍/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-18T10:59:13+08:00">
                2018-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: 网络协议相关知识介绍</p>
<h2 id="date-2018-06-03-18-36-00"><a href="#date-2018-06-03-18-36-00" class="headerlink" title="date: 2018-06-03 18:36:00"></a>date: 2018-06-03 18:36:00</h2><h1 id="网络的五层划分"><a href="#网络的五层划分" class="headerlink" title="网络的五层划分"></a>网络的五层划分</h1><p>网络层次的划分有OSI（Open System Interconnect，开放式系统互联）七层模型和TCP/IP模型。<br>OSI模型按照从顶层到底层划分7层，分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。<br>由于OSI模型划分的层数太多、模型比较复杂，实现起来比较困难，因此当前网络模型使用的是TCP/IP模型。<br>TCP/IP是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将网络分成四个层次，每一层都有对应的协议：</p>
<ul>
<li>应用层，支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信，包含的协议有HTTP、STMP、FTP</li>
<li>传输层，负责为信源和信宿提供应用程序进程间的数据传输服务，包含的协议有TCP、UDP</li>
<li>网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题，对应的是协议有IP协议、ARP协议等</li>
<li>网络接口层，该层也可细分为数据链路层和物理层，网络层负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。数据链路层负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。协议有以太网、Wi-Fi、MPLS等。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-9a2e7bb68df59264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络各层连接示意图"></p>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p>先说UDP吧，UDP的全称是User Datagram Protocol，又称为<strong>用户数据报文协议</strong>，UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议），而且不保证接收端可以收到。在一些即时通讯领域会采用UDP。</p>
<p>TCP的全程是Transmission Control Protocol，又称为<strong>传输控制协议</strong>，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>那么TCP是如何保证可靠性的呢？</p>
<p>TCP保证可靠性的手段有：停止等待协议、滑动窗口协议、流量控制、拥塞控制等。</p>
<ul>
<li>应用数据被分割成TCP认为最适合发送的数据块。</li>
<li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<ul>
<li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
</ul>
</li>
<li>校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。<ul>
<li>TCP的接收端会丢弃重复的数据。 </li>
</ul>
</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 </li>
<li>拥塞控制：当网络拥塞时，减少数据的发送。</li>
</ul>
<h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p>三次握手（Three-Way Handshake）即建立TCP连接，指的是在建立TCP连接的过程中，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-32dbd1e7141ab98a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3次握手"></p>
<p>那么为什么需要3次握手呢？</p>
<p>我们先来分析一下如果只有2次握手会怎么样，客户端发送一个请求，服务端发出一个响应，此时的情况下连接有可能根本就没有建立起来，因为网络传输是要花费时间的，服务端处理一个客户端连接也可以需要时间，客户端有可能在发送一个连接请求之后马上就关闭了，而此时服务端只是向客户端发送了一个确认的包，紧接着就开始处理网络请求了，这种情况下是不可能成功的。而且既然不需要等待客户端再次发出一个确认数据包，2次握手等同于1次握手，连接不可靠。</p>
<p>如果超过3次握手也没这个必要，毕竟3次就已经可以保证连接建立了。</p>
<h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p>四次挥手（Four-Way Wavehand）即终止TCP连接，也就是说断开连接的时候需要客户端和服务端总共发送4个包来确认连接的断开。这个断开连接的过程可以由客户端和服务端任意一方来发起。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-460ddbfd1b392381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手——客户端主动关闭"></p>
<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 </li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 </li>
</ul>
<p>4次挥手还存在着两端同时发起主动关闭的情况，流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-f88a83c1b0f3175f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手——双方同时主动关闭.png"></p>
<p>那么为什么需要4次挥手才能保证连接的断开呢？<br>这是因为客户端和服务端的读写是双向的，客户端和服务端都要分别发出两个包：</p>
<ul>
<li>一个数据包用来表示不再发送数据了</li>
<li>一个数据包用来表示不再接收数据了 </li>
</ul>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E7%9A%84%E5%B1%82" target="_blank" rel="noopener">因特网协议栈中的层</a></li>
<li><a href="https://blog.csdn.net/cmm0401/article/details/77878998" target="_blank" rel="noopener">我是如何讲清楚TCP协议是如何保证可靠传输的</a></li>
<li><a href="https://www.cnblogs.com/yangbodong/p/4964698.html" target="_blank" rel="noopener">停止等待协议,连续ARQ协议,滑动窗口协议</a></li>
<li><a href="https://blog.csdn.net/renzhenhuai/article/details/12105457" target="_blank" rel="noopener">TCP/IP协议 三次握手与四次挥手</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/12/Android Gradle Plugin打包Apk过程中的Transform API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/Android Gradle Plugin打包Apk过程中的Transform API/" itemprop="url">Android Gradle Plugin打包Apk过程中的Transform API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T12:42:00+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文以com.android.tools.build:gradle:3.1.2 源码来进行分析，文章对应的项目地址：<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>。</p>
</blockquote>
<p>Transform API 是在1.5.0-beta1版开始使用，利用Transform API，第三方的插件可以在.class文件转为dex文件之前，对一些.class 文件进行处理。Transform API 简化了这个处理过程，而且使用起来很灵活。</p>
<h1 id="使用Transform-API"><a href="#使用Transform-API" class="headerlink" title="使用Transform API"></a>使用Transform API</h1><p>使用Transform API主要是写一个类继承Transform，并把该Transform注入到打包过程中。<br>注入Transform很简单，先获取<code>com.android.build.gradle.AppExtension</code>对象，然后调用它的registerTransform()方法。<br>这个方法实际上是属于BaseExtension的，AppExtension继承自BaseExtension。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#com.android.build.gradle.BaseExtension</span><br><span class="line">public void registerTransform(@NonNull Transform transform, Object... dependencies) &#123;</span><br><span class="line">    transforms.add(transform);</span><br><span class="line">    transformDependencies.add(Arrays.asList(dependencies));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入Transform对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AppExtension android = project.extensions.getByType(AppExtension)</span><br><span class="line">android.registerTransform(new AJXTransform(project))</span><br></pre></td></tr></table></figure>
<p>AJXTransform是自定义的Transform类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">lass AJXTransform extends Transform &#123;</span><br><span class="line">    Project project</span><br><span class="line">    AJXTransform(Project project) &#123;</span><br><span class="line">        this.project = project</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;ajx&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        // 输入类型，可以使class文件，也可以是源码文件 ，这是表示输入的class文件</span><br><span class="line">        return ImmutableSet.&lt;QualifiedContent.ContentType&gt; of(QualifiedContent.DefaultContentType.CLASSES)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        // 作用范围</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        //是否支持增量编译</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        //在这里对输入输出的class进行处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContentType是一个接口，默认有一个枚举类型DefaultContentType实现了ContentType，包含有CLASSES和RESOURCES类型。</p>
<ul>
<li>CLASSES类型表示的是在jar包或者文件夹中的.class文件。</li>
<li>RESOURCES类型表示的是标准的Java源文件。</li>
</ul>
<p>Scope 作用范围</p>
<table>
<thead>
<tr>
<th>Scope类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROJECT</td>
<td>只处理当前的项目</td>
</tr>
<tr>
<td>SUB_PROJECTS</td>
<td>只处理子项目</td>
</tr>
<tr>
<td>EXTERNAL_LIBRARIES</td>
<td>只处理外部的依赖库</td>
</tr>
<tr>
<td>TESTED_CODE</td>
<td>只处理测试代码</td>
</tr>
<tr>
<td>PROVIDED_ONLY</td>
<td>只处理provided-only的依赖库</td>
</tr>
<tr>
<td>PROJECT_LOCAL_DEPS</td>
<td>只处理当前项目的本地依赖,例如jar, aar（过期，被EXTERNAL_LIBRARIES替代）</td>
</tr>
<tr>
<td>SUB_PROJECTS_LOCAL_DEPS</td>
<td>只处理子项目的本地依赖,例如jar, aar（过期，被EXTERNAL_LIBRARIES替代）</td>
</tr>
</tbody>
</table>
<p>Transform中的getInputTypes()方法和getScopes() 方法返回的是Set集合，因此这些类型是可以进行组合的。在<code>com.android.build.gradle.internal.pipeline.TransformManager</code>中就包含了多种Set集合。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-09a2feedc88f88b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TransformManager.png"></p>
<p>Transform 的 <code>isIncremental()</code> 方法表示是否支持增量编译，返回true的话表示支持，这个时候可以根据 <code>com.android.build.api.transform.TransformInput</code> 来获得更改、移除或者添加的文件目录或者jar包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface TransformInput &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a collection of &#123;@link JarInput&#125;.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;JarInput&gt; getJarInputs();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a collection of &#123;@link DirectoryInput&#125;.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;DirectoryInput&gt; getDirectoryInputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JarInput有一个方法是<code>getStatus()</code>来获取 <code>com.android.build.api.transform.Status</code>。Status是一个枚举类，包含了NOTCHANGED、ADDED、CHANGED、REMOVED，所以可以根据JarInput的status来对它进行相应的处理，比如添加或者移除。</p>
<p>DirectoryInput有一个方法<code>getChangedFiles()</code>开获取一个Map<file, status="">集合，所以可以遍历这个Map集合，然后根据File对应的Status来对File进行处理。</file,></p>
<p>如果不支持增量编译，就在处理.class之前把之前的输出目录中的文件删除。</p>
<p>获取TransformInput对象是根据 <code>com.android.build.api.transform.TransformInvocation</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface TransformInvocation &#123;</span><br><span class="line">// 返回transform运行的上下文，在android gradle plugin中有唯一的实现类TransformTask</span><br><span class="line">    @NonNull</span><br><span class="line">    Context getContext();</span><br><span class="line"></span><br><span class="line">// 获取transform的输入</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;TransformInput&gt; getInputs();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the referenced-only inputs which are not consumed by this transformation.</span><br><span class="line">     * @return the referenced-only inputs.</span><br><span class="line">     */</span><br><span class="line">    @NonNull Collection&lt;TransformInput&gt; getReferencedInputs();</span><br><span class="line">    /**</span><br><span class="line">     * Returns the list of secondary file changes since last. Only secondary files that this</span><br><span class="line">     * transform can handle incrementally will be part of this change set.</span><br><span class="line">     * @return the list of changes impacting a &#123;@link SecondaryInput&#125;</span><br><span class="line">     */</span><br><span class="line">    @NonNull Collection&lt;SecondaryInput&gt; getSecondaryInputs();</span><br><span class="line"></span><br><span class="line">//TransformOutputProvider用于删除输出目录或者创建文件对应的生成目录</span><br><span class="line">    @Nullable</span><br><span class="line">    TransformOutputProvider getOutputProvider();</span><br><span class="line"></span><br><span class="line">// transform过程是否支持增量编译</span><br><span class="line">    boolean isIncremental();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransformInvocation包含了输入、输出相关信息。其输出相关内容是由TransformOutputProvider来做处理。TransformOutputProvider的getContentLocation()方法可以获取文件的输出目录，如果目录存在的话直接返回，如果不存在就会重新创建一个。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// getContentLocation方法相当于创建一个对应名称表示的目录</span><br><span class="line">// 是从0 、1、2开始递增。如果是目录，名称就是对应的数字，如果是jar包就类似0.jar</span><br><span class="line">File outputDir = transformInvocation.outputProvider.getContentLocation(&quot;include&quot;, </span><br><span class="line">         dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)</span><br><span class="line"></span><br><span class="line">File outputJar = transformInvocation.outputProvider.getContentLocation(jarInput.name</span><br><span class="line">        , jarInput.contentTypes</span><br><span class="line">        , jarInput.scopes</span><br><span class="line">        , Format.JAR)</span><br></pre></td></tr></table></figure>
<p>在执行编译过程中会生成对应的目录，例如在/app/build/intermediates/transforms目录下生成了一个名为<code>ajx</code>的目录，这个名称就是根据自定义的Transform类<code>getName()</code>方法返回的字符串来的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-c5cb7d8fcabd333d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transforms下的ajx目录.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-7fa9504bbe5ff237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transforms下的ajx中内容.png"></p>
<p>ajx目录下还会有一个名为<code>__content__</code>的.json文件。该文件中展示了ajx中文件目录下的内容</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-7e4d4360b0ffb331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其实当你注入一个自定义的Transform的时候还会生成对应的Task，即TransformTask，该Task还会有一个对应的名称，例如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-a422dfd4590b410f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TransformTask名称.png"></p>
<p>这个名称生成过程是在 TransformManager 的 <code>addTransform()</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Transform&gt; Optional&lt;TransformTask&gt; addTransform(</span><br><span class="line">            @NonNull TaskFactory taskFactory,</span><br><span class="line">            @NonNull TransformVariantScope scope,</span><br><span class="line">            @NonNull T transform,</span><br><span class="line">            @Nullable TransformTask.ConfigActionCallback&lt;T&gt; callback) &#123;</span><br><span class="line">...</span><br><span class="line">        String taskName = scope.getTaskName(getTaskNamePrefix(transform));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static String getTaskNamePrefix(@NonNull Transform transform) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder(100);</span><br><span class="line">    sb.append(&quot;transform&quot;);</span><br><span class="line"></span><br><span class="line">    sb.append(</span><br><span class="line">            transform</span><br><span class="line">                    .getInputTypes()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(</span><br><span class="line">                            inputType -&gt;</span><br><span class="line">                                    CaseFormat.UPPER_UNDERSCORE.to(</span><br><span class="line">                                            CaseFormat.UPPER_CAMEL, inputType.name()))</span><br><span class="line">                    .sorted() // Keep the order stable.</span><br><span class="line">                    .collect(Collectors.joining(&quot;And&quot;)));</span><br><span class="line">    sb.append(&quot;With&quot;);</span><br><span class="line">    StringHelper.appendCapitalized(sb, transform.getName());</span><br><span class="line">    sb.append(&quot;For&quot;);</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Transform中，其<code>transform()</code> 方法是重头戏，需要对输入的文件进行处理，然后放到输出目录中。</p>
<p>例如，我在<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>中就是自定义一个Transform子类，然后在transform过程把输入的目录中的.class文件或者jar包中的.class 文件使用aspectj进行处理。如果对aspectj不太了解的，可以查看我之前写的一篇文章：<a href="https://www.jianshu.com/p/c66f4e3113b3" target="_blank" rel="noopener">AOP开发——AspectJ的使用</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">    TransformTask transformTask = (TransformTask) transformInvocation.context</span><br><span class="line">    //VariantCache 就是保存一些跟当前variant相关的一些缓存，以及在支持增量编译的情况下存储一些信息</span><br><span class="line">    VariantCache variantCache = new VariantCache(ajxProcedure.project, ajxProcedure.ajxCache, transformTask.variantName)</span><br><span class="line"></span><br><span class="line">    if (transformInvocation.isIncremental()) &#123;</span><br><span class="line">        //TODO 增量</span><br><span class="line">        print(&quot;====================增量编译=================&quot;)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        print(&quot;====================非增量编译=================&quot;)</span><br><span class="line">        //非增量,需要删除输出目录</span><br><span class="line">        transformInvocation.outputProvider.deleteAll()</span><br><span class="line">        variantCache.reset()</span><br><span class="line"></span><br><span class="line">        AJXFileProcess ajxFileProcess = new AJXFileProcess(project, variantCache, transformInvocation)</span><br><span class="line">        ajxFileProcess.proceed()</span><br><span class="line">        AJXTaskProcess ajxTaskProcess = new AJXTaskProcess(project, variantCache, transformInvocation)</span><br><span class="line">        ajxTaskProcess.proceed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Transform中的transform-方法是如何被执行的"><a href="#Transform中的transform-方法是如何被执行的" class="headerlink" title="Transform中的transform()方法是如何被执行的"></a>Transform中的transform()方法是如何被执行的</h1><p>我们在前面讲到的调用<code>android.registerTransform(transform)</code>注册方法，实际上只是把Transform对象放到了一个List集合中。那么什么时候用到这个集合呢？也就是说Transform的transform()方法是什么时候被执行的呢？</p>
<p>在这里可以先告诉你答案，Transform的transform()方法是在TransformTask的transform()方法中执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># com.android.build.gradle.internal.pipeline.TransformTask</span><br><span class="line">@TaskAction</span><br><span class="line">void transform(final IncrementalTaskInputs incrementalTaskInputs)</span><br><span class="line">        throws IOException, TransformException, InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    recorder.record(</span><br><span class="line">            ExecutionType.TASK_TRANSFORM,</span><br><span class="line">            executionInfo,</span><br><span class="line">            getProject().getPath(),</span><br><span class="line">            getVariantName(),</span><br><span class="line">            new Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Void call() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">                    transform.transform(</span><br><span class="line">                            new TransformInvocationBuilder(TransformTask.this)</span><br><span class="line">                                    .addInputs(consumedInputs.getValue())</span><br><span class="line">                                    .addReferencedInputs(referencedInputs.getValue())</span><br><span class="line">                                    .addSecondaryInputs(changedSecondaryInputs.getValue())</span><br><span class="line">                                    .addOutputProvider(</span><br><span class="line">                                            outputStream != null</span><br><span class="line">                                                    ? outputStream.asOutput()</span><br><span class="line">                                                    : null)</span><br><span class="line">                                    .setIncrementalMode(isIncremental.getValue())</span><br><span class="line">                                    .build());</span><br><span class="line"></span><br><span class="line">                    if (outputStream != null) &#123;</span><br><span class="line">                        outputStream.save();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上每个Transform都会有一个对应的TransformTask，TransformTask本质上就是表示Gradle中的一个Task，那么一个Task在执行的时候其<code>@TaskAction</code>注解的方法会被执行，也就是<code>com.android.build.gradle.internal.pipeline.TransformTask#transform()</code>方法会被执行，在该方法中会调用该TransformTask对应的Transform对象的transform()方法。</p>
<p>写过Gradle插件的都知道，在build.gradle中apply 插件后其apply(project)方法就会调用。例如我们在一个app中应用的是<code>apply plugin: &#39;com.andorid.application&#39;</code> ，这个实际上引入的就是AppPlugin，其apply()方法会被调用。关于这个源码过程我们就不多说了，我们只讲一个这个过程，感兴趣的可以查看文章末尾的相关文章。</p>
<p>-&gt;com.android.build.gradle.BasePlugin#apply()<br>-&gt;com.android.build.gradle.BasePlugin#createTasks()<br>-&gt;com.android.build.gradle.BasePlugin#createAndroidTasks()<br>-&gt;com.android.build.gradle.internal.VariantManager#createAndroidTasks()<br>-&gt;com.android.build.gradle.internal.VariantManager#createTasksForVariantData()<br>-&gt;com.android.build.gradle.internal.ApplicationTaskManager#createTasksForVariantScope() <strong>//该方法中干的事很多，可以重点关注</strong><br>-&gt;com.android.build.gradle.internal.ApplicationTaskManager#addCompileTask()<br>-&gt;com.android.build.gradle.internal.TaskManager#createPostCompilationTasks() <strong>//在这个方法中会调用AppExtension的getTransforms()方法，也就是我们之前注册的transform</strong><br>-&gt; com.android.build.gradle.internal.pipeline.TransformManager#addTransform() <strong>//在这个方法中创建了TransformTask</strong></p>
<p>在上面的这些流程中TaskManager的<strong>createPostCompilationTasks()</strong>需要重点关注，在该方法中对Apk打包过程中的各种Transform进行处理，创建对应了TransformTask并构建隐式的依赖关系。</p>
<p>到此TransformTask是创建完毕，TransformTask相当于是对我们自定义的Transform进行的包装。</p>
<p>那么这个TransformTask是什么时候执行呢？<br>我们可以显式地使用Gradle命令去执行一个Task，这是没问题的。但为什么我们执行<code>gradle assemble</code>命令的时候，TransformTask也会执行呢？这个就牵涉到Task的依赖关系了。假设TaskA依赖TaskB，那么如果我们要执行TaskA，那么在TaskA执行之前TaskB就会执行。但是要注意一点就是，假设TaskA依赖TaskB和TaskC，那么只能保证TaskA执行之前TaskB和TaskC都执行了，并不能保证TaskB和TaskC的执行顺序。</p>
<p>构建Task的依赖关系可以显式的调用其 <code>dependsOn()</code> 方法。 但是我在查看Transform API的过程中发现这个TransformTask之间并没有显式地调用<code>dependsOn()</code> 方法来保证依赖关系，难道这个TransformTask的执行顺序是任意的吗？如果是任意的，比如一个task是dexMerger是要把每个class编译成的dex合成为一个dex，而此时输入目录中还没有dex存在，该任务不就失败了吗？android gradle plugin 的开发者当然不会让这种情况存在了。</p>
<p>实际情况是Task除了显式地通过dependsOn来指定Task依赖，其实还可以<strong>使用Task依赖推断来判断依赖关系，Gradle通过使用一个Task的输出作为另一个Task的输入，就可以推断出依赖关系。</strong><br>在Transform API中，使用的是 TransformStream 来连接TransformTask的依赖关系，进行可以控制Transform的执行顺序。<br>计算TransformTask的输入输出是在 TransformManager 的 addTransform() 方法中。<br>通过输入输出已经隐式地确定了TransformTask的依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line">public &lt;T extends Transform&gt; Optional&lt;TransformTask&gt; addTransform(</span><br><span class="line">        @NonNull TaskFactory taskFactory,</span><br><span class="line">        @NonNull TransformVariantScope scope,</span><br><span class="line">        @NonNull T transform,</span><br><span class="line">        @Nullable TransformTask.ConfigActionCallback&lt;T&gt; callback) &#123;</span><br><span class="line">...</span><br><span class="line">    List&lt;TransformStream&gt; inputStreams = Lists.newArrayList();</span><br><span class="line">    String taskName = scope.getTaskName(getTaskNamePrefix(transform));</span><br><span class="line"></span><br><span class="line">    // get referenced-only streams</span><br><span class="line">    List&lt;TransformStream&gt; referencedStreams = grabReferencedStreams(transform);</span><br><span class="line"></span><br><span class="line">    // find input streams, and compute output streams for the transform.</span><br><span class="line">    // 通过之前添加的Transform来计算输入，并计算输出</span><br><span class="line">    IntermediateStream outputStream = findTransformStreams(</span><br><span class="line">            transform,</span><br><span class="line">            scope,</span><br><span class="line">            inputStreams,</span><br><span class="line">            taskName,</span><br><span class="line">            scope.getGlobalScope().getBuildDir());</span><br><span class="line">   ...</span><br><span class="line">    transforms.add(transform);</span><br><span class="line"></span><br><span class="line">    // create the task...</span><br><span class="line">    // 在创建Task的过程中传入了输入和输出，上一个Task的输出是该Task的输入，这就保证了Task的一个隐式的依赖关系</span><br><span class="line">    TransformTask task =</span><br><span class="line">            taskFactory.create(</span><br><span class="line">                    new TransformTask.ConfigAction&lt;&gt;(</span><br><span class="line">                            scope.getFullVariantName(),</span><br><span class="line">                            taskName,</span><br><span class="line">                            transform,</span><br><span class="line">                            inputStreams,</span><br><span class="line">                            referencedStreams,</span><br><span class="line">                            outputStream,</span><br><span class="line">                            recorder,</span><br><span class="line">                            callback));</span><br><span class="line"></span><br><span class="line">    return Optional.ofNullable(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以通过以上分析也可以当我们自定义Plugin要注入多个Transform的时候，按照添加顺序来保证依赖关系，先添加的Transform先执行。对于下面的例子，transformA的<code>transform()</code>方法会先于transformB执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.registerTransform(transformA);</span><br><span class="line">android.registerTransform(transformB);</span><br></pre></td></tr></table></figure></p>
<h1 id="Android-Gradle-Plugin中的Transform子类"><a href="#Android-Gradle-Plugin中的Transform子类" class="headerlink" title="Android Gradle Plugin中的Transform子类"></a>Android Gradle Plugin中的Transform子类</h1><p>Android Gradle Plugin中有多个Transform子类，在编写自己的Transform类的时候可以作为一个参考。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-f076900e17578724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transform子类.png"></p>
<p>可以在图中看到，Google已经在使用kotlin写Gradle插件了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自定义Transform并注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TransformPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        project.android.registerTransform(new ClassTransform(project))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassTransform extends Transform &#123;</span><br></pre></td></tr></table></figure>
<p>Transform API的执行有顺序，每一个Transform都对应一个TransformTask和TransformStream，通过输入输出隐式的构成Task依赖关系。开发者自定义的Transform按照注册顺序执行。</p>
<h1 id="补充——源码调试"><a href="#补充——源码调试" class="headerlink" title="补充——源码调试"></a>补充——源码调试</h1><p>在之前的一篇文章<a href="https://www.jianshu.com/p/b86330a877db" target="_blank" rel="noopener">启用Gradle远程调试</a>中介绍了如何调试Gradle插件，实际上使用该方式也可以用来调试查看Android Gradle Plugin的执行流程。这个时候最好要找到有能下载到源码的版本，比如3.1.2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line"> ...</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.1.2&apos;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是App或者Library插件对应的类的继承关系图<br><img src="https://upload-images.jianshu.io/upload_images/2083810-96bd7e87a558f504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你想要调试app打包过程，可以在 AppPlugin 的 <code>apply()</code> 方法中打断点。它直接调用了其父类 BasePlugin 的 <code>apply()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#com.android.build.gradle.AppPlugin</span><br><span class="line">@Override</span><br><span class="line">public void apply(@NonNull Project project) &#123;</span><br><span class="line">    super.apply(project);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul>
<li><a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">‎New Build System‎:Transform API</a></li>
<li><a href="https://www.jianshu.com/p/37df81365edf" target="_blank" rel="noopener">如何理解 Transform API</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492752&amp;idx=1&amp;sn=1d1ad65c63667d96b72452a492cbde58" target="_blank" rel="noopener">Android Gradle Plugin 源码解析（上）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492778&amp;idx=1&amp;sn=bf18cd9b7e4fb5f08b1a698836807304" target="_blank" rel="noopener">Android Gradle Plugin 源码解析（下）</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/AOP开发——AspectJ的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/AOP开发——AspectJ的使用/" itemprop="url">AOP开发——AspectJ的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T18:07:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>文章对应的项目地址<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>，运行一下sample，结合代码和文章，你会收获更多。</p>
</blockquote>
<p>熟悉程序开发的都知道OOP（Object Oriented Programming ，面向对象编程），把功能封装在一个类中，使用的时候创建该类的对象，调用对象的方法或者使用其属性即可，OOP具有可重用性、灵活性和扩展性。</p>
<p>尽管OOP具有很多好处，但是如果在软件开发领域只使用OOP，在某些情况下也会使程序变得复杂且难以维护。例如，我们需要统计程序中点击事件的执行情况，如果我们要自己找遍代码中的点击事件，这个工程量就太大了，而且维护起来也不方便。这个时候，使用AOP的方式就会使问题变得简单。<br>AOP（Aspect Oriented Programming，面向切面编程），把某一类问题集中在一个地方进行处理，比如处理程序中的点击事件、打印日志等。</p>
<p>关于OOP和AOP，我觉得邓凡平老师在<a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a>中说的挺对的：</p>
<blockquote>
<p>OOP和AOP都是方法论，表示的是我们从什么角度来看待问题。OOP的精髓是把功能或问题模块化，每个模块处理自己的家务事。但在现实世界中，并不是所有功能都能完美得划分到模块中。AOP的目标是把这些功能集中起来，放到一个统一的地方来控制和管理。</p>
</blockquote>
<p>那么在Android中有哪些使用到了AOP这种思想呢？<br>在Application中有个ActivityLifecycleCallbacks接口，这个接口提供了Activity生命周期相关的方法回调。当开发者调用了Application的<code>public void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback)</code> 方法之后，就可以在ActivityLifecycleCallbacks的实现类中统一处理这些生命周期方法。这其实就是AOP思想的一种体现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-5c897416cf40e7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityLifecycleCallbacks的AOP思想.png"></p>
<p>另外，我们今天的主角——AspectJ， 它是AOP编程思想的一个很火的实践。</p>
<h1 id="AspectJ-介绍"><a href="#AspectJ-介绍" class="headerlink" title="AspectJ 介绍"></a>AspectJ 介绍</h1><p>AspectJ是一个面向切面编程的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。AspectJ还支持原生的Java，只需要加上AspectJ提供的注解即可。在Android开发中，一般就用它提供的注解和一些简单的语法就可以实现绝大部分功能上的需求了。</p>
<p><strong>Join Points介绍</strong></p>
<p>Join Points，简称JPoints，是AspectJ中最关键的一个概念，表示的是程序运行时的一些<strong>执行点</strong>。理论上说，一个程序中很多地方都可以被看做是JPoint，但是AspectJ中，只有几种执行点被认为是JPoints，如构造方法调用、方法调用、方法执行、异常等等。JPoints实际上就是表示想把AspectJ的代码插入到程序哪个地方，是插入在方法中，还是插入在方法调用前后。需要说明的是：在AspectJ中，方法调用（call）和方法执行（execution）是不一样的，这个后面再做介绍。</p>
<p><strong>Pointcuts介绍</strong></p>
<p>一个程序会有很多的JPoints，即使是同一个函数，还分为call类型和execution类型的JPoint，但是并不是所有的JPoint都是我们需要关心的。比如我们可能只需要关心点击事件方法，那么如何从众多的JPoints中选择我们感兴趣的JPoint呢？这个时候可以用Pointcut：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void onClickMethodAround(ProceedingJoinPoint joinPoint)  &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的意思就是在OnClickListener.onClick()方法执行前后执行代码块中的逻辑。</p>
<p>所以在这里，我们可以简单的理解Pointcut的作用就是过滤JPoint。</p>
<p><strong>Advice介绍</strong></p>
<p>Advice简单来说就是表示AspectJ的hook点，在AspectJ中常用的是before、after、around等。before表示在JPoint执行之前，需要干的事情。after表示的是在JPoint执行之后，around表示的是在JPoint执行前后。</p>
<p><strong>Aspect介绍</strong></p>
<p>前面我们讲了AspectJ中使用过程中需要用到了一个概念，对于问题的处理需要统一放到一个地方去处理，这个地方就是Aspect，意为“切面”。在Java开发中主要是使用@Aspect注解来表示一个切面。</p>
<h1 id="Android-中使用Gradle集成-AspectJ"><a href="#Android-中使用Gradle集成-AspectJ" class="headerlink" title="Android 中使用Gradle集成 AspectJ"></a>Android 中使用Gradle集成 AspectJ</h1><p>在Android中集成AspectJ，主要思想就是hook Apk打包过程，使用AspectJ提供的工具来编译.class文件。这一点，JakeWharton 在其项目<a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">JakeWharton/hugo</a> 中演示了如何在Gradle中添加AspectJ，这为后来的人指了一条光明的道路。</p>
<p>一般来说，自己手动接入AspectJ的话，按照下面的指示即可。</p>
<p>在项目根目录build.gradle下引入aspectjtools插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ..</span><br><span class="line">        classpath &apos;org.aspectj:aspectjtools:1.8.10&apos;</span><br><span class="line">        classpath &apos;org.aspectj:aspectjweaver:1.8.8&apos;</span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行app的module目录下的build.gradle中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.bridge.IMessage</span><br><span class="line">import org.aspectj.bridge.MessageHandler</span><br><span class="line">import org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line">final def log = project.logger</span><br><span class="line">final def variants = project.android.applicationVariants</span><br><span class="line"></span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    if (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(&quot;Skipping non-debuggable build type &apos;$&#123;variant.buildType.name&#125;&apos;.&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">        String[] args = [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                         &quot;-1.8&quot;,</span><br><span class="line">                         &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-bootclasspath&quot;, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug &quot;ajc args: &quot; + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = new MessageHandler(true);</span><br><span class="line">        new Main().run(args, handler);</span><br><span class="line">        for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">            switch (message.getKind()) &#123;</span><br><span class="line">                case IMessage.ABORT:</span><br><span class="line">                case IMessage.ERROR:</span><br><span class="line">                case IMessage.FAIL:</span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.WARNING:</span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.INFO:</span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.DEBUG:</span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AspectJ在运行时也需要相关的Library支持，所以还需要在项目的dependencies中添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   ...</span><br><span class="line">  compile &apos;org.aspectj:aspectjrt:1.8.10&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前还有一些在Android中集成AspectJ的比较火的框架，如 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">HujiangTechnology / gradle_plugin_android_aspectjx</a>。该框架支持kotlin，我对这个框架深入研究了一番，也按照它的思想写了一个简单的gradle plugin ，收获颇多，我自己的项目地址是 <a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>，项目中演示了如何通过AOP的方式解决统一处理登录、绑定手机号、统计方法耗时、打印点击事件日志等的逻辑，有兴趣的可以去看看，欢迎交流。</p>
<h1 id="AspectJ-命令常用参数介绍"><a href="#AspectJ-命令常用参数介绍" class="headerlink" title="AspectJ 命令常用参数介绍"></a>AspectJ 命令常用参数介绍</h1><p>1 <strong>-inpath:</strong> .class文件路径，可以是在jar文件中也可以是在文件目录中，路径应该包含那些AspectJ相关的文件，只有这些文件才会被AspectJ处理。输出文件会包含这些.class 。该路径就是一个单一参数，多个路径的话用分隔符隔开。</p>
<p>2 <strong>-classpath:</strong> 指定去哪找用户使用到的.class文件，路径可以是zip文件也可以是文件目录，该路径就是一个单一参数，多个路径的话用分隔符隔开。</p>
<p>3 <strong>-aspectPath:</strong> 需要被处理的切面路径，存在于jar文件或者文件目录中。在Andorid中使用的话一般指的是被@Aspect注解标示的class文件路径。需要注意的是编译版本需要与Java编译版本一致。classpath指定的路径应该包含所有的aspectpath指定的.class文件。不过默认情况下，inPath和aspectPath中的路径不一定非要放置在classPath中，因为编译器会自动处理把它们加入。路径格式与classpath和inpath样，都需要用分隔符隔开。</p>
<p>4 <strong>-bootClasspath: </strong> 重载跟VM相关的bootClasspath，例如在Android中使用android-27的源码进行编译。路径格式与之前一样。</p>
<p>5 <strong>-d:</strong>  指定由AspectJ处理后的.class文件存放目录，如果不指定的话会放置在当前的工作目录中。</p>
<p>6 <strong>-outjar:</strong> 指定被AspectJ处理后的jar包存放的文件目录，</p>
<p>更多详情请查看<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">官网</a> <a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html</a></p>
<h1 id="Sample—处理点击事件"><a href="#Sample—处理点击事件" class="headerlink" title="Sample—处理点击事件"></a>Sample—处理点击事件</h1><p>例如，我们需要处理项目中的所有控件的点击事件，打印控件的名称，可以使用AspectJ来简单方便的处理。在之前已经在gradle中引入的AspectJ的基础上，我们新建一个Java文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class ClickAspect &#123;</span><br><span class="line">    private static final String TAG = &quot;ClickAspect&quot;;</span><br><span class="line">    // 第一个*所在的位置表示的是返回值，*表示的是任意的返回值，</span><br><span class="line">    // onClick()中的 .. 所在位置是方法参数的位置，.. 表示的是任意类型、任意个数的参数</span><br><span class="line">    // * 表示的是通配</span><br><span class="line">    @Pointcut(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">    public void clickMethod() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;clickMethod()&quot;)</span><br><span class="line">    public void onClickMethodAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        View view = null;</span><br><span class="line">        for (Object arg : args) &#123;</span><br><span class="line">            if (arg instanceof View) &#123;</span><br><span class="line">                view = (View) arg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取View 的 string id</span><br><span class="line">        String resEntryName = null;</span><br><span class="line">        String resName = null;</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            // resEntryName: btn_activity_2  resName: com.sososeen09.aop_tech:id/btn_activity_2</span><br><span class="line">            resEntryName = view.getContext().getResources().getResourceEntryName(view.getId());</span><br><span class="line">            resName = view.getContext().getResources().getResourceName(view.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        Log.d(TAG, &quot;after onclick: &quot; + &quot;resEntryName: &quot; + resEntryName + &quot;  resName: &quot; + resName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行项目，点击一个控件（设置了点击事件）之后，可以看到日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./com.sososeen09.aop_tech D/ClickAspect: after onclick: resEntryName: btn_activity_3 resName: com.sososeen09.aop_tech:id/btn_activity_3</span><br></pre></td></tr></table></figure>
<h1 id="切入点的语法"><a href="#切入点的语法" class="headerlink" title="切入点的语法"></a>切入点的语法</h1><p>以上面的例子来讲解：</p>
<ul>
<li>@Around：是advice，也就是具体的插入点。@Around该方法的逻辑会包含切入点前后，如果用到该注解，记得自己需要控制切入点的执行逻辑，调用<code>joinPoint.proceed()</code>。如果使用@Before注解，表示的是在切入点之前执行，@After表示在切入点之后执行，此时不需要调用<code>joinPoint.proceed()</code>。</li>
<li>execution：处理JPoint的类型，例如call、execution。对于<code>execution(* android.view.View.OnClickListener.onClick(..))</code>，第一个 <code>*</code> 所处的位置表示的是返回值，<code>*</code> 是通配符，表示的是任意类型。 <code>android.view.View.OnClickListener.onClick(..)</code> 表示的执行OnClickListener的onClick()方法。<code>onClick(..)</code>中的<code>..</code> 表示任意类型、任意个数的参数。</li>
<li>onClickMethodAround：表示的实际切入代码。这个方法名可以自己随意定义。</li>
</ul>
<p>在上面的例子中实际上我是自定义了一个PointCut，名字是<code>clickMethod()</code>。这个名称随意，只要在advice中指定好该名称就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void clickMethod() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想自定义，可以直接这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void onClickMethodAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="call和execution"><a href="#call和execution" class="headerlink" title="call和execution"></a>call和execution</h1><p>我们之前讲的切入点语法都是execution，那么如果使用call有什么区别呢？</p>
<p>我们再使用一个例子，创建一个切面用来打印方法的执行时间，并且只处理带有注解的参数。<br>TimeSpend 注册如下，value表示的是方法的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface TimeSpend &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用execution打印方法执行时间的切面如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MethodSpendTimeAspect &#123;</span><br><span class="line">    private static final String TAG = &quot;MethodSpendTimeAspect&quot;;</span><br><span class="line">    @Pointcut(&quot;execution(@com.sososeen09.aop_tech.aspect.TimeSpend * *(..))&quot;)</span><br><span class="line">    public void methodTime() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;methodTime()&quot;)</span><br><span class="line">    public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">        String methodName = methodSignature.getName();</span><br><span class="line">        String funName = methodSignature.getMethod().getAnnotation(TimeSpend.class).value();</span><br><span class="line">        //统计时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        long duration = System.currentTimeMillis() - begin;</span><br><span class="line">        Log.e(TAG, String.format(&quot;功能：%s,%s类的%s方法执行了，用时%d ms&quot;, funName, className, methodName, duration));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始Java文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">   ...</span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        StatusHolder.sHasLogin = true;</span><br><span class="line">        Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后的.class文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">...</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mEmailSignInButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                LoginActivity.this.attemptLogin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        JoinPoint var1 = Factory.makeJP(ajc$tjp_0, this, this);</span><br><span class="line">        attemptLogin_aroundBody1$advice(this, var1, MethodSpendTimeAspect.aspectOf(), (ProceedingJoinPoint)var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ajc$preClinit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把execution该为call，在看一下编译后的 .class 文件 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">        mEmailSignInButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                LoginActivity.access$000(com.sososeen09.aop_tech.LoginActivity.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        StatusHolder.sHasLogin = true;</span><br><span class="line">        Toast.makeText(this, &quot;登录成功&quot;, 0).show();</span><br><span class="line">        this.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ajc$preClinit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void access$000(LoginActivity x0) &#123;</span><br><span class="line">        JoinPoint makeJP = Factory.makeJP(ajc$tjp_0, null, x0);</span><br><span class="line">        attemptLogin_aroundBody1$advice(x0, makeJP, MethodSpendTimeAspect.aspectOf(), (ProceedingJoinPoint) makeJP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到区别了吧，execution表示JPoint是执行方法的地方，AspectJ会对被执行方法做处理。而call表示JPoint是调用方法的地方，AspectJ会对调用处做处理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了AOP的一些概念性的知识，简单介绍了AspectJ在Android开发中的基本使用方式。限于篇幅和水平，难以对AspectJ做一个全面的介绍，建议对AOP和AspectJ有兴趣的读者可以阅读下面的相关项目和文章，也欢迎交流。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><ul>
<li><a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a></li>
<li><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">HujiangTechnology / gradle_plugin_android_aspectjx</a></li>
<li><a href="https://github.com/north2016/T-MVP" target="_blank" rel="noopener">north2016 / T-MVP</a></li>
<li><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">JakeWharton/hugo</a></li>
<li><a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a></li>
<li><a href="https://www.jianshu.com/p/dca3e2c8608a" target="_blank" rel="noopener">安卓AOP三剑客:APT,AspectJ,Javassist</a></li>
<li><a href="http://www.goluck.top/2017/06/11/AspectJ%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">AspectJ在Android中的应用</a></li>
<li><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">devguide:ajc-ref</a></li>
<li><a href="https://juejin.im/post/587989f48d6d810058bbae01" target="_blank" rel="noopener">看 AspectJ 在 Android 中的强势插入</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/22/启用Gradle远程调试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/启用Gradle远程调试/" itemprop="url">启用Gradle远程调试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T19:33:00+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">Gradle学习10——自定义Gradle插件</a> 这篇文章中介绍了编写插件的几种方式。<br>编写gradle对象插件的实现方式有3种：</p>
<ol>
<li>直接写在build.gradle中，这种方式简单省事，比较适合比较小的插件编写</li>
<li>在项目根目录下建立buildSrc目录</li>
<li>建立一个独立的项目工程，以jar包的形式提供依赖</li>
</ol>
<p>在编写对象插件的过程中很多都需要进行调试，本文就介绍一下如何启动gradle远程调试。</p>
<h1 id="启动远程调用"><a href="#启动远程调用" class="headerlink" title="启动远程调用"></a>启动远程调用</h1><p>首先点击Run-&gt; Edit Configuration</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-309994bfec6c2b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Edit Configuration.png"></p>
<p>然后点击+号，Add New Configutation，我们选择Remote</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-1e7fc863d0f76c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add New Configutation.png"></p>
<p>我们新建一个命名为apt-debug的remote，并且复制Command Line对应下的这段语句，当然了，我们在这里实际上也可以更改端口号的。也可以用当前默认的端口号5005。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-d16f55b9ea665a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Remote.png"></p>
<p>然后点击Android Studio右侧的gradle选项</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-36570d19faa3bb43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle.png"></p>
<p>假如我们要选择app模块进行调试，可以在build下的assembleRelease任何下，右击，会有一个弹出窗口。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-4cd1b97e990d5896.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="assembleRelease.png"></p>
<p>我们点击Create 选项。会有如下窗口：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-daffe4fd205fb632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Create.png"></p>
<p>在VM options下填入我们刚才复制的信息，要注意的是把<strong>suspend对应的值改为y</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-ab6b6f3806863c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VM options.png"></p>
<p>然后会生成一个Run Condigurations的Task group。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-6fb0774ab28686b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Run Condigurations.png"></p>
<p>双击这个assembleRelease的调试任务，这个这个任务就会被挂起，等待着调式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-5705867a0ef0654c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="等待着调式.png"></p>
<p>然后我们选择apt-debug，在点击右侧的debug按钮，就可以开始调试了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-75c8ba6c0e73ede0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击右侧的debug按钮.png"></p>
<h1 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h1><p>debug 模式运行 gradle 脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle :app:clean -Dorg.gradle.debug=true  --no-daemon</span><br></pre></td></tr></table></figure>
<p>声明环境变量 GRADLE_OPTS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GRADLE_OPTS=&quot;-Xdebug - Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot;</span><br></pre></td></tr></table></figure>
<p>attach Debugger</p>
<p>记住，如果想继续调试，就以Debug方式再次运行我们在Run Configuration下生成的assembleDebug或者assembleRelease。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-bd21efd5939c5ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再次debug.png"></p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul>
<li><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">又掌握了一项新技能 - 断点调试 Gradle 插件</a></li>
<li><a href="https://developer.android.com/studio/run/rundebugconfig.html?hl=zh-cn" target="_blank" rel="noopener">创建和编辑运行/调试配置</a></li>
<li><a href="https://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">Gradle学习10——自定义Gradle插件</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/14/Apk文件构建流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/Apk文件构建流程/" itemprop="url">Apk文件构建流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T16:45:00+08:00">
                2018-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>阅读本文的时候，配合demo进行演示，效果更佳哦~<br>项目地址：<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a></p>
</blockquote>
<p>现在绝大部分人应该是使用Android Studio进行app的开发，通常我们运行一个app，直接点击 <code>run</code> 按钮或者使用gradle 命令 <code>./gradlew assembleDebug</code> 等就可以构建出一个apk文件，那么这个apk文件到底是怎么生成的呢？</p>
<p>本文通过命令行工具构建一个完整的app，来演示app的打包过程，借此来了解一下app的构建流程。由于网上已经有很多相关的文章，本文不会对基本的打包流程做过多详细的分析，有兴趣的读者可以查看文末的相关文章。</p>
<h1 id="基本的打包流程"><a href="#基本的打包流程" class="headerlink" title="基本的打包流程"></a>基本的打包流程</h1><p>首先来一张Android官网比较经典的打包流程图，这张图比较早了，但是依然具有指导意义。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-f699764e629cd8da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apk打包流程.png"></p>
<p>从这张图上看，构建一个基本的app，主要需要经历7个过程</p>
<ol>
<li><p>java文件生成过程，</p>
<ul>
<li>通过aapt工具生成R.java文件，输入文件是res目录下的文件和AndroidManifest.xml文件</li>
<li>通过aidl工具把.aidl文件生成java文件</li>
<li><p>其实还有apt的方式生成java文件<br>使用<code>android gradle plugin</code> 打包，在build/generated目录下存放的就是这些生成的java文件。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-8c096ab632984fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java generated.png"></p>
<p>aapt工具存放在/android-sdk/build-tools/$version/ 目录下。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-5976b83696dbde73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aapt存放目录"></p>
</li>
</ul>
</li>
<li><p>通过aapt工具来生成生成资源索引文件，一般来说生成的文件名是resources.ap<em>，使用<code>android gradle plugin</code> 打包，这个文件命名一般是 `resources</em>${buildVariant}.ap_`，例如<br><img src="https://upload-images.jianshu.io/upload_images/2083810-e3125b22ec2985a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源索引文件.png"></p>
</li>
<li><p>使用javac命令编译java文件<br>就是使用jdk中的javac工具，做java开发的应该都知道怎么使用。</p>
</li>
<li><p>通过dx工具生成dex文件，dx工具与aapt存放目录一致。</p>
</li>
<li><p>通过apkbuilder打包apk，可以在/android-sdk/tools/lib目录下找到sdklib.jar，执行其 com.android.sdklib.build.ApkBuilderMain的main方法<br><img src="https://upload-images.jianshu.io/upload_images/2083810-c99a4d5484f4fd85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdklib.jar.png"></p>
</li>
<li><p>签名，可以使用jarsigner工具签名和apksigner工具签名。jarsigner是Java本生自带的一个工具，他可以对jar进行签名的。而apksigner是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样。jarsigner工具签名时使用的是keystore文件，apksigner工具签名时使用的是pk8,x509.pem文件。<br>想要了解更多内容可以查看一位大神的文章<a href="https://blog.csdn.net/jiangwei0910410003/article/details/50402000" target="_blank" rel="noopener">Android签名机制之—签名过程详解</a></p>
</li>
<li>zipaligin，它位于/android-sdk/build-tools/$build-tools-version 目录，是一个zip文件整理工具用来优化apk文件。它的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时速度会更快。</li>
</ol>
<blockquote>
<p>注意：关于apk签名和zipaligin这块，如果使用不同的工具签名，zipaligin和签名的顺序是不一致的。例如，如果使用apksigner，那么zipaligin就必须是在签名之前进行。如果使用jarsigner，zipaligin就必须是在签名之后进行。具体可查看官网介绍：<a href="https://developer.android.google.cn/studio/command-line/apksigner" target="_blank" rel="noopener">https://developer.android.google.cn/studio/command-line/apksigner</a></p>
</blockquote>
<h1 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h1><p>在<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a>中，分别通过shell脚本和gradle打包的方式来演示构建apk的过程。同时，为了增加一些知识点，demo中演示了通过类加载机制实现代码热修复的一个基本过程。</p>
<p>例如，有如下代码，被除数为0，对于一个已经安装的apk，执行divide()方法肯定会crash。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//修复前</span><br><span class="line">public class SimpleMathUtils &#123;</span><br><span class="line">	public static String divide()&#123;</span><br><span class="line">		int a=10/0;</span><br><span class="line">		return &quot;the divide result is  &quot;+a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修复后</span><br><span class="line">public class SimpleMathUtils &#123;</span><br><span class="line">	public static String divide()&#123;</span><br><span class="line">		int a=10/1;</span><br><span class="line">		return &quot;the divide result is  &quot;+a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改代码后，把被除数改为1，通过javac命令生成class文件，然后再通过dex命令把class文件生成为dex文件，名称为fixed.dex。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding UTF-8 -g -target 1.7 -source 1.7 -d bin src/main/java/com/sososeen09/multidexbuild/SimpleMathUtils.java</span><br><span class="line">cd bin</span><br><span class="line">dx --dex --output=fixed.dex com/sososeen09/multidexbuild/SimpleMathUtils.class</span><br></pre></td></tr></table></figure>
<p>简单起见，我把修复好的dex文件存放在一个目录中了<br><img src="https://upload-images.jianshu.io/upload_images/2083810-647dff1b7f55c817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要被打包进apk中的文件.png"></p>
<p>打包的时候把assets目录中的内容复制到apk文件中对应的assets目录下。</p>
<p>整个构建前后的文件目录是这样的，bin目录下是构建过程中的产物，gen目录下是生成的R.java文件。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-f2155149561bb281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建前后的文件目录.png"></p>
<p>把打包后的apk文件拖入到AS中，可以看到assets目录中的内容已经复制到apk中了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-ee481e4eb0a9527d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打包后的apk文件.png"></p>
<p>运行效果图，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-2206e15b531b845e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行效果图..png"></p>
<p>直接点击getResult按钮会crash，因为 <code>10/0</code>，运行期肯定会报错。点击fix 按钮之后通过热修复的方式把代码做了更改，把代码中的 <code>10/0</code> 改成了 <code>10/1</code>，然后再点击 getResult 按钮的时候就没问题了。</p>
<p>相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void fix(View view) &#123;</span><br><span class="line">    tvFix.setText(&quot;fixing...&quot;);</span><br><span class="line">    File originDex = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        originDex = copyFileFromAssets(&quot;fixed.dex&quot;, getCacheDir().getAbsolutePath());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Toast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (originDex != null) &#123;</span><br><span class="line">        File dexOptimizeDir = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);</span><br><span class="line">        String dexOutputPath = dexOptimizeDir.getAbsolutePath();</span><br><span class="line">        PathClassLoader pathClassLoader = (PathClassLoader) getClassLoader();</span><br><span class="line">        DexClassLoader dexClassLoader = new DexClassLoader(originDex.getAbsolutePath(), dexOutputPath, null,</span><br><span class="line">                pathClassLoader);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取DexClassLoader对象的pathList对象，DexPathList</span><br><span class="line">            Object dexPathListWithDexClassLoader = ReflectUtils.findField(dexClassLoader, &quot;pathList&quot;).get(dexClassLoader);</span><br><span class="line"></span><br><span class="line">            // 获取DexPathList对象Element[]数组，对应的字段名是dexElements</span><br><span class="line">            Field dexElements = ReflectUtils.findField(dexPathListWithDexClassLoader, &quot;dexElements&quot;);</span><br><span class="line">            Object[] elements = (Object[]) dexElements.get(dexPathListWithDexClassLoader);</span><br><span class="line"></span><br><span class="line">            // 获取PathClassLoader对象的pathList对象，DexPathList</span><br><span class="line">            Object dexPathListWithPathClassLoader = ReflectUtils.findField(pathClassLoader, &quot;pathList&quot;).get(pathClassLoader);</span><br><span class="line"></span><br><span class="line">            //把之前获取的Element[]数组插入到PathClassLoader对象对应的DexPathList的Element数组中</span><br><span class="line">            ReflectUtils.insertFieldArray(dexPathListWithPathClassLoader, &quot;dexElements&quot;, elements);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tvFix.setText(&quot;done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private File copyFileFromAssets(String assetName, String dexOutputDir) throws IOException &#123;</span><br><span class="line">    File originDex = null;</span><br><span class="line">    AssetManager assets = getAssets();</span><br><span class="line">    InputStream open = assets.open(assetName);</span><br><span class="line">    originDex = new File(dexOutputDir, assetName);</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(originDex);</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len = open.read(bytes)) != -1) &#123;</span><br><span class="line">        fileOutputStream.write(bytes, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    open.close();</span><br><span class="line"></span><br><span class="line">    return originDex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>热修复就是基于类加载机制，把修复好的dex插入到app的PathClassLoader关联的dex数组的前部，这样的话根据类加载机制，就会先找到修复好的class，进而实现了修复的目的。</p>
<p>关于类加载机制，可以阅读相关文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/2026b01fb965" target="_blank" rel="noopener">类加载机制系列1——深入理解Java中的类加载器</a></li>
<li><a href="https://www.jianshu.com/p/7193600024e7" target="_blank" rel="noopener">类加载机制系列2——深入理解Android中的类加载器</a></li>
<li><a href="https://www.jianshu.com/p/07200780dc83" target="_blank" rel="noopener">类加载机制系列3——MultiDex原理解析</a></li>
</ul>
<h1 id="gradle打包处理添加assets过程"><a href="#gradle打包处理添加assets过程" class="headerlink" title="gradle打包处理添加assets过程"></a>gradle打包处理添加assets过程</h1><p>如果我们使用android gradle plugin打包，为了要把外部assets目录下的文件打包到apk的assets目录中，需要hook gradle的打包流程。给出相关代码，也可以亲自研究一下项目<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a>。</p>
<p>在build.gradle中创建一个类实现Plugin接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class AssetPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            project.android.applicationVariants.each &#123; ApplicationVariant variant -&gt;</span><br><span class="line">                String variantName = variant.name.capitalize()</span><br><span class="line">                def packageTask = project.tasks.getByName(&quot;package$&#123;variantName&#125;&quot;)</span><br><span class="line">                project.logger.quiet(&quot;packageTask: &quot; + packageTask.class)</span><br><span class="line">                project.logger.quiet(&quot;packageTask assets path: &quot; + packageTask.assets.asPath)</span><br><span class="line">                packageTask.doFirst &#123;</span><br><span class="line">                    project.copy &#123; param -&gt;</span><br><span class="line">                        from &quot;../multidexbuild/assets&quot;</span><br><span class="line">                        //很坑的一点是，2.3.3下是packageTask.assets，到3.0就变成packageTask.assets.asPath</span><br><span class="line">                        into &quot;$&#123;packageTask.assets.asPath&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在build.gradle中引入插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: AssetPlugin</span><br></pre></td></tr></table></figure>
<p>想要了解gradle可以查看我之前写过的一个gradle系列文章<a href="https://www.jianshu.com/p/0bde7097abaf" target="_blank" rel="noopener">Gradle学习</a>。<br>关于gradle打包apk的过程，这里就不多做介绍了，感兴趣的可以自行了解。如果想要深入研究，推荐研究一下<a href="https://github.com/typ0520/fastdex" target="_blank" rel="noopener">fastdex</a>，是我司的大神写的，一定会让你深受启发。<br>也可以阅读他写的相关文章：<a href="https://www.jianshu.com/p/53923d8f241c" target="_blank" rel="noopener">加快apk的构建速度，如何把编译时间从130秒降到17秒</a></p>
<h1 id="apk打包shell脚本"><a href="#apk打包shell脚本" class="headerlink" title="apk打包shell脚本"></a>apk打包shell脚本</h1><p>为了方便起见，写了一个构建apk文件的脚本 <a href="https://github.com/sososeen09/android-blog-demos/blob/master/apk-build/apk-build-with-shell/build.sh" target="_blank" rel="noopener">build.sh</a>，<br>如果要再自己本机上运行一下脚本，需要更改配置的android sdk目录。</p>
<blockquote>
<p>注意:使用命令行打包，注意需要配置好环境变量，确保adb、dx、aapt等命令都可以正常使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;init...&apos;</span><br><span class="line">project_dir=$(pwd)</span><br><span class="line"></span><br><span class="line">echo &quot;project_dir: $&#123;project_dir&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 需要更改为自己的android sdk存放的目录</span><br><span class="line">sdk_folder=/works/android/android-sdk-macosx</span><br><span class="line">platform_folder=$&#123;sdk_folder&#125;/platforms/android-26</span><br><span class="line">android_jar=$&#123;platform_folder&#125;/android.jar</span><br><span class="line"></span><br><span class="line"># 使用通配符，因为有的命名是sdklib-26.0.0-dev.jar这样的形式</span><br><span class="line">sdklib_jar=$&#123;sdk_folder&#125;/tools/lib/sdklib*.jar</span><br><span class="line"></span><br><span class="line">src=$&#123;project_dir&#125;/src/main</span><br><span class="line">bin=$&#123;project_dir&#125;/bin</span><br><span class="line">libs=$&#123;project_dir&#125;/libs</span><br><span class="line"></span><br><span class="line">java_source_folder=$&#123;src&#125;/java</span><br><span class="line"></span><br><span class="line">if [ -d gen ];then</span><br><span class="line">	rm -rf gen</span><br><span class="line">fi</span><br><span class="line">if [ -d bin ];then</span><br><span class="line">	rm -rf bin</span><br><span class="line">fi</span><br><span class="line">mkdir gen</span><br><span class="line">mkdir bin</span><br><span class="line"></span><br><span class="line">#1.生成R文件</span><br><span class="line">echo &apos;generate R.java file&apos;</span><br><span class="line">aapt package -f -m -J ./gen -S $&#123;src&#125;/res -M $&#123;src&#125;/AndroidManifest.xml -I $&#123;android_jar&#125;</span><br><span class="line"></span><br><span class="line">#2.生成资源索引文件</span><br><span class="line">echo &apos;generate resourses index file&apos;</span><br><span class="line">aapt package -f -M $&#123;src&#125;/AndroidManifest.xml -S $&#123;src&#125;/res -I $&#123;android_jar&#125; -F bin/resources.ap_</span><br><span class="line"></span><br><span class="line">#3.编译java文件</span><br><span class="line">echo &apos;compile java file&apos;</span><br><span class="line">javac -encoding UTF-8 -g -target 1.7 -source 1.7 -cp $&#123;android_jar&#125; -d bin $&#123;java_source_folder&#125;/com/sososeen09/multidexbuild/*.java $&#123;java_source_folder&#125;/com/sososeen09/multidexbuild/utils/*.java gen/com/sososeen09/multidexbuild/*.java</span><br><span class="line"># javac -encoding UTF-8 -g -target 1.7 -source 1.7 -cp $android_jar -d bin src/ gen/</span><br><span class="line"></span><br><span class="line">#4.生成dex文件,这里我们把MainActivity打包到主dex中，utils打包到secondaryDex中</span><br><span class="line"># --minimal-main-dex 表示只把maindexlist.txt中指定的类打包到主dex中</span><br><span class="line">#  --set-max-idx-number=2000  表示指定没个dex的最大方法数目是2001，最大65535</span><br><span class="line">echo &apos;generate dex file&apos;</span><br><span class="line">dx --dex --output=bin/ --multi-dex --main-dex-list=maindexlist.txt --minimal-main-dex bin/</span><br><span class="line"></span><br><span class="line">#5.打包apk</span><br><span class="line">echo &apos;generate apk file&apos;</span><br><span class="line">java -cp $&#123;sdklib_jar&#125; com.android.sdklib.build.ApkBuilderMain bin/app-debug-unsigned.apk -v -u -z bin/resources.ap_ -f bin/classes.dex -rf src</span><br><span class="line"></span><br><span class="line">#6.通过aapt工具把secondarydex copy到apk中</span><br><span class="line">echo &apos;aapt add dex into apk&apos;</span><br><span class="line">cd bin</span><br><span class="line">aapt add -f app-debug-unsigned.apk classes2.dex</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">#7.把assets的内容加进去</span><br><span class="line">echo &apos;put some file into apk assets&apos;</span><br><span class="line">aapt add -f bin/app-debug-unsigned.apk assets/ic_launcher-web.png assets/fixed.dex</span><br><span class="line"></span><br><span class="line">#8 签名</span><br><span class="line">echo &apos;sign apk&apos;</span><br><span class="line">java -jar auto-sign/signapk.jar auto-sign/testkey.x509.pem auto-sign/testkey.pk8 ./bin/app-debug-unsigned.apk ./bin/app-debug.apk</span><br><span class="line"></span><br><span class="line">#9 打印方法数</span><br><span class="line">dexdump -f bin/app-debug.apk | grep method_ids_size</span><br></pre></td></tr></table></figure>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul>
<li><a href="https://blog.csdn.net/chenkai19920410/article/details/60589100" target="_blank" rel="noopener">自己动手生成Android Apk</a></li>
<li><a href="https://blog.csdn.net/jason0539/article/details/44917745" target="_blank" rel="noopener">android Apk打包过程概述_android是如何打包apk的</a></li>
<li><a href="http://blog.csdn.net/chichoxian/article/details/8760456" target="_blank" rel="noopener">dx使用出现的错误总结</a></li>
<li><a href="https://segmentfault.com/a/1190000004062952" target="_blank" rel="noopener">Android动态加载入门 简单加载模式</a></li>
<li><a href="http://blog.csdn.net/jiangwei0910410003/article/details/50740026" target="_blank" rel="noopener">如何使用Ant脚本编译出Jar和Apk包</a></li>
<li><a href="https://dev.qq.com/topic/5913db5c29d8be2a14b64da8" target="_blank" rel="noopener">dex分包变形记</a></li>
<li><a href="http://blog.csdn.net/gaozhan_csdn/article/details/52024497" target="_blank" rel="noopener">multidex分包续：将指定的类打包到主dex中</a></li>
<li><a href="http://blog.csdn.net/mynameishuangshuai/article/details/52703029" target="_blank" rel="noopener">彻底掌握Android多分包技术MultiDex-用Ant和Gradle分别构建（一）</a></li>
<li><a href="https://www.zybuluo.com/linux1s1s/note/309503" target="_blank" rel="noopener">Android 打包系列-基本打包流程</a></li>
<li><a href="https://blog.csdn.net/jiangwei0910410003/article/details/50402000" target="_blank" rel="noopener">Android签名机制之—签名过程详解</a></li>
<li><a href="https://developer.android.google.cn/studio/command-line/zipalign" target="_blank" rel="noopener">https://developer.android.google.cn/studio/command-line/zipalign</a></li>
<li><a href="https://www.jianshu.com/p/53923d8f241c" target="_blank" rel="noopener">加快apk的构建速度，如何把编译时间从130秒降到17秒</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/LayoutInflater——你应该知道的一点知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/LayoutInflater——你应该知道的一点知识/" itemprop="url">LayoutInflater——你应该知道的一点知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T13:56:00+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android开发中我们经常使用LayoutInflater，俗称布局填充器，使用它来把布局转为一个View。一般来讲可能采用的方式如下：</p>
<ol>
<li><p>调用其静态from方法，获取LayoutInflater对象，然后调用其inflate方法获取一个View对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static LayoutInflater from(Context context)</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用View的静态inflate方法，获取对象，不过该方法其实等同于封装了方式1。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) &#123;</span><br><span class="line">    LayoutInflater factory = LayoutInflater.from(context);</span><br><span class="line">    return factory.inflate(resource, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，其实今天想讨论的不是如何加载一个布局的问题，而是一些其它问题，比如：</p>
<ol>
<li>每次调用LayoutInflater的from方法都会创建一个新的LayoutInflater对象吗？</li>
<li>LayoutInflater的from方法中如果传递不同的Context对象会有什么不同？</li>
<li>调用View的getContext() 方法会获取一个Context，那么这个Context对象具体是谁呢？</li>
<li>为什么想要在xml中使用View，就必须要有两个参数的构造方法呢？</li>
</ol>
<p>下面我们就通过实践和源码分析的方式来回答一下上面的这些问题。</p>
<h1 id="LayoutInflater的from方法"><a href="#LayoutInflater的from方法" class="headerlink" title="LayoutInflater的from方法"></a>LayoutInflater的from方法</h1><p>先给出结论：我们通过LayoutInflater的from(Context context)方法获取一个LayoutInflater对象。传递不同的Context对象，获取到的LayoutInflater对象也不同。每一个Activity 都会持有一个 LayoutInflater 对象， 如果每次传递的Context对象都是同一个Activity 对象，只会创建一个 LayoutInflater 对象。</p>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater fromActivity1 = LayoutInflater.from(this);</span><br><span class="line">LayoutInflater fromActivity2 = LayoutInflater.from(this);</span><br><span class="line">LayoutInflater fromApplication = LayoutInflater.from(getApplication());</span><br><span class="line"></span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromActivity1);</span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromApplication);</span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromActivity2);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@28d214ef</span><br><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@3adebfc</span><br><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@28d214ef</span><br></pre></td></tr></table></figure>
<p>在打印的 log 中也可以看到调动LayoutInflater的from方法实际上创建的是它的子类 PhoneLayoutInflater 对象。从结果中也看到传递Application 或者Activity，创建的LayoutInflater 不同，而且如果传递的是Activity，多次调用只会创建一个LayoutInflater 对象。</p>
<p>源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#android.view.LayoutInflater</span><br><span class="line">public static LayoutInflater from(Context context) &#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    if (LayoutInflater == null) &#123;</span><br><span class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了Context的getSystemService方法，如果我们传递的是Activity，会先调用Activity的getSystemService() 方法。，所以我们先看一下Activity中的getSystemService方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(@ServiceName @NonNull String name) &#123;</span><br><span class="line">    if (getBaseContext() == null) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                &quot;System services not available to Activities before onCreate()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (WINDOW_SERVICE.equals(name)) &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125; else if (SEARCH_SERVICE.equals(name)) &#123;</span><br><span class="line">        ensureSearchManager();</span><br><span class="line">        return mSearchManager;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity 中的 getSystemService() 方法只是对<strong>WINDOW_SERVICE</strong> 和 <strong>SEARCH_SERVICE</strong> 做了单独的处理，没有对 <strong>LAYOUT_INFLATER_SERVICE</strong> 做什么处理，不过Activity是继承自 ContextThemeWrapper 的，我们再来看一下ContextThemeWrapper 的 getSystemService() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#android.view.ContextThemeWrapper</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">        if (mInflater == null) &#123;</span><br><span class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);//1</span><br><span class="line">        &#125;</span><br><span class="line">        return mInflater;</span><br><span class="line">    &#125;</span><br><span class="line">    return getBaseContext().getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果我们获取LayoutInflater对象，并且当前的 mInflater 变量为空的话就会调用1处的 LayoutInflater.from(getBaseContext()).cloneInContext(this) 方法创建一个LayoutInflater对象，下次再调用的时候直接返回这个对象，不会重复创建。<br>上面的代码中getBaseContext()方法获取的就是该Activity绑定的mBase对象，这个mBase是一个Context对象 ，但Context是一个抽象类，那么它实际上是什么对象呢，这个我们一会再来解释。</p>
<p>先来看一下如果我们传递的是Application对象会发生什么呢？<br>我们需要知道一点，Application是继承自ContextWrapper的，来看一下ContextWrapper的 getSystemService() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContextWrapper</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return mBase.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了 mBase 的 getSystemService() 方法，这个mBase也不绕关子了，它就是一个ContextImpl对象。Application、Activity、Service对象在创建完毕之后他们的attach() 方法都会被调用，在 attach()  中会调用 attachBaseContext() 方法，就会给这个mBase 赋值，实际上是一个 ContextImpl对象。这个在我之前写的几篇文章中都有涉及到相关内容，想要了解的可以看下<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>、<a href="https://www.jianshu.com/p/bce3b49a3af6" target="_blank" rel="noopener">Android四大组件——Service的工作过程分析</a>。</p>
<p>通过上面的分析我们会发现，不管是传递Activity还是Application实际上都会先调用ContextImpl 的  getSystemService() 方法，直接来看一下它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl </span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextImpl 调用了 SystemServiceRegistry的getSystemService() 方法，需要说明一点，ContextImpl 的getSystemService() 方法在不同的版本中都会有不同。我们不需要纠结API的不同，侧重流程，看到我们想要看的即可。比如现在，我们想要看的是LayoutInflater对象是怎么创建的，跟着代码继续看 SystemServiceRegistry的getSystemService() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.app.SystemServiceRegistry</span><br><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    return fetcher != null ? fetcher.getService(ctx) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SystemServiceRegistry的getSystemService() 方法中通过一个 SYSTEM_SERVICE_FETCHERS 来根据一个 name 获取一个 ServiceFetcher 对象，然后调用它的getService 返回一个对象。我们的LayoutInflater 对象应该就是通过ServiceFetcher 获得的。SYSTEM_SERVICE_FETCHERS 实际上就是一个HashMap。SystemServiceRegistry这个类都是静态方法和静态代码块，也就是说只要这个类加载的时候就会触发注册，SystemServiceRegistry注册了App运行需要用到的所有服务，有AMS，PMS、NMS，我们需要用到 LAYOUT_INFLATER_SERVICE 也就是LayoutInflater 也在其中。</p>
<p>ServiceFetcher的getService中首先会看看当前是否已经缓存了对应的对象，比如我们想要获取的LayoutInflater，如果已经有的话会直接返回这个对象，如果没有的话就会调用其createService() 方法，从下面的代码中也可以看到，通过PhoneLayoutInflater 的一个参数的构造方法创建了LayoutInflater 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final class SystemServiceRegistry &#123;</span><br><span class="line">    private static final String TAG = &quot;SystemServiceRegistry&quot;;</span><br><span class="line"></span><br><span class="line">    // Service registry information.</span><br><span class="line">    // This information is never changed once static initialization has completed.</span><br><span class="line">    private static final HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class="line">            new HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">    private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line">    private static int sServiceCacheSize;</span><br><span class="line"></span><br><span class="line">    // Not instantiable.</span><br><span class="line">    private SystemServiceRegistry() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">...</span><br><span class="line">        registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,</span><br><span class="line">                new CachedServiceFetcher&lt;ActivityManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ActivityManager createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">...</span><br><span class="line">        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">                new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public LayoutInflater createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析我们也可以发现，不管是LayoutInflater的from方法中的 Context，传递Activity还是Application实际上都会先调用ContextImpl 的  getSystemService() 方法获取一个LayoutInflater。这个对象是唯一的，只要是从ContextImpl这获取的，就只有一个。对于Activity不同的是又调用了 cloneInContext() 方法来获取一个LayoutInflater对象，这个 cloneInContext() 方法是一个抽象方法，由PhoneLayoutInflater实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># com.android.internal.policy.PhoneLayoutInflater</span><br><span class="line">public PhoneLayoutInflater(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LayoutInflater cloneInContext(Context newContext) &#123;</span><br><span class="line">    return new PhoneLayoutInflater(this, newContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected PhoneLayoutInflater(LayoutInflater original, Context newContext) &#123;</span><br><span class="line">    super(original, newContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> #android.view.LayoutInflater</span><br><span class="line">protected LayoutInflater(LayoutInflater original, Context newContext) &#123;</span><br><span class="line">    mContext = newContext;</span><br><span class="line">    mFactory = original.mFactory;</span><br><span class="line">    mFactory2 = original.mFactory2;</span><br><span class="line">    mPrivateFactory = original.mPrivateFactory;</span><br><span class="line">    setFilter(original.mFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中也可以看到，调用 LayoutInflater的cloneInContext() 方法实际上就是创建了一个新的LayoutInflater对象，并且会把原来对象上的一些属性拷贝过来，如mFactory、mFactory2、mPrivateFactory、mFilter。这些factory 和 filter 就是为了从xml中加载布局来创建View对象时候用到的。</p>
<p>不过还有一点需要注意，PhoneLayoutInflater的一个构造方法中的Context是由ContextImpl的getOuterContext() 方法获取到的，那么这个mOuterContext是什么呢？</p>
<p>ContextImpl对象与Application、Activity、Service对象是一一绑定的。我们的ContextImpl 中的mOuterContext对象，这个在Activity中就是当前Activity对象，在Service中就是当前的Service对象。赋值时机是在ContextImpl对象创建后。ContextImpl的创建时机都是在ActivityThead中每次启动Activity或者Service或者一个新的Application的时候。</p>
<h1 id="LayoutInflater-的创建时机"><a href="#LayoutInflater-的创建时机" class="headerlink" title="LayoutInflater 的创建时机"></a>LayoutInflater 的创建时机</h1><p>上面我们讲到的是开发者主动调用LayoutInflater的from方法来返回一个对象，但是我们知道一点是当在Activity中调用 setContentView(layoutRes) 方法的时候，会调用到PhoneWindow的setContentView(layoutRes) 方法，在该方法中通过LayoutInflater对象来创建View树了，那么这个LayoutInflater是什么时候创建的呢？</p>
<p>实际上，LayoutInflater的创建时机就是在Activity对象被创建出来之后。当Activity创建后，其attach方法就会被调用，在这个过程中Activity相关的对象或者属性就会被绑定，比如，PhoneWindow就是在这个时候被创建出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PhoneWindow中有两个构造函数，一个有3个参数，一个有1个参数。3个参数的首先会调用1个参数的。在这个过程中调用了LayoutInflater的from 方法。来创建LayoutInflater对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PhoneWindow(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个context对象就是Activity。</p>
</blockquote>
<h1 id="LayoutInflater的inflate-方法"><a href="#LayoutInflater的inflate-方法" class="headerlink" title="LayoutInflater的inflate() 方法"></a>LayoutInflater的inflate() 方法</h1><p>我们使用LayoutInflater的inflate方法的时候一般会使用2个参数或者3个参数的方法，第一个参数代表所要加载的布局，第二个参数是跟ViewGroup，这个参数需要与第3个参数配合使用，attachToRoot如果为true，表示要把当前的布局添加到ViewGroup中，作为其子View。如果为false就是表示只是采用ViewGroup的LayoutParams作为测量的依据。如果ViewGroup为null的话也能够得到一个View，不过这个View的尺寸有可能不是我们想要的。所以尽量不要使第二个参数为null。如果你只想从布局中加载View，而不想添加到ViewGroup中，可以使用3个参数的方法，attachToRoot为false即可。</p>
<p>下面这两个方法表示从资源中找到对应的布局xml，然后创建一个XmlResourceParser对象用来解析便签。解析方式采用的是pull解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">    return inflate(resource, root, root != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res = getContext().getResources();</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;</span><br><span class="line">                + Integer.toHexString(resource) + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    try &#123;</span><br><span class="line">        return inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面两个我们开发者经常使用的方法，还有一个3个参数的inflate方法。第一个参数是XmlPullParser对象，我们把它当做一个解析标签的对象即可。在这个inflate() 方法中会对所有的view标签（包括自定义View）、include、merge、ViewStub等进行处理。</p>
<p>在该方法中有一个含有两个元素的数组 mConstructorArgs，这个就是在使用View的两个参数的构造方法时用于提供参数的。mConstructorArgs的第一个元素就是inflaterContext，实际上就是创建LayoutInflater对象的mContext。在一个Activity创建的LayoutInflater，mContext指向的就是这个Activity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">        final Context inflaterContext = mContext;</span><br><span class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">        mConstructorArgs[0] = inflaterContext;</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                // Empty</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">            final String name = parser.getName();</span><br><span class="line">...</span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml  //1</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // Set the layout params for temp if we are not</span><br><span class="line">                        // attaching. (If we are, we use addView, below)</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">                // Inflate all children under temp against its context.</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line">...</span><br><span class="line">                // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                // to root. Do that now.</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Decide whether to return the root that was passed in or the</span><br><span class="line">                // top view found in xml.</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">...</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注释1调用了 createViewFromTag() 方法。该方法又会调用其重载方法。在createViewFromTag 重载方法中，会一次判断mFactory2、mFactory、mPrivateFactory是否会null，如果不为null的就按照优先级调用mFactory2、mFactory、mPrivateFactory的相关方法来创建View，只有前一个返回的View为null的时候，才会由后一个来创建，如果这几个创建的View都会null的话，就会调用LayoutInflater自身的方法来创建View。</p>
<p>mFactory2、mFactory、mPrivateFactory均有相关的set方法用于设置。<br>相信看到这里，就应该明白了我们之前讲的在clone一个原始的LayoutInflater的作用了，就是可以复用它的mFactory2、mFactory、mPrivateFactory，不需要再重新设置了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    return createViewFromTag(parent, name, context, attrs, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</span><br><span class="line">        boolean ignoreThemeAttr) &#123;</span><br><span class="line">    if (name.equals(&quot;view&quot;)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Apply a theme wrapper, if allowed and one is specified.</span><br><span class="line">    if (!ignoreThemeAttr) &#123;</span><br><span class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        final int themeResId = ta.getResourceId(0, 0);</span><br><span class="line">        if (themeResId != 0) &#123;</span><br><span class="line">            context = new ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">// 1 开始创建View</span><br><span class="line">    try &#123;</span><br><span class="line">        View view;</span><br><span class="line">        if (mFactory2 != null) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; else if (mFactory != null) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            view = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            final Object lastContext = mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] = context;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    view = createView(name, null, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mConstructorArgs[0] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return view;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下Factory、Factory2，Factory2继承自Factory，它们的接口方法都是用来创建View对象的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    public View onCreateView(String name, Context context, AttributeSet attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Factory2 extends Factory &#123;</span><br><span class="line">    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一下LayoutInflater的createView方法，首先通过View的名称来获取它的构造函数Constructor。如果Constructor为null的话就会采用ClassLoader去加载对应的class。需要注意的时候我们在xml填写的View的名称比如TextView，实际上是有全路径名的，即为：android.widget.TextView，类加载器加载必须要使用全路径名，因此对于TextView这样的Android系统自带的空间，需要加上全路径，因此可以在注释1处看到使用了prefix。当Class加载成功的时候就会通过mConstructorSignature创建一个两个参数的构造器，对应的参数是 Context.class, AttributeSet.class。之后就可以看到利用的反射的方式创建View对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public final View createView(String name, String prefix, AttributeSet attrs)</span><br><span class="line">        throws ClassNotFoundException, InflateException &#123;</span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</span><br><span class="line">        constructor = null;</span><br><span class="line">        sConstructorMap.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends View&gt; clazz = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line"></span><br><span class="line">        if (constructor == null) &#123;</span><br><span class="line">            // Class not found in the cache, see if it&apos;s real, and try to add it </span><br><span class="line">            //1</span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">            if (mFilter != null &amp;&amp; clazz != null) &#123;</span><br><span class="line">                boolean allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                if (!allowed) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If we have a filter, apply it to cached constructor</span><br><span class="line">            if (mFilter != null) &#123;</span><br><span class="line">                // Have we seen this name before?</span><br><span class="line">                Boolean allowedState = mFilterMap.get(name);</span><br><span class="line">                if (allowedState == null) &#123;</span><br><span class="line">                    // New class -- remember whether it is allowed</span><br><span class="line">                    clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                            prefix != null ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                    mFilterMap.put(name, allowed);</span><br><span class="line">                    if (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object lastContext = mConstructorArgs[0];</span><br><span class="line">        if (mConstructorArgs[0] == null) &#123;</span><br><span class="line">            // Fill in the context if not already within inflation.</span><br><span class="line">            mConstructorArgs[0] = mContext;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = mConstructorArgs;</span><br><span class="line">        args[1] = attrs;</span><br><span class="line"></span><br><span class="line">        final View view = constructor.newInstance(args);</span><br><span class="line">        if (view instanceof ViewStub) &#123;</span><br><span class="line">            // Use the same context when inflating ViewStub later.</span><br><span class="line">            final ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</span><br><span class="line">        &#125;</span><br><span class="line">        mConstructorArgs[0] = lastContext;</span><br><span class="line">        return view;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过View的两个参数的构造函数创建了View对象，第一个参数Context，传递的是LayoutInflater自身的mContext，对于Activity中的LayoutInflater，这个mContext就是Activity自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public View(Context context, @Nullable AttributeSet attrs)</span><br></pre></td></tr></table></figure>
<p>所以你应该明白了，在View中的Context实际上就是其所在的Activity对象。那么对于Fragment中的View也是这样的。</p>
<h1 id="Fragment中的LayoutInflater"><a href="#Fragment中的LayoutInflater" class="headerlink" title="Fragment中的LayoutInflater"></a>Fragment中的LayoutInflater</h1><p>Fragment中有一个onCreateView() 方法，方法中有一个参数是LayoutInflater，这么LayoutInflater对象是从哪来的呢？</p>
<p>这个对象也是clone而来，而且是由Activity中的LayoutInflater clone而来。Fragment中的LayoutInflater与Activity中的LayoutInflater不是同一个对象，但既然是clone，Fragment中的LayoutInflater中把是Activity中的LayoutInflater中的mFactory、mFactory2、mPrivateFactory、mFilter变量全部赋值给自己相应的成员变量。注意：这是一个浅拷贝，也就是对象中的成员变量拷贝的是引用而不是实例。</p>
<p>我们来分析一下源码，Fragment是由FragmentManager来管理的，Fragment在创建阶段的生命周期方法是由FragmentManager的moveToState() 方法中回调的。代码很长，我们截取一些关键的信息，可以看到在这个方法中，Fragment的生命周期方法被回调。其中我们看到调用了Fragment的performCreateView() 方法，在参数中传递了LayoutInflater，而这个是通过调用的Fragment的 performGetLayoutInflater() 方法获得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"># android.app.FragmentManagerImpl</span><br><span class="line">@SuppressWarnings(&quot;ReferenceEquality&quot;)</span><br><span class="line">void moveToState(Fragment f, int newState, int transit, int transitionStyle,</span><br><span class="line">        boolean keepActive) &#123;</span><br><span class="line">    if (DEBUG &amp;&amp; false) Log.v(TAG, &quot;moveToState: &quot; + f</span><br><span class="line">        + &quot; oldState=&quot; + f.mState + &quot; newState=&quot; + newState</span><br><span class="line">        + &quot; mRemoving=&quot; + f.mRemoving + &quot; Callers=&quot; + Debug.getCallers(5));</span><br><span class="line"></span><br><span class="line">    // Fragments that are not currently added will sit in the onCreate() state.</span><br><span class="line">    if ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        newState = Fragment.CREATED;</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">        if (f.mState == Fragment.INITIALIZING &amp;&amp; f.isInBackStack()) &#123;</span><br><span class="line">            // Allow the fragment to be created so that it can be saved later.</span><br><span class="line">            newState = Fragment.CREATED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // While removing a fragment, we can&apos;t change it to a higher state.</span><br><span class="line">            newState = f.mState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Defer start if requested; don&apos;t allow it to move to STARTED or higher</span><br><span class="line">    // if it&apos;s not already started.</span><br><span class="line">    if (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mState &lt;= newState) &#123;</span><br><span class="line">...</span><br><span class="line">        switch (f.mState) &#123;</span><br><span class="line">            case Fragment.INITIALIZING:</span><br><span class="line">...</span><br><span class="line">                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);</span><br><span class="line">                    f.mCalled = false;</span><br><span class="line">                    f.onAttach(mHost.getContext());</span><br><span class="line">...</span><br><span class="line">            case Fragment.CREATED:</span><br><span class="line">                // This is outside the if statement below on purpose; we want this to run</span><br><span class="line">                // even if we do a moveToState from CREATED =&gt; *, CREATED =&gt; CREATED, and</span><br><span class="line">                // * =&gt; CREATED as part of the case fallthrough above.</span><br><span class="line">                ensureInflatedFragmentView(f);</span><br><span class="line"></span><br><span class="line">                if (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;moveto ACTIVITY_CREATED: &quot; + f);</span><br><span class="line">                    if (!f.mFromLayout) &#123;</span><br><span class="line">                        ViewGroup container = null;</span><br><span class="line">                 ...</span><br><span class="line">                            container = mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">                            if (container == null &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                                String resName;</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    resName = f.getResources().getResourceName(f.mContainerId);</span><br><span class="line">...</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mContainer = container;</span><br><span class="line">                        f.mView = f.performCreateView(f.performGetLayoutInflater(</span><br><span class="line">                                f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">                        if (f.mView != null) &#123;</span><br><span class="line">                            f.mView.setSaveFromParentEnabled(false);</span><br><span class="line">                            if (container != null) &#123;</span><br><span class="line">                                container.addView(f.mView);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (f.mHidden) &#123;</span><br><span class="line">                                f.mView.setVisibility(View.GONE);</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</span><br><span class="line">                                    false);</span><br><span class="line">                            // Only animate the view if it is visible. This is done after</span><br><span class="line">                            // dispatchOnFragmentViewCreated in case visibility is changed</span><br><span class="line">                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</span><br><span class="line">                                    &amp;&amp; f.mContainer != null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);</span><br><span class="line">                    if (f.mView != null) &#123;</span><br><span class="line">                        f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mSavedFragmentState = null;</span><br><span class="line">                &#125;</span><br><span class="line">                // fall through</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下Fragment的 performGetLayoutInflater() 方法，在该方法中又调用了其onGetLayoutInflater() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.Fragment</span><br><span class="line">LayoutInflater performGetLayoutInflater(Bundle savedInstanceState) &#123;</span><br><span class="line">    LayoutInflater layoutInflater = onGetLayoutInflater(savedInstanceState);</span><br><span class="line">    mLayoutInflater = layoutInflater;</span><br><span class="line">    return mLayoutInflater;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LayoutInflater getLayoutInflater(Bundle savedFragmentState) &#123;</span><br><span class="line">    if (mHost == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;onGetLayoutInflater() cannot be executed until the &quot;</span><br><span class="line">                + &quot;Fragment is attached to the FragmentManager.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutInflater result = mHost.onGetLayoutInflater();</span><br><span class="line">    getChildFragmentManager(); // Init if needed; use raw implementation below.</span><br><span class="line">    LayoutInflaterCompat.setFactory2(result, mChildFragmentManager.getLayoutInflaterFactory());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Fragment的getLayoutInflater() 方法中，通过调用 mHost.onGetLayoutInflater()获取了一个LayoutInflater对象。mHost 就是FragmentHostCallback对象，来看一下它的onGetLayoutInflater() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.FragmentHostCallback</span><br><span class="line">public LayoutInflater onGetLayoutInflater() &#123;</span><br><span class="line">    return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FragmentHostCallback的onGetLayoutInflater() 方法实际上就是调用了mContext的getSystemService方法，这个就跟我们前面分析的通过LayoutInflater的from方法是一个意思，mContext实际上就是Fragment所在的Activity。再加上之前的分析我们可以得出一个结论，Fragment中的LayoutInflater是由Activity中的LayoutInflater clone而来，它们不是同一个对象，不过Fragment中的LayoutInflater把Activity的LayoutInflater设置的一些factory copy过来，相当于它们使用的是同样的工厂。</p>
<p>在Fragmen的getLayoutInflater方法中调用了 <code>LayoutInflaterCompat.setFactory2(result, mChildFragmentManager.getLayoutInflaterFactory());</code> ，其实就调用LayoutInflater的setFactory2() 方法。这个方法我们下一小结再讲。</p>
<h1 id="LayoutInflater的setFactory2-方法"><a href="#LayoutInflater的setFactory2-方法" class="headerlink" title="LayoutInflater的setFactory2() 方法"></a>LayoutInflater的setFactory2() 方法</h1><p>LayoutInflater的setFactory2方法很有意思，如果原来LayoutInflater上面的mFactory为null，就是把实际上mFactory、mFactory2均赋值为当前设置的factory。如果不为null创建了一个FactoryMerger对象赋值给mFactory、mFactory2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public void setFactory2(Factory2 factory) &#123;</span><br><span class="line">    if (mFactorySet) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (factory == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Given factory can not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mFactorySet = true;</span><br><span class="line">    if (mFactory == null) &#123;</span><br><span class="line">        mFactory = mFactory2 = factory;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们之前在Activity中设置了mFactory2，那么当在Fragment中的LayoutInflater调用setFactory2方法的时候，mFactory 、mFactory2 均不为空，那么就会走到else里面，也就是说创建了一个FactoryMerger对象。FactoryMerger实际上实现了Factory2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class FactoryMerger implements Factory2 &#123;</span><br><span class="line">    private final Factory mF1, mF2;</span><br><span class="line">    private final Factory2 mF12, mF22;</span><br><span class="line"></span><br><span class="line">    FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) &#123;</span><br><span class="line">        mF1 = f1;</span><br><span class="line">        mF2 = f2;</span><br><span class="line">        mF12 = f12;</span><br><span class="line">        mF22 = f22;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">        View v = mF1.onCreateView(name, context, attrs);</span><br><span class="line">        if (v != null) return v;</span><br><span class="line">        return mF2.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">        View v = mF12 != null ? mF12.onCreateView(parent, name, context, attrs)</span><br><span class="line">                : mF1.onCreateView(name, context, attrs);</span><br><span class="line">        if (v != null) return v;</span><br><span class="line">        return mF22 != null ? mF22.onCreateView(parent, name, context, attrs)</span><br><span class="line">                : mF2.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想到没有，当Fragment中的LayoutInflater中的Factory方法去执行的时候，实际上先执行的是mF12和mF1的onCreateView，我们知道在Fragment中设置的是mChildFragmentManager.getLayoutInflaterFactory()，mChildFragmentManager是FragmentManager，我们在Activity中通过getSupportFragmentManager获取也是FragmentManager对象。FragmentManager的实现类FragmentManagerImpl实现了Factory2接口，是用来解析<code>fragment</code>标签的。<br>可以看到，如果标签不是fragment，实际上它还是会直接返回的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.FragmentManager$FragmentManagerImpl</span><br><span class="line">@Override</span><br><span class="line">public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    if (!&quot;fragment&quot;.equals(name)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    return fragment.mView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实想想，这样的设计真的挺好，Fragment会复用了Activity的Factory对象，只是在解析fragment标签的时候，采用用FragmentManagerImpl来解析。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信看完上面的内容，你对LayoutInflater应该有一个比较全面的了解了，具体怎么灵活运用就要看你的需求了。比如你想完成一个换肤框架，那么你首先肯定要获得所有需要换肤的控件，此时LayoutInflater的Factory2就可以派上用场了。通过给LayoutInflater设置Factory2，可以自己处理View的创建逻辑，获取相关的View，当你需要换肤的时候，给这些View设置新的属性即可。</p>
<p>我们再来回顾一些问题，现在你能够自己解答了吗？</p>
<ol>
<li>每次调用LayoutInflater的from方法都会创建一个新的LayoutInflater对象吗？</li>
<li>LayoutInflater的from方法中如果传递不同的Context对象会有什么不同？</li>
<li>调用View的getContext() 方法会获取一个Context，那么这个Context对象具体是谁呢？</li>
<li>为什么想要在xml中使用View，就必须要有两个参数的构造方法呢？</li>
<li>Fragment中有一个onCreateView方法，有一个参数是LayoutInflater，这么LayoutInflater对象是从哪来的呢？</li>
<li>LayoutInflater对象的真正创建时机是什么时候？</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/使用AsyncTask需要注意的一些点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/使用AsyncTask需要注意的一些点/" itemprop="url">使用AsyncTask需要注意的一些点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T18:13:00+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AsyncTask在面试中应该比较经常会问到，虽然我们现在开发中可能用的并不多。<br>它的使用还是比较简单的。</p>
<h1 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h1><p>下面以一个保存短信示例来演示一下AsyncTask的使用。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-d910a0c137b90175.gif?imageMogr2/auto-orient/strip" alt="AsyncTask备份短信.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    private TextView tv_desc;</span><br><span class="line">    private ProgressBar progressBar;</span><br><span class="line">    private Button btn_backup;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv_desc = (TextView) findViewById(R.id.tv_desc);</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progressBar);</span><br><span class="line">        btn_backup = (Button) findViewById(R.id.btn_backup);</span><br><span class="line">        btn_backup.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                // new AsyncTask&lt;输入值, 进度, 处理结果&gt;;</span><br><span class="line">                new AsyncTask&lt;Void, Integer, Void&gt;() &#123;</span><br><span class="line">                    private int processCount = 0;</span><br><span class="line"></span><br><span class="line">                    //在子线程运行的方法</span><br><span class="line">                    @Override</span><br><span class="line">                    protected Void doInBackground(Void... params) &#123;</span><br><span class="line">                        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                            SystemClock.sleep(500);</span><br><span class="line">                            processCount++;</span><br><span class="line">                            //传递给onProgressUpdate</span><br><span class="line">                            //当然也可以直接用全局变量processCount</span><br><span class="line">                            publishProgress(processCount);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onPreExecute() &#123;</span><br><span class="line">                        //初始化数据</span><br><span class="line">                        progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">                        progressBar.setMax(100);</span><br><span class="line">                        progressBar.setProgress(0);</span><br><span class="line">                        tv_desc.setText(&quot;正在备份0/20条短信&quot;);</span><br><span class="line">                        btn_backup.setEnabled(false);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onPostExecute(Void aVoid) &#123;</span><br><span class="line">                        progressBar.setVisibility(View.GONE);</span><br><span class="line">                        tv_desc.setText(&quot;共备份了20条短信&quot;);</span><br><span class="line">                        btn_backup.setEnabled(true);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">                        System.out.println(values[0]);</span><br><span class="line">                        int num = values[0];</span><br><span class="line">                        progressBar.setProgress(num * 100 / 20);</span><br><span class="line">                        tv_desc.setText(&quot;正在备份&quot; + num + &quot;/20条短信&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AsyncTask需要注意的地方"><a href="#AsyncTask需要注意的地方" class="headerlink" title="AsyncTask需要注意的地方"></a>AsyncTask需要注意的地方</h3><p>AsyncTask算是应用了模板方法设计模式，具体的调用流程都已经封装好了，子类只需要重写一些必须的回调方法就可以轻松的完成任务了。</p>
<p>AsyncTask有四个比较重要的方法doInBackground、onPreExecute、onPostExecute、onProgressUpdate，虽然这些方法都标了有注解，比如WorkerThread是在工作线程调用，MainThread是在主线程中调用，但是这个实际上只是一个规则，如果你不按照这个规则来，程序运行也不会crash。这4个方法都是protected的，因此不能直接在AsyncTask的外部直接调用，doInBackground方法是必须要重写的，而其它3个方法需要结合实际看是都需要重写。另外如果你需要在AsyncTask中回调onProgressUpdate方法，需要自己在doInBackground中自己主动调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doInBackground // WorkerThread，抽象方法，需要重写</span><br><span class="line">onPreExecute // MainThread</span><br><span class="line">onPostExecute // MainThread</span><br><span class="line">onProgressUpdate // MainThread</span><br><span class="line"></span><br><span class="line">publishProgress // 开发者在doInBackground中主动调用，然后AsyncTask的onProgressUpdate方法会被回调。</span><br></pre></td></tr></table></figure>
<p>AsyncTask在每个版本都会有一些关键地方的变化，所以需要注意一些事项：</p>
<p>我们使用AsyncTask，一般是想在子线程中做耗时操作，然后把结果发送到主线程中，既然涉及到线程切换，那必须有Handler机制来保证。而且要必须保证Handler所关联的Looper对象已经创建，而且这个Looper是在主线程中创建。<br>这也就引出了AsyncTask类的加载实际和对象的初始化问题。</p>
<ol>
<li><p>AsyncTask类的加载线程问题。AsyncTask 类中有一个InternalHandler（也就是一个Handler）类型的类成员 sHandler，AsyncTask是使用sHandler对象来做线程切换。 在6.0以前（包括6.0），InternalHandler只有一个无参构造，因此sHandler引用所指向的InternalHandler对象必须在主线程中创建，因为只有主线程默认情况下已经创建了Looper对象。从Andorid4.1到Android5.0，sHandler的创建时饿汉式，也就是说当AsyncTask类加载的时候就会创建InternalHandler对象，为了保证InternalHandler是在主线程中创建，必须保证AsyncTask是在主线程中加载。当一个App进程启动的时候，在ActivityThread的main方法中会调用AsyncTask的的类方法init，这会触发AsyncTask类的加载，也就保证了AsyncTask是在主线程中加载的，继而保证了在主线程中创建InternalHandler对象，进而保证任务结果正常的切换到主线程。</p>
<p> 6.0的时候已经没有init方法了，但是有一个静态方法getHandler，这个时候InternalHandler的创建时属于懒汉式。此时InternalHandler同样能保证关联的Looper是主线程，因为InternalHandler在无参构造方法中，调用了super，传递了Looper.getMainLooper()。所以在6.0的时候没有必要再去管是不是在主线程中加载了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static Handler getHandler() &#123;</span><br><span class="line">    synchronized (AsyncTask.class) &#123;</span><br><span class="line">        if (sHandler == null) &#123;</span><br><span class="line">            sHandler = new InternalHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>到8.0之后，AysncTask的构造方法变为3个，不过对于开发者来说只能看到1个，另外两个是隐藏的API。所以可以认为和6.0、7.0的使用情况是一样的。InternalHandler还是懒加载创建。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">    this((Looper) null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public AsyncTask(@Nullable Handler handler) &#123;</span><br><span class="line">    this(handler != null ? handler.getLooper() : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>一些博客或者书籍里说，AsyncTask对象必须是在主线程中创建，并在主线程中调用其execute方法。这个说法并不完全准确。你真要是想在子线程中去创建AsyncTask对象并在子线程中去调用其execute方法，这个也没什么问题的。只不过通常来说，我们是为了让AsyncTask在子线程中做耗时操作，在主线程中回调进度方法并且收到结果回调，而且通常还有一个onPreExecute方法来做一些初始化的工作，这个onPreExecute方法是在execute方法中调用的，通常我们需要onPreExecute在主线程中回调，从这个角度上来说，AsyncTask对象应该是在主线程中创建并且在主线程中执行其execute方法。</p>
</li>
<li><p>不要在AsyncTask之外直接调用doInBackground、onPreExecute、onPostExecute 、onProgressUpdate ，这几个方法是有AsyncTask对象自己内部回调的。</p>
</li>
<li><p>AsyncTask只能执行一次，其内部有一个枚举类型的Status用于维护执行状态：PENDING、RUNNING、FINISHED。默认情况下是PENDING，表示可以执行，当调用execute方法之后，会检查其状态是否是PENDING，如果不是的话就会抛出异常。</p>
</li>
<li><p>在1.6之前AsyncTask是串行执行任务的，1.6的时候改为线程池并行执行任务，3.0之后为了防止并发执行错误，又改为了默认情况是的串行执行任务，不过添加了executeOnExecutor方法，通过由开发者自己提供Executor来实现并行执行任务。这种方式算是依赖注入的方式，符合设计模式中的里氏替换原则（Liskov Substitution principle），从这我们也可以看出依赖注入的好处，当目前的实现不满足开发者使用的时候可以由开发者自己来实现，解耦而且扩展性好。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/Android进程保活招数概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/Android进程保活招数概览/" itemprop="url">Android进程保活招数概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T09:36:00+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中的进程保活应该分为两个方面：</p>
<ul>
<li>提高进程的优先级，减少被系统杀死的可能性</li>
<li>在进程已经被杀死的情况下，通过一些手段来重新启动应用进程</li>
</ul>
<p>本文针对这两方面来进程阐述，并给出相应的示例。其实主要也是在前人的基础上做了一个总结，并进行了一些实践。</p>
<blockquote>
<p>阅读本文的时候，可以先clone一份代码 <a href="https://github.com/sososeen09/android-process-daemon" target="_blank" rel="noopener">android-process-daemon</a>，这样的话可能理解更清晰。</p>
</blockquote>
<h1 id="进程等级与Low-Memory-Killer"><a href="#进程等级与Low-Memory-Killer" class="headerlink" title="进程等级与Low Memory Killer"></a>进程等级与Low Memory Killer</h1><p>在开始之前，首先有必要了解一下进程等级的概念。Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会对进程进行分类。 需要时，系统会首先消除重要性最低的进程，然后是清除重要性稍低一级的进程，依此类推，以回收系统资源。</p>
<p>进程等级：</p>
<ul>
<li><p>前台进程</p>
<ul>
<li>与用户正在交互的Activity</li>
<li>前台Activity以bind方式启动的Service</li>
<li>Service调用了startForground，绑定了Notification</li>
<li>正在执行生命周期的Service，例如在执行onCreate、onStart、onDestory</li>
<li>正在执行onReceive方法的BroadcastReceiver</li>
</ul>
</li>
<li><p>可见进程</p>
<ul>
<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>
<li>托管绑定到可见（或前台）Activity 的 Service。</li>
</ul>
</li>
<li><p>服务进程<br>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
</li>
<li><p>后台进程<br>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p>
</li>
<li><p>空进程<br>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
</li>
</ul>
<p>进程等级参考谷歌官方文档 <a href="https://developer.android.google.cn/guide/components/processes-and-threads.html?hl=zh-cn。" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/processes-and-threads.html?hl=zh-cn。</a></p>
<p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫 Low Memory Killer，它是一种根据 OOM_ADJ 阈值级别触发相应力度的内存回收的机制。</p>
<p>关于 OOM_ADJ 的说明如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-12de25557189a20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自——腾讯Bugly干货分享】Android 进程保活招式大全.png"></p>
<p>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在Low Memory Killer 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p>
<p>Android 手机中进程被杀死可能有如下情况：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-56c4b4339858dfa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自——腾讯Bugly干货分享】Android 进程保活招式大全.png"></p>
<p>所以，想要应用降低被杀死的可能性就要尽量提高进程的优先级，这样才会在系统内存不足的时候减少被杀死的可能性。在这里，我们只是说减少被杀死的可能性，而不是说一定不会杀死。除了系统应用，或者厂商白名单中的应用，一般的应用都有被杀死的可能性。</p>
<p>我们可以通过adb命令来查看进程的优先级<br>首先使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | grep  packageName</span><br></pre></td></tr></table></figure>
<p>获取进程的PID，然后使用命令获取进程的oom_adj值，这个值越小，代表优先级越高越不容易被杀死：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/PID/oom_adj</span><br></pre></td></tr></table></figure>
<p>比如，先获取adb进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># adb shell ps |grep com.sososeen09.process</span><br><span class="line">u0_a85    1740  486  1013428 64840 00000000 f7491e65 S com.sososeen09.process.daemon.sample</span><br></pre></td></tr></table></figure>
<p>然后获取oom_adj值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># adb shell cat /proc/1740/oom_adj</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>此时该进程运行在前台，它的优先级为0，这种情况下被杀死的可能性很小。当通过Home键把当前引用退回后台的时候，重新查看一下oom_adj，这个值可能会变为6（不同的rom情况可能不一样）。</p>
<h1 id="提升进程优先级"><a href="#提升进程优先级" class="headerlink" title="提升进程优先级"></a>提升进程优先级</h1><h2 id="利用Activity提升权限"><a href="#利用Activity提升权限" class="headerlink" title="利用Activity提升权限"></a>利用Activity提升权限</h2><p>前面我们也讲了，当应用切换后后台的时候进程的优先级变得很低，被杀死的可能性就增大了。如果此时用户通过电源键进行息屏了。可以考虑通过监听息屏和解锁的广播，在息屏的时候启动一个只有一个像素的Activity。这样的话，在息屏这段时间，应用的进程优先级很高，不容易被杀死。采用这种方案要注意的是要使用户无感知。</p>
<p>该方案主要解决第三方应用及系统管理工具在检测到锁屏事件后一段时间（一般为5分钟以内）内会杀死后台进程，已达到省电的目的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class KeepLiveActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;KeepLiveActivity&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        Log.e(TAG,&quot;start Keep app activity&quot;);</span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        //设置这个act 左上角</span><br><span class="line">        window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line">        //宽 高都为1</span><br><span class="line">        WindowManager.LayoutParams attributes = window.getAttributes();</span><br><span class="line">        attributes.width = 1;</span><br><span class="line">        attributes.height = 1;</span><br><span class="line">        attributes.x = 0;</span><br><span class="line">        attributes.y = 0;</span><br><span class="line">        window.setAttributes(attributes);</span><br><span class="line"></span><br><span class="line">        KeepLiveManager.getInstance().setKeep(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        Log.e(TAG,&quot;stop keep app activity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让无用无感知，Activity要设置的小（只有一个像素），无背景并且是透明的。此外还要注意一点，需要设置Activity的taskAffinity 属性，要与我们的应用默认的taskAffinity不同，否则当这个Activity启动的时候，会把我们的应用所在的任务栈移动到前台，当屏幕解锁之后，会发现我们的应用移动到前台了。而用户在息屏的时候明明已经把我们的应用切换到后台了，这会给用户造成困扰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.keepliveactivity.KeepLiveActivity&quot;</span><br><span class="line">    android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:finishOnTaskLaunch=&quot;false&quot;</span><br><span class="line">    android:taskAffinity=&quot;com.sososeen09.daemon.keep.live&quot;</span><br><span class="line">    android:theme=&quot;@style/KeepLiveTheme&quot; /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;KeepLiveTheme&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>要有一个BroadcastReceiver，用于监听屏幕的点亮和关闭的广播，在这里我们使用了<code>Intent.ACTION_USER_PRESENT</code>这个action，它会早于系统发出的<code>Intent.ACTION_SCREEN_OFF</code> 广播。这样可以更早的结束之前息屏的时候启动的Activity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class KeepLiveReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    private static final String TAG = &quot;KeepLiveReceiver&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        Log.e(TAG, &quot;receive action:&quot; + action);</span><br><span class="line">        //屏幕关闭事件</span><br><span class="line">        if (TextUtils.equals(action, Intent.ACTION_SCREEN_OFF)) &#123;</span><br><span class="line">            //关屏 开启1px activity</span><br><span class="line">            KeepLiveManager.getInstance().startKeepLiveActivity(context);</span><br><span class="line">            // 解锁事件</span><br><span class="line">        &#125; else if (TextUtils.equals(action, Intent.ACTION_USER_PRESENT)) &#123;</span><br><span class="line">            KeepLiveManager.getInstance().finishKeepLiveActivity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeepLiveManager.getInstance().startKeepLiveService(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Service绑定一个Notification的方式："><a href="#Service绑定一个Notification的方式：" class="headerlink" title="Service绑定一个Notification的方式："></a>Service绑定一个Notification的方式：</h2><p>应用启动一个Service，并且Service通过调用startForeground方法来绑定一个前台的通知时，可以有效的提升进程的优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    NotificationCompat.Builder builder = new NotificationCompat.Builder(this);</span><br><span class="line">    builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">    builder.setContentTitle(&quot;Foreground&quot;);</span><br><span class="line">    builder.setContentText(&quot;I am a foreground service&quot;);</span><br><span class="line">    builder.setContentInfo(&quot;Content Info&quot;);</span><br><span class="line">    builder.setWhen(System.currentTimeMillis());</span><br><span class="line">    Intent activityIntent = new Intent(this, MainActivity.class);</span><br><span class="line">    PendingIntent pendingIntent = PendingIntent.getActivity(this, 1, activityIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    builder.setContentIntent(pendingIntent);</span><br><span class="line">    Notification notification = builder.build();</span><br><span class="line">    startForeground(FOREGROUND_ID, notification);</span><br><span class="line">    return super.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的话会在通知栏显示一个通知，该方式属于比较文明的。</p>
<p>我们可以使用 命令来查看当前正在运行的服务信息，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services com.sososeen09.process</span><br></pre></td></tr></table></figure>
<p>可以得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ACTIVITY MANAGER SERVICES (dumpsys activity services)</span><br><span class="line">  User 0 active services:</span><br><span class="line">  * ServiceRecord&#123;d18c80d u0 com.sososeen09.process.daemon.sample/.service.WhiteService&#125;</span><br><span class="line">    intent=&#123;cmp=com.sososeen09.process.daemon.sample/.service.WhiteService&#125;</span><br><span class="line">    packageName=com.sososeen09.process.daemon.sample</span><br><span class="line">    processName=com.sososeen09.process.daemon.sample:white</span><br><span class="line">    baseDir=/data/app/com.sososeen09.process.daemon.sample-2/base.apk</span><br><span class="line">    dataDir=/data/data/com.sososeen09.process.daemon.sample</span><br><span class="line">    app=ProcessRecord&#123;696d809 2478:com.sososeen09.process.daemon.sample:white/u0a85&#125;</span><br><span class="line">    isForeground=true foregroundId=1001 foregroundNoti=Notification(pri=0 contentView=com.sososeen09.process.daemon.sample/0x1090077 vibrate=null sound=null defaults=0x0 flags=0x62 color=0x00000000 vis=PRIVATE)</span><br><span class="line">    createTime=-44s879ms startingBgTimeout=--</span><br><span class="line">    lastActivity=-44s860ms restartTime=-44s860ms createdFromFg=true</span><br><span class="line">    startRequested=true delayedStop=false stopIfKilled=false callStart=true lastStartId=1</span><br><span class="line"></span><br><span class="line">  * ServiceRecord&#123;e4782a4 u0 com.sososeen09.process.daemon.sample/.service.NormalService&#125;</span><br><span class="line">    intent=&#123;cmp=com.sososeen09.process.daemon.sample/.service.NormalService&#125;</span><br><span class="line">    packageName=com.sososeen09.process.daemon.sample</span><br><span class="line">    processName=com.sososeen09.process.daemon.sample:normal</span><br><span class="line">    baseDir=/data/app/com.sososeen09.process.daemon.sample-2/base.apk</span><br><span class="line">    dataDir=/data/data/com.sososeen09.process.daemon.sample</span><br><span class="line">    app=ProcessRecord&#123;2402ea0e 2459:com.sososeen09.process.daemon.sample:normal/u0a85&#125;</span><br><span class="line">    createTime=-48s510ms startingBgTimeout=--</span><br><span class="line">    lastActivity=-48s479ms restartTime=-48s479ms createdFromFg=true</span><br><span class="line">    startRequested=true delayedStop=false stopIfKilled=false callStart=true lastStartId=1</span><br><span class="line"></span><br><span class="line">  Connection bindings to services:</span><br><span class="line">  * ConnectionRecord&#123;3b4eb582 u0 CR DEAD com.sososeen09.process.daemon.sample/.acount.AuthenticationService:@2a1598cd&#125;</span><br><span class="line">    binding=AppBindRecord&#123;d621c2f com.sososeen09.process.daemon.sample/.acount.AuthenticationService:system&#125;</span><br><span class="line">    conn=android.app.LoadedApk$ServiceDispatcher$InnerConnection@2a1598cd flags=0x1</span><br></pre></td></tr></table></figure>
<p>可以看到，调用了startForeground方法的Service是一个前台进程了，有一个属性是isForeground=true。</p>
<p>在这种情况下，当应用所在进程退回到后台时，oom_adj的值为1，不容易被杀死。</p>
<h2 id="隐藏Notification的Service"><a href="#隐藏Notification的Service" class="headerlink" title="隐藏Notification的Service"></a>隐藏Notification的Service</h2><p>前面讲的startForeground，会在通知栏中显示一个通知。有一种方式利用了系统漏洞，把通知栏给隐藏，让用户无感知。不过这种方式跟版本有关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Notification notification = new Notification();</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; 18) &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">            // start InnerService</span><br><span class="line">            startService(new Intent(this, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在InnerService中关闭Notification</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    try &#123;</span><br><span class="line">        startForeground(NOTIFICATION_ID, new Notification());</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    stopSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们可以发现，在Tinker中，由于在Patch的过程是在另一个服务进程中，为了保证这个服务进程不被干掉，Tinker也利用了这个系统的漏洞。具体可以查看<a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java" target="_blank" rel="noopener">TinkerPatchService</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-22f9de159b910a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tinker中Service进程保活.png"></p>
<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>上面讲了提升进程优先级的方式了来减少应用被杀死的可能性，但是当应用真的被杀死的时候，我们就要想办法来拉活进行了。</p>
<h2 id="利用广播拉活"><a href="#利用广播拉活" class="headerlink" title="利用广播拉活"></a>利用广播拉活</h2><p>这个在推送中比较常见，当几个App都集成了同一家的推送，只要有一个App起来，就会发送一个广播，这样其它的App接收到这个广播之后，开启一个服务，就把进程给启动起来了。各大厂家的全家桶也是这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class WakeReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1001;</span><br><span class="line">    public final static String ACTION_WAKE = &quot;com.sososeen09.wake&quot;;</span><br><span class="line">    private final static String TAG = &quot;WakeReceiver&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        if (action != null &amp;&amp; action.equals(ACTION_WAKE)) &#123;</span><br><span class="line">            context.startService(new Intent(context, WakeService.class));</span><br><span class="line"></span><br><span class="line">            Log.e(TAG, &quot;onReceive: &quot; + &quot;收到广播，兄弟们要起来了。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class WakeService extends Service &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Notification notification = new Notification();</span><br><span class="line">                if (Build.VERSION.SDK_INT &lt; 18) &#123;</span><br><span class="line">                    startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">                    // start InnerService</span><br><span class="line">                    startService(new Intent(this, WakeInnerService.class));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, &quot;onReceive: &quot; + &quot;我是 WakeService，我起来了，谢谢兄弟。。。&quot; + ProcessUtils.getProcessName(this));</span><br><span class="line">            return super.onStartCommand(intent, flags, startId);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class WakeInnerService extends Service &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCreate() &#123;</span><br><span class="line">            super.onCreate();</span><br><span class="line">            try &#123;</span><br><span class="line">                startForeground(NOTIFICATION_ID, new Notification());</span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onDestroy() &#123;</span><br><span class="line">            stopForeground(true);</span><br><span class="line">            super.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也可以监听系统的广播来达到启动应用进程的方式，但是从android 7.0开始，对广播进行了限制，而且在8.0更加严格<a href="https://developer.android.google.cn/about/versions/oreo/background.html#broadcasts" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background.html#broadcasts</a></p>
<p>可静态注册广播列表：<br><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>
<h2 id="系统Service机制拉活"><a href="#系统Service机制拉活" class="headerlink" title="系统Service机制拉活"></a>系统Service机制拉活</h2><p>将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活。</p>
<ul>
<li>START_STICKY：<br>  “粘性”。如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。</li>
<li>START_NOT_STICKY：<br>  “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。</li>
<li>START_REDELIVER_INTENT：<br>  重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。</li>
<li>START_STICKY_COMPATIBILITY：<br>  START_STICKY的兼容版本，但不保证服务被kill后一定能重启。<br>只要 targetSdkVersion 不小于5，就默认是 START_STICKY。<br>但是某些ROM 系统不会拉活。并且经过测试，Service 第一次被异常杀死后很快被重启，第二次会比第一次慢，第三次又会比前一次慢，一旦在短时间内 Service 被杀死4-5次，则系统不再拉起。</li>
</ul>
<h2 id="使用账户同步拉活"><a href="#使用账户同步拉活" class="headerlink" title="使用账户同步拉活"></a>使用账户同步拉活</h2><p>手机系统设置里会有“帐户”一项功能，任何第三方APP都可以通过此功能将数据在一定时间内同步到服务器中去。系统在将APP帐户同步时，会将未启动的APP进程拉活。 如何利用账户同步可以参考 <a href="https://github.com/googlesamples/android-BasicSyncAdapter" target="_blank" rel="noopener">https://github.com/googlesamples/android-BasicSyncAdapter</a></p>
<p>但是账户同步这个东西，在不同的手机上可能在同步时间不同。</p>
<p>关于这种方式，这里就不多讲了，有兴趣的可以搜索相关文章，在<a href="[https://github.com/sososeen09/android-process-daemon">示例代码</a>中也有相关的介绍。](<a href="https://github.com/sososeen09/android-process-daemon)中也有相关的介绍。" target="_blank" rel="noopener">https://github.com/sososeen09/android-process-daemon)中也有相关的介绍。</a>)</p>
<h2 id="使用JobSchedule拉活"><a href="#使用JobSchedule拉活" class="headerlink" title="使用JobSchedule拉活"></a>使用JobSchedule拉活</h2><p>JobScheduler允许在特定状态与特定时间间隔周期执行任务。可以利用它的这个特点完成保活的功能，效果类似开启一个定时器，与普通定时器不同的是其调度由系统完成。它是在Android5.0之后推出的，在5.0之前无法使用。</p>
<p>首先写一个Service类继承自JobService，在小于7.0的系统上，JobInfo可以周期性的执行，但是在7.0以上的系统上，不能周期性的执行了。因此可以在JobService的onStartJob回调方法中继续开启一个任务来执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public class MyJobService extends JobService &#123;</span><br><span class="line">    private static final String TAG = &quot;MyJobService&quot;;</span><br><span class="line"></span><br><span class="line">    public static void startJob(Context context) &#123;</span><br><span class="line">        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line"></span><br><span class="line">        JobInfo.Builder builder = new JobInfo.Builder(10, new ComponentName(context.getPackageName(), MyJobService.class.getName())).setPersisted(true);</span><br><span class="line"></span><br><span class="line">        //小于7.0</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">            // 每隔1s 执行一次 job</span><br><span class="line">            builder.setPeriodic(1_000);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //延迟执行任务</span><br><span class="line">            builder.setMinimumLatency(1_000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (jobScheduler != null) &#123;</span><br><span class="line">            jobScheduler.schedule(builder.build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(JobParameters params) &#123;</span><br><span class="line">        Log.e(TAG, &quot;start job schedule&quot;);</span><br><span class="line">        //如果7.0以上 轮训</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">            startJob(this);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters params) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AndroidManifest.xml并需要声明权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.jobschedule.MyJobService&quot;</span><br><span class="line">    android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>不过在某些ROM可能并不能达到需要的效果(某米)</p>
<h2 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h2><p>我们都直到Service可以以bind方式启动，当Service被系统杀死的时候，会在ServiceConnection的onServiceDisconnected方法中会收到回调。利用这个原理，可以在主进程中进行有一个LocalService，在子进程中有RemoteService。LocalService中以bind和start方式启动RemoteService，同时RemoteService以bind和start方式启动LocalService。并且在它们各自的ServiceConnection的onServiceDisconnected方法中重新bind和start。</p>
<p>这种Java层通过Service这种双进程守护的方式，可以有效的保证进程的存活能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LocalService extends Service &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1003;</span><br><span class="line">    private static final String TAG = &quot;LocalService&quot;;</span><br><span class="line">    private ServiceConnection serviceConnection;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        serviceConnection = new LocalServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class LocalServiceConnection implements ServiceConnection &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            //服务连接后回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.e(TAG, &quot;remote service died，make it alive&quot;);</span><br><span class="line">            //连接中断后回调</span><br><span class="line">            startService(new Intent(LocalService.this, RemoteService.class));</span><br><span class="line">            bindService(new Intent(LocalService.this, RemoteService.class), serviceConnection,</span><br><span class="line">                    BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyBinder extends IMyAidlInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RemoteService也类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteService extends Service &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1002;</span><br><span class="line">    private static final String TAG = &quot;RemoteService&quot;;</span><br><span class="line">    private ServiceConnection serviceConnection;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        serviceConnection = new RemoteServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RemoteServiceConnection implements ServiceConnection &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            //服务连接后回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.e(TAG, &quot;main process local service died，make it alive&quot;);</span><br><span class="line">            //连接中断后回调</span><br><span class="line">            startService(new Intent(RemoteService.this, LocalService.class));</span><br><span class="line">            bindService(new Intent(RemoteService.this, LocalService.class), serviceConnection,</span><br><span class="line">                    BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyBinder extends IMyAidlInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了提高Service所在进程的优先级，可以结合我们之前讲的startForground来开启一个Notification的方式，提高进程的优先级，以降低被杀风险。</p>
<h2 id="其它方式拉活"><a href="#其它方式拉活" class="headerlink" title="其它方式拉活"></a>其它方式拉活</h2><p>其它我们还可以使用推送拉活，根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送，这样也可以保证进程可以被推送唤醒。</p>
<p>Native拉活，Native fork子进程用于观察当前app主进程的存亡状态。这种在5.0以前的系统上效果比较高，对于5.0以上成功率极低。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>提升进程优先级的方式</p>
<ul>
<li><p>Activity提权，监听屏幕的息屏和解锁，使用一个1个像素的Activity</p>
</li>
<li><p>Service提权，Service通过startForground方法来开启一个Notification</p>
</li>
</ul>
<p>进程拉活</p>
<ul>
<li><p>通过广播的方式</p>
</li>
<li><p>通过Service在onStartCommand的返回值，START_STICK，由系统拉活，在短时间内如果多次被杀死可能就再也启动不了了</p>
</li>
<li><p>通过账户同步拉活</p>
</li>
<li><p>通过JobSchedule拉活</p>
</li>
<li><p>通过Service的bind启动的方式，双进程守护拉活</p>
</li>
<li><p>推送拉活</p>
</li>
<li><p>Native fork子进程的方式拉活</p>
</li>
</ul>
<blockquote>
<p>更多详情，请查看 <a href="https://github.com/sososeen09/android-process-daemon" target="_blank" rel="noopener">android-process-daemon</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background#broadcasts" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background#broadcasts</a></li>
<li><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></li>
<li><a href="https://github.com/googlesamples/android-BasicSyncAdapter" target="_blank" rel="noopener">https://github.com/googlesamples/android-BasicSyncAdapter</a></li>
<li><a href="https://segmentfault.com/a/1190000006251859" target="_blank" rel="noopener">【腾讯Bugly干货分享】Android 进程保活招式大全</a></li>
<li><a href="https://www.jianshu.com/p/63aafe3c12af" target="_blank" rel="noopener">关于 Android 进程保活，你所需要知道的一切</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/14/Android四大组件——ContentProvider的工作过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/Android四大组件——ContentProvider的工作过程/" itemprop="url">Android四大组件——ContentProvider的工作过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T13:02:00+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ContentProvider是内容提供者，对外提供数据。内部运行依赖Binde机制。想要自己写一个ContentProvider向外部提供数据，需要继承ContentProvider并重写一下六个方法，在ContentProvider中提供了增删改查的方法，一般这个增删改查会通过SqliteDataBase这个数据库的方式对外提供增删改查的功能。也可以不这么做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onCreate() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public String getType(@NonNull Uri uri) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在AndroidManifest.xml中去注册：<br>authorities 相当于是个地址<br>permission 用于控制权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;.provider.BookProvider&quot;</span><br><span class="line">    android:authorities=&quot;com.sososeen09.knowledge.provider.book&quot;</span><br><span class="line">    android:permission=&quot;com.sososeen09.PROVIDER&quot;</span><br><span class="line">    android:process=&quot;:provider&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>其它客户端查询，需要用到ContentResolver对象，ContentResolver是抽象类，它的实现是ContextImpl中的ApplicationContentResolver，是在ContextImpl的构造方法中创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uri bookUri = Uri.parse(&quot;content://com.sososeen09.knowledge.provider.book/book&quot;);</span><br><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;_id&quot;, 6);</span><br><span class="line">getContentResolver().insert(bookUri, values);</span><br><span class="line">Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);</span><br></pre></td></tr></table></figure>
<p>Context的getContentResolver方法实际上获取的就是ContextImpl的ApplicationContentResolver类型的成员mContentResolver。</p>
<p>当ContentProvider所在进程还未创建时，第一次访问ContentProvider会触发ContentProvider所在进程的创建和ContentProvider对象的创建。通过ContentProvider的4个方法中的任何一个都会触发ContentProvider的启动过程。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们分析<code>getContentResolver().query</code> 方法触发的流程。</p>
<p>ContextWrapper的getContentResolver的方法如下，还是通过mBase来获取，这个mBase实际上是ContextImpl对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return mBase.getContentResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下ContextImpl的getContentResolver方法，直接返回了一个成员变量mContentResolver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return mContentResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mContentResolver实际上是ContentResolver的子类ApplicationContentResolver，该对象是在ContextImpl的构造方法中创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private ContextImpl(ContextImpl container, ActivityThread mainThread,</span><br><span class="line">                    LoadedApk packageInfo, IBinder activityToken, UserHandle user, int flags,</span><br><span class="line">                    Display display, Configuration overrideConfiguration, int createDisplayWithId) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    mContentResolver = new ApplicationContentResolver(this, mainThread, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取了ContentResolver对象之后，调用它的query方法。在ContentResolver的query方法中首先会调用acquireUnstableProvider来获取一个IContentProvider对象。</p>
<p>在这里要说一下，返回值是IContentProvider对象，它继承自IInterface，也就是说它的实现类会是一个Binder对象。这也是因此ContentProvider不是一个Binder对象，而且一般ContentProvider和客户端不再同一个进程中。它的增删改查方法的结果肯定是需要一个通过一个Binder对象来进行IPC过程的传输。在这里就是IContentProvider。在这里它的实现是ContentProviderNative的子类ContentProvider.Transport。ContentProvider.Transport对象运行在ContentProvider的同一个进程，在远程有个特代理是ContentProviderProxy。</p>
<p>acquireUnstableProvider方法由ApplicationContentResolver实现，在ApplicationContentResolver中还有一个重写的方法是acquireProvider，它们都是做一个中转，调用的是ActivityThread的acquireProvider方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final IContentProvider acquireProvider(</span><br><span class="line">        Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // There is a possible race here.  Another thread may try to acquire</span><br><span class="line">    // the same provider at the same time.  When this happens, we want to ensure</span><br><span class="line">    // that the first one wins.</span><br><span class="line">    // Note that we cannot hold the lock while acquiring and installing the</span><br><span class="line">    // provider since it might take a long time to run and it could also potentially</span><br><span class="line">    // be re-entrant in the case where the provider is in the same process.</span><br><span class="line">    IActivityManager.ContentProviderHolder holder = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Install provider will increment the reference count for us, and break</span><br><span class="line">    // any ties in the race.</span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            true /*noisy*/, holder.noReleaseNeeded, stable);</span><br><span class="line">    return holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它首先调用acquireExistingProvider，查看是否有缓存的IContentProvider对象，如果有的话就直接返回这个缓存对象。缓存存放在mProviderMap这个Map集合中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// The lock of mProviderMap protects the following variables.</span><br><span class="line">final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class="line">        = new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure>
<p>如果当前没有缓存的话，就需要通过一个IPC过程调用AMS的getContentProvider方法来获取一个ContentProviderHolder，ContentProviderHolder实现了Parcelable接口，因此它可以被进程间传递，它就是客户端的ContentProvider的一个代理对象的包装类。之后调用installProvider方法还要修改ContentProvider的引用计数器。</p>
<p>AMS的getContentProvider方法又会调用getContentProviderImpl方法，在该方法中会判断所要请求的ContentProvider进程是否已经存在，如果不存在的话就会调用startProcessLocked方法来创建ContentProvider的进程并安装ContentProvider。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private ContentProviderHolder getContentProviderImpl(IApplicationThread caller,</span><br><span class="line">                                                     String name, IBinder token, boolean stable, int userId) &#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = null;</span><br><span class="line">    ProviderInfo cpi = null;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ProcessRecord r = null;</span><br><span class="line">      ...</span><br><span class="line">        boolean checkCrossUser = true;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: getProviderByName&quot;);</span><br><span class="line"></span><br><span class="line">        // First check if this content provider has been published...</span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">        // If that didn&apos;t work, check if it exists for user 0 and then</span><br><span class="line">        // verify that it&apos;s a singleton provider before using it.</span><br><span class="line">   ...</span><br><span class="line">        boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed;</span><br><span class="line">   ...</span><br><span class="line">        if (!providerRunning) &#123;</span><br><span class="line">            ...</span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, false);</span><br><span class="line">                    if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                           </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, false, 0, &quot;content provider&quot;,</span><br><span class="line">                                new ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                        cpi.name), false, false, false);</span><br><span class="line">                       ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">    return cpr != null ? cpr.newHolder(conn) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法可以看出，如果ContentProvider没有在运行，而且它所在的进程没有存在的话就会调用AMS自身的startProcessLocked方法来创建进程。AMS的startProcessLocked会调用Process的start方法，在该方法表明所要启动一个新进程，并且调用android.app.ActivityThread的main方法作为入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">                                      String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">  ...</span><br><span class="line">        // Start the process.  It will either succeed and return a result containing</span><br><span class="line">        // the PID of the new process, or else throw a RuntimeException.</span><br><span class="line">        boolean isActivityProcess = (entryPoint == null);</span><br><span class="line">        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line">     ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>App进程启动的流程如下，这里我们就不细讲了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2083810-dc58c61994176d36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="App进程启动的流程.png"></p>
<p>最终ActivityThread的main方法会被调用，该方法中会创建ActivityThread对象，并创建主线程的Looper对象，调用ActivityThread的attach方法，并且传递的参数为false，表明不是系统进程。之后就开始消息循环了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityThread的attach方法中，会通过一个IPC过程调用AMS的attachApplication方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">    ...</span><br><span class="line">        final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        try &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS的attachApplication方法又会调用其attachApplicationLocked方法，在该方法中又会通过IPC过程调用ApplicationThread的bindApplication方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                                  List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                                  ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                                  IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                                  IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                                  boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">                                  boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">                                  CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">    if (services != null) &#123;</span><br><span class="line">        // Setup the service cache in the ServiceManager</span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppBindData是一个JavaBean独享，用于ActivityThreadThread绑定的App的信息。<br>ApplicationThread的bindApplication方法是在Binder线程池中执行，因此通过一个Handler发送<br>H.BIND_APPLICATION消息切换到主线程。在Handler H的handleMessage方法中会从msg中取出AppBindData对象，并且调用ActivityThread的handleBindApplication方法。</p>
<p>在这里面做了5步操作：</p>
<ol>
<li>创建ContextImpl对象</li>
<li>创建Instrumentation对象</li>
<li>创建Application对象</li>
<li>调用<code>installContentProviders(app, data.providers)</code>方法启动当前进程的ContentProvider并调用其onCreate方法</li>
<li>调用Application的onCreate方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    // If the app is Honeycomb MR1 or earlier, switch its AsyncTask</span><br><span class="line">    // implementation to use the pool executor.  Normally, we use the</span><br><span class="line">    // serialized executor as the default. This has to happen in the</span><br><span class="line">    // main thread so the main looper is set right.</span><br><span class="line">    if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    // Instrumentation info affects the class loader, so load it before</span><br><span class="line">    // setting up the app context.</span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    if (data.instrumentationName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ii = new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ii = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1 创建 ContextImpl对象</span><br><span class="line">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">...</span><br><span class="line">    // 2 创建Instrumentation对象</span><br><span class="line">    // Continue loading instrumentation.</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        final ApplicationInfo instrApp = new ApplicationInfo();</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), false, true, false);</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                            + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ComponentName component = new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation = new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...// 3 创建 Applcation对象</span><br><span class="line">    try &#123;</span><br><span class="line">        // If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">        // a restricted environment with the base application class.</span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        // don&apos;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">        // app&apos;s custom Application class</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 4 启动当前进程的ContentProvider，并调用其方法</span><br><span class="line">        if (!data.restrictedBackupMode) &#123;</span><br><span class="line">            if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">                // For process that contains content providers, we want to</span><br><span class="line">                // ensure that the JIT is enabled &quot;at some point&quot;.</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">        // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">...     // 5 调用Application的onCreate方法</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下ActivityThread的installContentProviders方法。在该方法中主要遍历当前进程的ProviderInfo信息，通过调用installProvider方法来构建一个IActivityManager.ContentProviderHolder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void installContentProviders(</span><br><span class="line">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">            new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    for (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        if (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = new StringBuilder(128);</span><br><span class="line">            buf.append(&quot;Pub &quot;);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(&quot;: &quot;);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</span><br><span class="line">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</span><br><span class="line">        if (cph != null) &#123;</span><br><span class="line">            cph.noReleaseNeeded = true;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们之前说的吗，ContentProvider对象是无法跨进程调用的，因此需要一个Binder对象用于给客户端使用。ContentProviderHolder实现了Pacelable接口，可以在进程间传递数据。它实际上就是一个JavaBean对象，但是里面封装了IContentProvider，它实际上会作为一个Binder对象用于进程间方法的调用。我们前面也已经提了。IContentProvider的实现是ContentProviderNative的子类ContentProvider.Transport。ContentProvider.Transport对象运行在ContentProvider的同一个进程，在远程有个特代理是ContentProviderProxy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static class ContentProviderHolder implements Parcelable &#123;</span><br><span class="line">    public final ProviderInfo info;</span><br><span class="line">    public IContentProvider provider;</span><br><span class="line">    public IBinder connection;</span><br><span class="line">    public boolean noReleaseNeeded;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下ActivityThread的installProvider方法，可以看到首先通过类加载器创建了ContentProvider对象，然后调用了ContentProvider的attachInfo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private IActivityManager.ContentProviderHolder installProvider(Context context,</span><br><span class="line">                                                               IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">                                                               boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">    ContentProvider localProvider = null;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    if (holder == null || holder.provider == null) &#123;</span><br><span class="line">       ...</span><br><span class="line">        Context c = null;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">        if (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; else if (mInitialApplication != null &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            localProvider = (ContentProvider)cl.</span><br><span class="line">                    loadClass(info.name).newInstance();</span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">...</span><br><span class="line">            // XXX Need to create the correct context for this provider.</span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line">        &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        provider = holder.provider;</span><br><span class="line">        if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Installing external provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                + info.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">    return retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一下ContentProvider的attachInfo方法，该方法会调用3个参数的重载方法，在该方法中调用了ContextProvider的onCreate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123;</span><br><span class="line">    mNoPerms = testing;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Only allow it to be set once, so after the content service gives</span><br><span class="line">     * this to us clients can&apos;t change it.</span><br><span class="line">     */</span><br><span class="line">    if (mContext == null) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        if (context != null) &#123;</span><br><span class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                    Context.APP_OPS_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mMyUid = Process.myUid();</span><br><span class="line">        if (info != null) &#123;</span><br><span class="line">            setReadPermission(info.readPermission);</span><br><span class="line">            setWritePermission(info.writePermission);</span><br><span class="line">            setPathPermissions(info.pathPermissions);</span><br><span class="line">            mExported = info.exported;</span><br><span class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0;</span><br><span class="line">            setAuthorities(info.authority);</span><br><span class="line">        &#125;</span><br><span class="line">        ContentProvider.this.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面的分析可知，ContentProvider的onCreate方法是在Application的onCreate方法之前调用的。当然了，还是要晚于Application的attachBaseContext方法。</p>
<p>ContentProvider创建完毕并启动之后还没有完事，会通过一个IPC过程调用AMS的publishContentProviders方法，此时传递ApplicationThread对象和创建完毕的ContentProviderHolder集合。publishContentProviders方法中也即是在AMS端存一下ContentProvider的记录，这里就不再细说了。</p>
<p>到此，ContentProvider所在的进程已经创建完毕，并且ContentProvider也已经全部启动起来。但是还没有完，调起ContentResolver发起query方法的那边还在等着返回结果呢。回到ContentResolver的query方法。注意此时客户端获取的IContentProvider对象是ContentProviderProxy，它是ContentProviderNative的内部类，通过IPC过程调用到ContentProviderNative.ContentProvider.Transport中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContentResolver</span><br><span class="line">public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,</span><br><span class="line">                                    @Nullable String[] projection, @Nullable String selection,</span><br><span class="line">                                    @Nullable String[] selectionArgs, @Nullable String sortOrder,</span><br><span class="line">                                    @Nullable CancellationSignal cancellationSignal) &#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, &quot;uri&quot;);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    if (unstableProvider == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = null;</span><br><span class="line">    Cursor qCursor = null;</span><br><span class="line">    try &#123;</span><br><span class="line">  ...</span><br><span class="line">        try &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">            // The remote process has died...  but we only hold an unstable</span><br><span class="line">            // reference though, so we might recover!!!  Let&apos;s try!!!!</span><br><span class="line">            // This is exciting!!1!!1!!!!1</span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            if (stableProvider == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (qCursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Force query execution.  Might fail and throw a runtime exception here.</span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        long durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);</span><br><span class="line"></span><br><span class="line">        // Wrap the cursor object into CursorWrapperInner object.</span><br><span class="line">        final IContentProvider provider = (stableProvider != null) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = null;</span><br><span class="line">        qCursor = null;</span><br><span class="line">        return wrapper;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下ContentProvider.Transport的query方法，由于ContentProvider.Transport是非静态内部类，因此持有ContentProvider的引用，所以内部调用了ContentProvider的query方法的返回值，返回的结果也会通过一个IPC过程返回到调用者那里。ContentProvider对外提供数据的方法，query、insert、delete、update方法也都是通过Transport进行调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContentProvider.Transport</span><br><span class="line">@Override</span><br><span class="line">public Cursor query(String callingPkg, Uri uri, String[] projection,</span><br><span class="line">                    String selection, String[] selectionArgs, String sortOrder,</span><br><span class="line">                    ICancellationSignal cancellationSignal) &#123;</span><br><span class="line">    validateIncomingUri(uri);</span><br><span class="line">    uri = getUriWithoutUserId(uri);</span><br><span class="line">    if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        // The caller has no access to the data, so return an empty cursor with</span><br><span class="line">        // the columns in the requested order. The caller may ask for an invalid</span><br><span class="line">        // column and we would not catch that but this is not a problem in practice.</span><br><span class="line">        // We do not call ContentProvider#query with a modified where clause since</span><br><span class="line">        // the implementation is not guaranteed to be backed by a SQL database, hence</span><br><span class="line">        // it may not handle properly the tautology where clause we would have created.</span><br><span class="line">        if (projection != null) &#123;</span><br><span class="line">            return new MatrixCursor(projection, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Null projection means all columns but we have no idea which they are.</span><br><span class="line">        // However, the caller may be expecting to access them my index. Hence,</span><br><span class="line">        // we have to execute the query as if allowed to get a cursor with the</span><br><span class="line">        // columns. We then use the column names to return an empty cursor.</span><br><span class="line">        Cursor cursor = ContentProvider.this.query(uri, projection, selection,</span><br><span class="line">                selectionArgs, sortOrder, CancellationSignal.fromTransport(</span><br><span class="line">                        cancellationSignal));</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Return an empty cursor for all columns.</span><br><span class="line">        return new MatrixCursor(cursor.getColumnNames(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    final String original = setCallingPackage(callingPkg);</span><br><span class="line">    try &#123;</span><br><span class="line">        return ContentProvider.this.query(</span><br><span class="line">                uri, projection, selection, selectionArgs, sortOrder,</span><br><span class="line">                CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        setCallingPackage(original);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>访问一个ContentProvider需要用到ContentResolver对象，它是一个抽象类，实际上用的是它的实现类ContextImpl的ApplicationContentResolver。</p>
</li>
<li><p>访问ContextProvider时一个IPC过程，由于ContentProvider不能跨进程访问。调用ContentResolver的query等方法首先需要从AMS端获取一个ContextProvider的代理对象，这个代理对象实现了IContentProvider接口，它用于代理远端的Binder对象ContextProvider.Trasnport。ContextProvider.Trasnport继承自ContentProviderNative，ContentProviderNative实现了IContentProvider接口。通过ContextProvider.Trasnport的本地代理对象，可以调用ContextProvider.Trasnport的query方法，Trasnport是ContextProvider的内部类，持有ContextProvider的引用，它再去调用ContextProvider的方法并通过IPC过程返回结果。</p>
</li>
<li><p>第一次访问ContentProvider的时候，如果它还没有创建，AMS会通过startProcessLock方法调用Process的start方法，通过Zygote去fork一个进程之后调用ActivityThread的main方法，在main方法中创建ActivityThread对象，并调用其attach方法，在此过程创建了Instrumentation对象、Application对象，并创建该进程中对应的ContentProvider并调用其onCreate方法，此后调用Application的onCreate方法，因此ContentProvider的onCreate方法早于Application的onCreate方法执行，这也是四大组件中唯一一个比较特别的。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/Android四大组件——BroadCastReceiver的工作过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Android四大组件——BroadCastReceiver的工作过程/" itemprop="url">Android四大组件——BroadCastReceiver的工作过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T15:30:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>BroadCastReceiver的工作过程分为包含两方面的内容：</p>
<ol>
<li>注册</li>
<li>发送和接收</li>
</ol>
<p>使用BroadcastReceiver很简单，只需要继承BroadcastReceiver并重写它的onReceive方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使BroadcastReceiver工作，就需要对它进程注册。注册BroadCastReceiver分为在AndroidManifest.xml静态注册和代码中动态注册。</p>
<p>静态注册示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.sososeen.09.demo.my.receiver&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>动态注册也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">intentFilter.addAction(&quot;com.sososeen.09.demo.my.receiver&quot;);</span><br><span class="line">registerReceiver(new MyReceiver(), intentFilter);</span><br></pre></td></tr></table></figure>
<p>不过动态注册别忘了反注册，否则会造成内存泄漏。</p>
<p>发送广播示例如下，通过给Intent设置action，对应的广播接收者的onReveive就会被回调了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(&quot;com.sososeen.09.demo.my.receiver&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
<p>注册广播和发送广播中间过程是怎么进行的，我们今天就来分析一下。由于静态注册牵涉到在应用安装时有系统自动完成注册，确切的说是通过PackageManagerService完成注册，相对比较复杂。今天先来分析一下动态注册的BroadCastReceiver的工作过程。</p>
<p>在本文的分析中，ActivityManagerService简称AMS。</p>
<h1 id="动态注册BroadCastReceiver"><a href="#动态注册BroadCastReceiver" class="headerlink" title="动态注册BroadCastReceiver"></a>动态注册BroadCastReceiver</h1><p>注册广播接收者是通过ContextWrapper来进行的，但是类似启动Service，真正干事的还是ContextImpl，我们直接来看它的方法。2个参数的registerReceiver方法，会调用4个参数的registerReceiver方法，然后会调用registerReceiverInternal方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">    return registerReceiver(receiver, filter, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">                               String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    return registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在registerReceiverInternal方法中主要干了两件事：</p>
<ol>
<li><p>mPackageInfo指的是LoadedApk对象，通过调用LoadedApk的getReceiverDispatcher方法把BroadcastReceiver包装为ReceiverDispatcher.InnerReceiver对象，这是因为BroadcastReceiver是不具有跨进程通信能力的，想要最终调用到BroadcastReceiver的onReceive方法，必须有一个Binder对象用来进行IPC，在这里就是ReceiverDispatcher.InnerReceiver对象。InnerReceiver对象持有ReceiverDispatcher对象的引用。当AMS端调用InnerReceiver的接收广播的方法，InnerReceiver对象会找到对应的ReceiverDispatcher进而找到BroadcastReceiver对象并调用其onReceive方法。这个过程我们后面再分析。这种方式与bind方式启动Service的中包装ServiceConnection是类似的，有兴趣的可以看一下<a href="https://www.jianshu.com/p/bce3b49a3af6" target="_blank" rel="noopener">Android四大组件——Service的工作过程分析</a>。</p>
</li>
<li><p>ActivityManagerNative.getDefault()获取的是AMS在本地的代理，该代理通过IPC过程调用AMS的registerReceiver方法。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">                                        IntentFilter filter, String broadcastPermission,</span><br><span class="line">                                        Handler scheduler, Context context) &#123;</span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            // 1 创建ReceiverDispatcher.InnerReceiver对象</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler,</span><br><span class="line">                    mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 2 IPC过程调用AMS的registerReceiver方法</span><br><span class="line">        final Intent intent = ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看一下LoadedApk的getReceiverDispatcher方法，就是创建一个ReceiverDispatcher对象并将其保存起来，在ReceiverDispatcher的构造方法中创建InnerReceiver对象，ReceiverDispatcher对象中保存了BroadcastReceiver和InnerReceiver对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">                                             Context context, Handler handler,</span><br><span class="line">                                             Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span><br><span class="line">        if (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            if (map != null) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rd == null) &#123;</span><br><span class="line">            rd = new ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line">            if (registered) &#123;</span><br><span class="line">                if (map == null) &#123;</span><br><span class="line">                    map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        rd.mForgotten = false;</span><br><span class="line">        return rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下AMS的registerReceiver方法，该方法很长，我们选取一些关键的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">                               IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;registerReceiver&quot;);</span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = null;</span><br><span class="line">    ProcessRecord callerApp = null;</span><br><span class="line">      ...</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        if (rl == null) &#123;</span><br><span class="line">            rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            if (rl.app != null) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    return sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = true;</span><br><span class="line">            &#125;</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId);</span><br><span class="line">        rl.add(bf);</span><br><span class="line">       ...</span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中 mRegisteredReceivers 是一个HashMap对象，用于追踪客户端BroadcastReceiver对应的ReceiverDispatcher.InnerReceiver对象。ReceiverList是一个ArrayList集合，用于存放BroadcastFilter，BroadcastFilter用于包装IntentFilter。我们需要知道一点，同一个BroadcastReceiver是可以对应多个IntentFilter的，只要匹配一个就能够接收消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： BroadcastFilter中封装了ReceiverList对象，而ReceiverList对象中包含了客户端BroadcastReceiver对应的IIntentReceiver对象（实际上就是ReceiverDispatcher.InnerReceiver对象），将来在发送广播的阶段，通过Intent找到所有匹配到的动态注册的BroadcastFilter集合。</p>
</blockquote>
<p>到此，BroadcastReceiver的动态注册过程就完毕了。</p>
<h1 id="广播的发送和接收过程"><a href="#广播的发送和接收过程" class="headerlink" title="广播的发送和接收过程"></a>广播的发送和接收过程</h1><p>广播的发送分为普通广播、有序广播和粘性广播。有序广播是按照广播接收者的优先级，从高优先级到低优先级依次接收，而且在高优先级的广播接收者中是可以打断广播，造成低优先级的广播接收不到。而粘性广播表示想要当发送广播的时候，BroadcastReceiver还没有创建，当BroadcastReceiver创建后，它的onReveive方法会被立即调用。</p>
<p>在这里我们分析一下普通广播的发送和接收流程。</p>
<p>调用Context的方法发送广播，实际上还是会调用ContextImpl的方法，来一下ContextImpl的sendBroadcast方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个过程中看，通过一个IPC过程调用到AMS的broadcastIntent方法，在该方法又调用了AMS的broadcastIntentLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">                                 Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">                                 int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">                                 String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">                                 boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        int res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != null ? callerApp.info.packageName : null,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>broadcastIntentLocked方法非常长，我们尽量选取一些关键的地方来分析，在方法的开始会有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intent = new Intent(intent);</span><br><span class="line"></span><br><span class="line">// By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br></pre></td></tr></table></figure>
<p>表示会重新创建一个Intent对象用于包裹传递过来的的Intent对象，并且为Intent添加了一个flag，Intent.FLAG_EXCLUDE_STOPPED_PACKAGES，表示默认情况下广播不会发送给已经停止运行的App，这也是为了方式一些App想要利用广播来启动进程。</p>
<p>从Android3.1开始，添加了两个标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 表示不包含已经停止的应用，如果广播设置这个标记，就不会发送给已经停止的应用</span><br><span class="line">public static final int FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;</span><br><span class="line"> </span><br><span class="line">// 表示包含已经停止的应用，如果广播设置这个标记，就会发送给已经停止的应用</span><br><span class="line">public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;</span><br></pre></td></tr></table></figure>
<p>从Android 3.1开始，默认情况下都是添加一个FLAG_EXCLUDE_STOPPED_PACKAGES标记，表示不会发送给停止的应用，如果确实需要的话，需要给广播显式的设置FLAG_INCLUDE_STOPPED_PACKAGES标记。</p>
<p>在broadcastIntentLocked内部，会根据IntentFilter查找出匹配的BroadcastReceiver，经过一系列条件的筛选和过滤，将满足条件的接收者放在BroadcastQueue中，接下来BroadcastQueue就会将广播发送出去。注意在这个过程中会先把找出来的动态注册的广播发出去，然后再把静态注册的广播发出去。因此，动态注册的广播优先级是高于静态注册的广播的。而且，如果BroadcastReceiver同时注册了静态广播和动态广播，其onReceive方法会被调用两次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">        || resultTo != null) &#123;</span><br><span class="line">    BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line"></span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</span><br><span class="line">            + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">            &quot;Enqueueing broadcast &quot; + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">    if (!replaced) &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>BroadcastQueue发送广播的实现如下，通过Handler发送一个BROADCAST_INTENT_MSG类型的消息，Handler收到消息之后会调用BroadcastQueue的processNextBroadcast方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">            + mQueueName + &quot;]: current=&quot;</span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    if (mBroadcastsScheduled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BroadcastQueue的processNextBroadcast方法很长，我们选取发送普通广播的部分来看，可以看到无序广播存放在mParallelBroadcasts集合中，通过遍历这个集合来发送广播给BroadcastReceiver。具体的发送过程是deliverToRegisteredReceiverLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">       ...</span><br><span class="line">        // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">        while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(0);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            final int N = r.receivers.size();</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">            for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</span><br><span class="line">                                + target + &quot;: &quot; + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下BroadcastQueue的deliverToRegisteredReceiverLocked方法，该方法负责将一个特定的广播发送给特定的接收者，具体的发送过程是调用了performReceiveLocked方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                        new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br></pre></td></tr></table></figure>
<p>来看一下performReceiveLocked方法，app.thread指的就是ApplicationThread在本地的代理对象，app.thread != null 条件满足，会通过IPC过程调用ApplicationThread的scheduleRegisteredReceiver方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.BroadcastQueue</span><br><span class="line"></span><br><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">                          Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">                          boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">            // If we have an app thread, do the call through that so it is</span><br><span class="line">            // correctly ordered with other one-way calls.</span><br><span class="line">            try &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">              ...</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Application has died. Receiver doesn&apos;t exist.</span><br><span class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ApplicationThread的scheduleRegisteredReceiver方法中调用了receiver的performReceive方法，而这个receiver我们知道，实际上就是ReceiverDispatcher.InnerReceiver对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">                                       int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">                                       boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下ReceiverDispatcher.InnerReceiver对象的performReceive方法，在该方法中首先获取InnerReceiver持有的ReceiverDispatcher对象，如果ReceiverDispatcher对象不为空的话就会调用它的performReceive方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher.InnerReceiver</span><br><span class="line">@Override</span><br><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                           Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">        rd = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    if (rd != null) &#123;</span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ReceiverDispatcher的performReceive方法中，会封装一个Args对象，Args是ReceiverDispatcher的非静态内部类，因此持有ReceiverDispatcher的引用，可以访问ReceiverDispatcher的参数和方法，并且它实现了Runnable接口。mActivityThread是一个Handler，通过post方法，把调用切换到主线程中来，Args的run方法会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher</span><br><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                           Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final Args args = new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (intent == null || !mActivityThread.post(args)) &#123;</span><br><span class="line">        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing sync broadcast to &quot; + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Args的run方法如下，最后会调用BroadcastReceiver的onReceive方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher.Args</span><br><span class="line">public void run() &#123;</span><br><span class="line">    final BroadcastReceiver receiver = mReceiver;</span><br><span class="line">...</span><br><span class="line">    ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">    intent.setExtrasClassLoader(cl);</span><br><span class="line">    intent.prepareToEnterProcess();</span><br><span class="line">    setExtrasClassLoader(cl);</span><br><span class="line">    receiver.setPendingResult(this);</span><br><span class="line">    receiver.onReceive(mContext, intent);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，广播的发送和接收过程也分析完毕了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>注册广播的时候是把BroadcastReceiver封装到ReceiverDispatcher中，并且把与此对应的ReceiverDispatcher.InnerReceiver作为一个Binder对象传递到AMS端，AMS端会通过一个Map集合来存放ReceiverDispatcher.InnerReceiver对象和对应的IntentFilter包装类。</p>
</li>
<li><p>发送广播的时候，通过一个IPC过程调用到AMS端，AMS端会找到匹配的广播接收者并添加到BroadcastQueue中，在BroadcastQueue中进程处理之后通过一个IPC过程调用到ApplicationThread的scheduleRegisteredReceiver方法，然后会调用ReceiverDispatcher.InnerReceiver的方法，再经过ReceiverDispatcher、以及它的内部类Args，最终调用到BroadcastReceiver的onReveive方法。</p>
</li>
<li><p>动态注册的广播优先级是高于静态注册的广播的。而且，如果BroadcastReceiver同时注册了静态广播和动态广播，其onReceive方法会被调用两次。</p>
</li>
<li><p>从过程中也可以看到，AMS端如果想要与客户端打交道的话都是通过ApplicationThread。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
