<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android Gradle Plugin打包Apk过程中的Transform API</title>
      <link href="/2018/07/12/Android%20Gradle%20Plugin%E6%89%93%E5%8C%85Apk%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84Transform%20API/"/>
      <url>/2018/07/12/Android%20Gradle%20Plugin%E6%89%93%E5%8C%85Apk%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84Transform%20API/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文以com.android.tools.build:gradle:3.1.2 源码来进行分析，文章对应的项目地址：<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>。</p></blockquote><p>Transform API 是在1.5.0-beta1版开始使用，利用Transform API，第三方的插件可以在.class文件转为dex文件之前，对一些.class 文件进行处理。Transform API 简化了这个处理过程，而且使用起来很灵活。</p><h1 id="使用Transform-API"><a href="#使用Transform-API" class="headerlink" title="使用Transform API"></a>使用Transform API</h1><p>使用Transform API主要是写一个类继承Transform，并把该Transform注入到打包过程中。<br>注入Transform很简单，先获取<code>com.android.build.gradle.AppExtension</code>对象，然后调用它的registerTransform()方法。<br>这个方法实际上是属于BaseExtension的，AppExtension继承自BaseExtension。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#com.android.build.gradle.BaseExtension</span><br><span class="line">public void registerTransform(@NonNull Transform transform, Object... dependencies) &#123;</span><br><span class="line">    transforms.add(transform);</span><br><span class="line">    transformDependencies.add(Arrays.asList(dependencies));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入Transform对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AppExtension android = project.extensions.getByType(AppExtension)</span><br><span class="line">android.registerTransform(new AJXTransform(project))</span><br></pre></td></tr></table></figure><p>AJXTransform是自定义的Transform类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">lass AJXTransform extends Transform &#123;</span><br><span class="line">    Project project</span><br><span class="line">    AJXTransform(Project project) &#123;</span><br><span class="line">        this.project = project</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;ajx&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        // 输入类型，可以使class文件，也可以是源码文件 ，这是表示输入的class文件</span><br><span class="line">        return ImmutableSet.&lt;QualifiedContent.ContentType&gt; of(QualifiedContent.DefaultContentType.CLASSES)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        // 作用范围</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        //是否支持增量编译</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        //在这里对输入输出的class进行处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContentType是一个接口，默认有一个枚举类型DefaultContentType实现了ContentType，包含有CLASSES和RESOURCES类型。</p><ul><li>CLASSES类型表示的是在jar包或者文件夹中的.class文件。</li><li>RESOURCES类型表示的是标准的Java源文件。</li></ul><p>Scope 作用范围</p><table><thead><tr><th>Scope类型</th><th>说明</th></tr></thead><tbody><tr><td>PROJECT</td><td>只处理当前的项目</td></tr><tr><td>SUB_PROJECTS</td><td>只处理子项目</td></tr><tr><td>EXTERNAL_LIBRARIES</td><td>只处理外部的依赖库</td></tr><tr><td>TESTED_CODE</td><td>只处理测试代码</td></tr><tr><td>PROVIDED_ONLY</td><td>只处理provided-only的依赖库</td></tr><tr><td>PROJECT_LOCAL_DEPS</td><td>只处理当前项目的本地依赖,例如jar, aar（过期，被EXTERNAL_LIBRARIES替代）</td></tr><tr><td>SUB_PROJECTS_LOCAL_DEPS</td><td>只处理子项目的本地依赖,例如jar, aar（过期，被EXTERNAL_LIBRARIES替代）</td></tr></tbody></table><p>Transform中的getInputTypes()方法和getScopes() 方法返回的是Set集合，因此这些类型是可以进行组合的。在<code>com.android.build.gradle.internal.pipeline.TransformManager</code>中就包含了多种Set集合。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-09a2feedc88f88b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TransformManager.png"></p><p>Transform 的 <code>isIncremental()</code> 方法表示是否支持增量编译，返回true的话表示支持，这个时候可以根据 <code>com.android.build.api.transform.TransformInput</code> 来获得更改、移除或者添加的文件目录或者jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface TransformInput &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a collection of &#123;@link JarInput&#125;.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;JarInput&gt; getJarInputs();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a collection of &#123;@link DirectoryInput&#125;.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;DirectoryInput&gt; getDirectoryInputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JarInput有一个方法是<code>getStatus()</code>来获取 <code>com.android.build.api.transform.Status</code>。Status是一个枚举类，包含了NOTCHANGED、ADDED、CHANGED、REMOVED，所以可以根据JarInput的status来对它进行相应的处理，比如添加或者移除。</p><p>DirectoryInput有一个方法<code>getChangedFiles()</code>开获取一个Map<file, status="">集合，所以可以遍历这个Map集合，然后根据File对应的Status来对File进行处理。</file,></p><p>如果不支持增量编译，就在处理.class之前把之前的输出目录中的文件删除。</p><p>获取TransformInput对象是根据 <code>com.android.build.api.transform.TransformInvocation</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface TransformInvocation &#123;</span><br><span class="line">// 返回transform运行的上下文，在android gradle plugin中有唯一的实现类TransformTask</span><br><span class="line">    @NonNull</span><br><span class="line">    Context getContext();</span><br><span class="line"></span><br><span class="line">// 获取transform的输入</span><br><span class="line">    @NonNull</span><br><span class="line">    Collection&lt;TransformInput&gt; getInputs();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the referenced-only inputs which are not consumed by this transformation.</span><br><span class="line">     * @return the referenced-only inputs.</span><br><span class="line">     */</span><br><span class="line">    @NonNull Collection&lt;TransformInput&gt; getReferencedInputs();</span><br><span class="line">    /**</span><br><span class="line">     * Returns the list of secondary file changes since last. Only secondary files that this</span><br><span class="line">     * transform can handle incrementally will be part of this change set.</span><br><span class="line">     * @return the list of changes impacting a &#123;@link SecondaryInput&#125;</span><br><span class="line">     */</span><br><span class="line">    @NonNull Collection&lt;SecondaryInput&gt; getSecondaryInputs();</span><br><span class="line"></span><br><span class="line">//TransformOutputProvider用于删除输出目录或者创建文件对应的生成目录</span><br><span class="line">    @Nullable</span><br><span class="line">    TransformOutputProvider getOutputProvider();</span><br><span class="line"></span><br><span class="line">// transform过程是否支持增量编译</span><br><span class="line">    boolean isIncremental();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransformInvocation包含了输入、输出相关信息。其输出相关内容是由TransformOutputProvider来做处理。TransformOutputProvider的getContentLocation()方法可以获取文件的输出目录，如果目录存在的话直接返回，如果不存在就会重新创建一个。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// getContentLocation方法相当于创建一个对应名称表示的目录</span><br><span class="line">// 是从0 、1、2开始递增。如果是目录，名称就是对应的数字，如果是jar包就类似0.jar</span><br><span class="line">File outputDir = transformInvocation.outputProvider.getContentLocation(&quot;include&quot;, </span><br><span class="line">         dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)</span><br><span class="line"></span><br><span class="line">File outputJar = transformInvocation.outputProvider.getContentLocation(jarInput.name</span><br><span class="line">        , jarInput.contentTypes</span><br><span class="line">        , jarInput.scopes</span><br><span class="line">        , Format.JAR)</span><br></pre></td></tr></table></figure><p>在执行编译过程中会生成对应的目录，例如在/app/build/intermediates/transforms目录下生成了一个名为<code>ajx</code>的目录，这个名称就是根据自定义的Transform类<code>getName()</code>方法返回的字符串来的。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-c5cb7d8fcabd333d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transforms下的ajx目录.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-7fa9504bbe5ff237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="transforms下的ajx中内容.png"></p><p>ajx目录下还会有一个名为<code>__content__</code>的.json文件。该文件中展示了ajx中文件目录下的内容</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-7e4d4360b0ffb331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其实当你注入一个自定义的Transform的时候还会生成对应的Task，即TransformTask，该Task还会有一个对应的名称，例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-a422dfd4590b410f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TransformTask名称.png"></p><p>这个名称生成过程是在 TransformManager 的 <code>addTransform()</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Transform&gt; Optional&lt;TransformTask&gt; addTransform(</span><br><span class="line">            @NonNull TaskFactory taskFactory,</span><br><span class="line">            @NonNull TransformVariantScope scope,</span><br><span class="line">            @NonNull T transform,</span><br><span class="line">            @Nullable TransformTask.ConfigActionCallback&lt;T&gt; callback) &#123;</span><br><span class="line">...</span><br><span class="line">        String taskName = scope.getTaskName(getTaskNamePrefix(transform));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static String getTaskNamePrefix(@NonNull Transform transform) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder(100);</span><br><span class="line">    sb.append(&quot;transform&quot;);</span><br><span class="line"></span><br><span class="line">    sb.append(</span><br><span class="line">            transform</span><br><span class="line">                    .getInputTypes()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(</span><br><span class="line">                            inputType -&gt;</span><br><span class="line">                                    CaseFormat.UPPER_UNDERSCORE.to(</span><br><span class="line">                                            CaseFormat.UPPER_CAMEL, inputType.name()))</span><br><span class="line">                    .sorted() // Keep the order stable.</span><br><span class="line">                    .collect(Collectors.joining(&quot;And&quot;)));</span><br><span class="line">    sb.append(&quot;With&quot;);</span><br><span class="line">    StringHelper.appendCapitalized(sb, transform.getName());</span><br><span class="line">    sb.append(&quot;For&quot;);</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Transform中，其<code>transform()</code> 方法是重头戏，需要对输入的文件进行处理，然后放到输出目录中。</p><p>例如，我在<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>中就是自定义一个Transform子类，然后在transform过程把输入的目录中的.class文件或者jar包中的.class 文件使用aspectj进行处理。如果对aspectj不太了解的，可以查看我之前写的一篇文章：<a href="https://www.jianshu.com/p/c66f4e3113b3" target="_blank" rel="noopener">AOP开发——AspectJ的使用</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">    TransformTask transformTask = (TransformTask) transformInvocation.context</span><br><span class="line">    //VariantCache 就是保存一些跟当前variant相关的一些缓存，以及在支持增量编译的情况下存储一些信息</span><br><span class="line">    VariantCache variantCache = new VariantCache(ajxProcedure.project, ajxProcedure.ajxCache, transformTask.variantName)</span><br><span class="line"></span><br><span class="line">    if (transformInvocation.isIncremental()) &#123;</span><br><span class="line">        //TODO 增量</span><br><span class="line">        print(&quot;====================增量编译=================&quot;)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        print(&quot;====================非增量编译=================&quot;)</span><br><span class="line">        //非增量,需要删除输出目录</span><br><span class="line">        transformInvocation.outputProvider.deleteAll()</span><br><span class="line">        variantCache.reset()</span><br><span class="line"></span><br><span class="line">        AJXFileProcess ajxFileProcess = new AJXFileProcess(project, variantCache, transformInvocation)</span><br><span class="line">        ajxFileProcess.proceed()</span><br><span class="line">        AJXTaskProcess ajxTaskProcess = new AJXTaskProcess(project, variantCache, transformInvocation)</span><br><span class="line">        ajxTaskProcess.proceed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transform中的transform-方法是如何被执行的"><a href="#Transform中的transform-方法是如何被执行的" class="headerlink" title="Transform中的transform()方法是如何被执行的"></a>Transform中的transform()方法是如何被执行的</h1><p>我们在前面讲到的调用<code>android.registerTransform(transform)</code>注册方法，实际上只是把Transform对象放到了一个List集合中。那么什么时候用到这个集合呢？也就是说Transform的transform()方法是什么时候被执行的呢？</p><p>在这里可以先告诉你答案，Transform的transform()方法是在TransformTask的transform()方法中执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># com.android.build.gradle.internal.pipeline.TransformTask</span><br><span class="line">@TaskAction</span><br><span class="line">void transform(final IncrementalTaskInputs incrementalTaskInputs)</span><br><span class="line">        throws IOException, TransformException, InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    recorder.record(</span><br><span class="line">            ExecutionType.TASK_TRANSFORM,</span><br><span class="line">            executionInfo,</span><br><span class="line">            getProject().getPath(),</span><br><span class="line">            getVariantName(),</span><br><span class="line">            new Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Void call() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">                    transform.transform(</span><br><span class="line">                            new TransformInvocationBuilder(TransformTask.this)</span><br><span class="line">                                    .addInputs(consumedInputs.getValue())</span><br><span class="line">                                    .addReferencedInputs(referencedInputs.getValue())</span><br><span class="line">                                    .addSecondaryInputs(changedSecondaryInputs.getValue())</span><br><span class="line">                                    .addOutputProvider(</span><br><span class="line">                                            outputStream != null</span><br><span class="line">                                                    ? outputStream.asOutput()</span><br><span class="line">                                                    : null)</span><br><span class="line">                                    .setIncrementalMode(isIncremental.getValue())</span><br><span class="line">                                    .build());</span><br><span class="line"></span><br><span class="line">                    if (outputStream != null) &#123;</span><br><span class="line">                        outputStream.save();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上每个Transform都会有一个对应的TransformTask，TransformTask本质上就是表示Gradle中的一个Task，那么一个Task在执行的时候其<code>@TaskAction</code>注解的方法会被执行，也就是<code>com.android.build.gradle.internal.pipeline.TransformTask#transform()</code>方法会被执行，在该方法中会调用该TransformTask对应的Transform对象的transform()方法。</p><p>写过Gradle插件的都知道，在build.gradle中apply 插件后其apply(project)方法就会调用。例如我们在一个app中应用的是<code>apply plugin: &#39;com.andorid.application&#39;</code> ，这个实际上引入的就是AppPlugin，其apply()方法会被调用。关于这个源码过程我们就不多说了，我们只讲一个这个过程，感兴趣的可以查看文章末尾的相关文章。</p><p>-&gt;com.android.build.gradle.BasePlugin#apply()<br>-&gt;com.android.build.gradle.BasePlugin#createTasks()<br>-&gt;com.android.build.gradle.BasePlugin#createAndroidTasks()<br>-&gt;com.android.build.gradle.internal.VariantManager#createAndroidTasks()<br>-&gt;com.android.build.gradle.internal.VariantManager#createTasksForVariantData()<br>-&gt;com.android.build.gradle.internal.ApplicationTaskManager#createTasksForVariantScope() <strong>//该方法中干的事很多，可以重点关注</strong><br>-&gt;com.android.build.gradle.internal.ApplicationTaskManager#addCompileTask()<br>-&gt;com.android.build.gradle.internal.TaskManager#createPostCompilationTasks() <strong>//在这个方法中会调用AppExtension的getTransforms()方法，也就是我们之前注册的transform</strong><br>-&gt; com.android.build.gradle.internal.pipeline.TransformManager#addTransform() <strong>//在这个方法中创建了TransformTask</strong></p><p>在上面的这些流程中TaskManager的<strong>createPostCompilationTasks()</strong>需要重点关注，在该方法中对Apk打包过程中的各种Transform进行处理，创建对应了TransformTask并构建隐式的依赖关系。</p><p>到此TransformTask是创建完毕，TransformTask相当于是对我们自定义的Transform进行的包装。</p><p>那么这个TransformTask是什么时候执行呢？<br>我们可以显式地使用Gradle命令去执行一个Task，这是没问题的。但为什么我们执行<code>gradle assemble</code>命令的时候，TransformTask也会执行呢？这个就牵涉到Task的依赖关系了。假设TaskA依赖TaskB，那么如果我们要执行TaskA，那么在TaskA执行之前TaskB就会执行。但是要注意一点就是，假设TaskA依赖TaskB和TaskC，那么只能保证TaskA执行之前TaskB和TaskC都执行了，并不能保证TaskB和TaskC的执行顺序。</p><p>构建Task的依赖关系可以显式的调用其 <code>dependsOn()</code> 方法。 但是我在查看Transform API的过程中发现这个TransformTask之间并没有显式地调用<code>dependsOn()</code> 方法来保证依赖关系，难道这个TransformTask的执行顺序是任意的吗？如果是任意的，比如一个task是dexMerger是要把每个class编译成的dex合成为一个dex，而此时输入目录中还没有dex存在，该任务不就失败了吗？android gradle plugin 的开发者当然不会让这种情况存在了。</p><p>实际情况是Task除了显式地通过dependsOn来指定Task依赖，其实还可以<strong>使用Task依赖推断来判断依赖关系，Gradle通过使用一个Task的输出作为另一个Task的输入，就可以推断出依赖关系。</strong><br>在Transform API中，使用的是 TransformStream 来连接TransformTask的依赖关系，进行可以控制Transform的执行顺序。<br>计算TransformTask的输入输出是在 TransformManager 的 addTransform() 方法中。<br>通过输入输出已经隐式地确定了TransformTask的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line">public &lt;T extends Transform&gt; Optional&lt;TransformTask&gt; addTransform(</span><br><span class="line">        @NonNull TaskFactory taskFactory,</span><br><span class="line">        @NonNull TransformVariantScope scope,</span><br><span class="line">        @NonNull T transform,</span><br><span class="line">        @Nullable TransformTask.ConfigActionCallback&lt;T&gt; callback) &#123;</span><br><span class="line">...</span><br><span class="line">    List&lt;TransformStream&gt; inputStreams = Lists.newArrayList();</span><br><span class="line">    String taskName = scope.getTaskName(getTaskNamePrefix(transform));</span><br><span class="line"></span><br><span class="line">    // get referenced-only streams</span><br><span class="line">    List&lt;TransformStream&gt; referencedStreams = grabReferencedStreams(transform);</span><br><span class="line"></span><br><span class="line">    // find input streams, and compute output streams for the transform.</span><br><span class="line">    // 通过之前添加的Transform来计算输入，并计算输出</span><br><span class="line">    IntermediateStream outputStream = findTransformStreams(</span><br><span class="line">            transform,</span><br><span class="line">            scope,</span><br><span class="line">            inputStreams,</span><br><span class="line">            taskName,</span><br><span class="line">            scope.getGlobalScope().getBuildDir());</span><br><span class="line">   ...</span><br><span class="line">    transforms.add(transform);</span><br><span class="line"></span><br><span class="line">    // create the task...</span><br><span class="line">    // 在创建Task的过程中传入了输入和输出，上一个Task的输出是该Task的输入，这就保证了Task的一个隐式的依赖关系</span><br><span class="line">    TransformTask task =</span><br><span class="line">            taskFactory.create(</span><br><span class="line">                    new TransformTask.ConfigAction&lt;&gt;(</span><br><span class="line">                            scope.getFullVariantName(),</span><br><span class="line">                            taskName,</span><br><span class="line">                            transform,</span><br><span class="line">                            inputStreams,</span><br><span class="line">                            referencedStreams,</span><br><span class="line">                            outputStream,</span><br><span class="line">                            recorder,</span><br><span class="line">                            callback));</span><br><span class="line"></span><br><span class="line">    return Optional.ofNullable(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过以上分析也可以当我们自定义Plugin要注入多个Transform的时候，按照添加顺序来保证依赖关系，先添加的Transform先执行。对于下面的例子，transformA的<code>transform()</code>方法会先于transformB执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.registerTransform(transformA);</span><br><span class="line">android.registerTransform(transformB);</span><br></pre></td></tr></table></figure></p><h1 id="Android-Gradle-Plugin中的Transform子类"><a href="#Android-Gradle-Plugin中的Transform子类" class="headerlink" title="Android Gradle Plugin中的Transform子类"></a>Android Gradle Plugin中的Transform子类</h1><p>Android Gradle Plugin中有多个Transform子类，在编写自己的Transform类的时候可以作为一个参考。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-f076900e17578724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transform子类.png"></p><p>可以在图中看到，Google已经在使用kotlin写Gradle插件了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自定义Transform并注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TransformPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        project.android.registerTransform(new ClassTransform(project))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassTransform extends Transform &#123;</span><br></pre></td></tr></table></figure><p>Transform API的执行有顺序，每一个Transform都对应一个TransformTask和TransformStream，通过输入输出隐式的构成Task依赖关系。开发者自定义的Transform按照注册顺序执行。</p><h1 id="补充——源码调试"><a href="#补充——源码调试" class="headerlink" title="补充——源码调试"></a>补充——源码调试</h1><p>在之前的一篇文章<a href="https://www.jianshu.com/p/b86330a877db" target="_blank" rel="noopener">启用Gradle远程调试</a>中介绍了如何调试Gradle插件，实际上使用该方式也可以用来调试查看Android Gradle Plugin的执行流程。这个时候最好要找到有能下载到源码的版本，比如3.1.2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line"> ...</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.1.2&apos;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是App或者Library插件对应的类的继承关系图<br><img src="https://upload-images.jianshu.io/upload_images/2083810-96bd7e87a558f504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果你想要调试app打包过程，可以在 AppPlugin 的 <code>apply()</code> 方法中打断点。它直接调用了其父类 BasePlugin 的 <code>apply()</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#com.android.build.gradle.AppPlugin</span><br><span class="line">@Override</span><br><span class="line">public void apply(@NonNull Project project) &#123;</span><br><span class="line">    super.apply(project);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">‎New Build System‎:Transform API</a></li><li><a href="https://www.jianshu.com/p/37df81365edf" target="_blank" rel="noopener">如何理解 Transform API</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492752&amp;idx=1&amp;sn=1d1ad65c63667d96b72452a492cbde58" target="_blank" rel="noopener">Android Gradle Plugin 源码解析（上）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492778&amp;idx=1&amp;sn=bf18cd9b7e4fb5f08b1a698836807304" target="_blank" rel="noopener">Android Gradle Plugin 源码解析（下）</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP开发——AspectJ的使用</title>
      <link href="/2018/07/02/AOP%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94AspectJ%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/02/AOP%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94AspectJ%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章对应的项目地址<a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>，运行一下sample，结合代码和文章，你会收获更多。</p></blockquote><p>熟悉程序开发的都知道OOP（Object Oriented Programming ，面向对象编程），把功能封装在一个类中，使用的时候创建该类的对象，调用对象的方法或者使用其属性即可，OOP具有可重用性、灵活性和扩展性。</p><p>尽管OOP具有很多好处，但是如果在软件开发领域只使用OOP，在某些情况下也会使程序变得复杂且难以维护。例如，我们需要统计程序中点击事件的执行情况，如果我们要自己找遍代码中的点击事件，这个工程量就太大了，而且维护起来也不方便。这个时候，使用AOP的方式就会使问题变得简单。<br>AOP（Aspect Oriented Programming，面向切面编程），把某一类问题集中在一个地方进行处理，比如处理程序中的点击事件、打印日志等。</p><p>关于OOP和AOP，我觉得邓凡平老师在<a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a>中说的挺对的：</p><blockquote><p>OOP和AOP都是方法论，表示的是我们从什么角度来看待问题。OOP的精髓是把功能或问题模块化，每个模块处理自己的家务事。但在现实世界中，并不是所有功能都能完美得划分到模块中。AOP的目标是把这些功能集中起来，放到一个统一的地方来控制和管理。</p></blockquote><p>那么在Android中有哪些使用到了AOP这种思想呢？<br>在Application中有个ActivityLifecycleCallbacks接口，这个接口提供了Activity生命周期相关的方法回调。当开发者调用了Application的<code>public void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback)</code> 方法之后，就可以在ActivityLifecycleCallbacks的实现类中统一处理这些生命周期方法。这其实就是AOP思想的一种体现。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-5c897416cf40e7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityLifecycleCallbacks的AOP思想.png"></p><p>另外，我们今天的主角——AspectJ， 它是AOP编程思想的一个很火的实践。</p><h1 id="AspectJ-介绍"><a href="#AspectJ-介绍" class="headerlink" title="AspectJ 介绍"></a>AspectJ 介绍</h1><p>AspectJ是一个面向切面编程的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。AspectJ还支持原生的Java，只需要加上AspectJ提供的注解即可。在Android开发中，一般就用它提供的注解和一些简单的语法就可以实现绝大部分功能上的需求了。</p><p><strong>Join Points介绍</strong></p><p>Join Points，简称JPoints，是AspectJ中最关键的一个概念，表示的是程序运行时的一些<strong>执行点</strong>。理论上说，一个程序中很多地方都可以被看做是JPoint，但是AspectJ中，只有几种执行点被认为是JPoints，如构造方法调用、方法调用、方法执行、异常等等。JPoints实际上就是表示想把AspectJ的代码插入到程序哪个地方，是插入在方法中，还是插入在方法调用前后。需要说明的是：在AspectJ中，方法调用（call）和方法执行（execution）是不一样的，这个后面再做介绍。</p><p><strong>Pointcuts介绍</strong></p><p>一个程序会有很多的JPoints，即使是同一个函数，还分为call类型和execution类型的JPoint，但是并不是所有的JPoint都是我们需要关心的。比如我们可能只需要关心点击事件方法，那么如何从众多的JPoints中选择我们感兴趣的JPoint呢？这个时候可以用Pointcut：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void onClickMethodAround(ProceedingJoinPoint joinPoint)  &#123;&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思就是在OnClickListener.onClick()方法执行前后执行代码块中的逻辑。</p><p>所以在这里，我们可以简单的理解Pointcut的作用就是过滤JPoint。</p><p><strong>Advice介绍</strong></p><p>Advice简单来说就是表示AspectJ的hook点，在AspectJ中常用的是before、after、around等。before表示在JPoint执行之前，需要干的事情。after表示的是在JPoint执行之后，around表示的是在JPoint执行前后。</p><p><strong>Aspect介绍</strong></p><p>前面我们讲了AspectJ中使用过程中需要用到了一个概念，对于问题的处理需要统一放到一个地方去处理，这个地方就是Aspect，意为“切面”。在Java开发中主要是使用@Aspect注解来表示一个切面。</p><h1 id="Android-中使用Gradle集成-AspectJ"><a href="#Android-中使用Gradle集成-AspectJ" class="headerlink" title="Android 中使用Gradle集成 AspectJ"></a>Android 中使用Gradle集成 AspectJ</h1><p>在Android中集成AspectJ，主要思想就是hook Apk打包过程，使用AspectJ提供的工具来编译.class文件。这一点，JakeWharton 在其项目<a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">JakeWharton/hugo</a> 中演示了如何在Gradle中添加AspectJ，这为后来的人指了一条光明的道路。</p><p>一般来说，自己手动接入AspectJ的话，按照下面的指示即可。</p><p>在项目根目录build.gradle下引入aspectjtools插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ..</span><br><span class="line">        classpath &apos;org.aspectj:aspectjtools:1.8.10&apos;</span><br><span class="line">        classpath &apos;org.aspectj:aspectjweaver:1.8.8&apos;</span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行app的module目录下的build.gradle中引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.bridge.IMessage</span><br><span class="line">import org.aspectj.bridge.MessageHandler</span><br><span class="line">import org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line">final def log = project.logger</span><br><span class="line">final def variants = project.android.applicationVariants</span><br><span class="line"></span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    if (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(&quot;Skipping non-debuggable build type &apos;$&#123;variant.buildType.name&#125;&apos;.&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">        String[] args = [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                         &quot;-1.8&quot;,</span><br><span class="line">                         &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                         &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                         &quot;-bootclasspath&quot;, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug &quot;ajc args: &quot; + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = new MessageHandler(true);</span><br><span class="line">        new Main().run(args, handler);</span><br><span class="line">        for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">            switch (message.getKind()) &#123;</span><br><span class="line">                case IMessage.ABORT:</span><br><span class="line">                case IMessage.ERROR:</span><br><span class="line">                case IMessage.FAIL:</span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.WARNING:</span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.INFO:</span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">                case IMessage.DEBUG:</span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJ在运行时也需要相关的Library支持，所以还需要在项目的dependencies中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   ...</span><br><span class="line">  compile &apos;org.aspectj:aspectjrt:1.8.10&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前还有一些在Android中集成AspectJ的比较火的框架，如 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">HujiangTechnology / gradle_plugin_android_aspectjx</a>。该框架支持kotlin，我对这个框架深入研究了一番，也按照它的思想写了一个简单的gradle plugin ，收获颇多，我自己的项目地址是 <a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a>，项目中演示了如何通过AOP的方式解决统一处理登录、绑定手机号、统计方法耗时、打印点击事件日志等的逻辑，有兴趣的可以去看看，欢迎交流。</p><h1 id="AspectJ-命令常用参数介绍"><a href="#AspectJ-命令常用参数介绍" class="headerlink" title="AspectJ 命令常用参数介绍"></a>AspectJ 命令常用参数介绍</h1><p>1 <strong>-inpath:</strong> .class文件路径，可以是在jar文件中也可以是在文件目录中，路径应该包含那些AspectJ相关的文件，只有这些文件才会被AspectJ处理。输出文件会包含这些.class 。该路径就是一个单一参数，多个路径的话用分隔符隔开。</p><p>2 <strong>-classpath:</strong> 指定去哪找用户使用到的.class文件，路径可以是zip文件也可以是文件目录，该路径就是一个单一参数，多个路径的话用分隔符隔开。</p><p>3 <strong>-aspectPath:</strong> 需要被处理的切面路径，存在于jar文件或者文件目录中。在Andorid中使用的话一般指的是被@Aspect注解标示的class文件路径。需要注意的是编译版本需要与Java编译版本一致。classpath指定的路径应该包含所有的aspectpath指定的.class文件。不过默认情况下，inPath和aspectPath中的路径不一定非要放置在classPath中，因为编译器会自动处理把它们加入。路径格式与classpath和inpath样，都需要用分隔符隔开。</p><p>4 <strong>-bootClasspath: </strong> 重载跟VM相关的bootClasspath，例如在Android中使用android-27的源码进行编译。路径格式与之前一样。</p><p>5 <strong>-d:</strong>  指定由AspectJ处理后的.class文件存放目录，如果不指定的话会放置在当前的工作目录中。</p><p>6 <strong>-outjar:</strong> 指定被AspectJ处理后的jar包存放的文件目录，</p><p>更多详情请查看<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">官网</a> <a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html</a></p><h1 id="Sample—处理点击事件"><a href="#Sample—处理点击事件" class="headerlink" title="Sample—处理点击事件"></a>Sample—处理点击事件</h1><p>例如，我们需要处理项目中的所有控件的点击事件，打印控件的名称，可以使用AspectJ来简单方便的处理。在之前已经在gradle中引入的AspectJ的基础上，我们新建一个Java文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class ClickAspect &#123;</span><br><span class="line">    private static final String TAG = &quot;ClickAspect&quot;;</span><br><span class="line">    // 第一个*所在的位置表示的是返回值，*表示的是任意的返回值，</span><br><span class="line">    // onClick()中的 .. 所在位置是方法参数的位置，.. 表示的是任意类型、任意个数的参数</span><br><span class="line">    // * 表示的是通配</span><br><span class="line">    @Pointcut(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">    public void clickMethod() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;clickMethod()&quot;)</span><br><span class="line">    public void onClickMethodAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        View view = null;</span><br><span class="line">        for (Object arg : args) &#123;</span><br><span class="line">            if (arg instanceof View) &#123;</span><br><span class="line">                view = (View) arg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取View 的 string id</span><br><span class="line">        String resEntryName = null;</span><br><span class="line">        String resName = null;</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            // resEntryName: btn_activity_2  resName: com.sososeen09.aop_tech:id/btn_activity_2</span><br><span class="line">            resEntryName = view.getContext().getResources().getResourceEntryName(view.getId());</span><br><span class="line">            resName = view.getContext().getResources().getResourceName(view.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        Log.d(TAG, &quot;after onclick: &quot; + &quot;resEntryName: &quot; + resEntryName + &quot;  resName: &quot; + resName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，点击一个控件（设置了点击事件）之后，可以看到日志输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./com.sososeen09.aop_tech D/ClickAspect: after onclick: resEntryName: btn_activity_3 resName: com.sososeen09.aop_tech:id/btn_activity_3</span><br></pre></td></tr></table></figure><h1 id="切入点的语法"><a href="#切入点的语法" class="headerlink" title="切入点的语法"></a>切入点的语法</h1><p>以上面的例子来讲解：</p><ul><li>@Around：是advice，也就是具体的插入点。@Around该方法的逻辑会包含切入点前后，如果用到该注解，记得自己需要控制切入点的执行逻辑，调用<code>joinPoint.proceed()</code>。如果使用@Before注解，表示的是在切入点之前执行，@After表示在切入点之后执行，此时不需要调用<code>joinPoint.proceed()</code>。</li><li>execution：处理JPoint的类型，例如call、execution。对于<code>execution(* android.view.View.OnClickListener.onClick(..))</code>，第一个 <code>*</code> 所处的位置表示的是返回值，<code>*</code> 是通配符，表示的是任意类型。 <code>android.view.View.OnClickListener.onClick(..)</code> 表示的执行OnClickListener的onClick()方法。<code>onClick(..)</code>中的<code>..</code> 表示任意类型、任意个数的参数。</li><li>onClickMethodAround：表示的实际切入代码。这个方法名可以自己随意定义。</li></ul><p>在上面的例子中实际上我是自定义了一个PointCut，名字是<code>clickMethod()</code>。这个名称随意，只要在advice中指定好该名称就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void clickMethod() &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果不想自定义，可以直接这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(* android.view.View.OnClickListener.onClick(..))&quot;)</span><br><span class="line">public void onClickMethodAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="call和execution"><a href="#call和execution" class="headerlink" title="call和execution"></a>call和execution</h1><p>我们之前讲的切入点语法都是execution，那么如果使用call有什么区别呢？</p><p>我们再使用一个例子，创建一个切面用来打印方法的执行时间，并且只处理带有注解的参数。<br>TimeSpend 注册如下，value表示的是方法的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface TimeSpend &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用execution打印方法执行时间的切面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MethodSpendTimeAspect &#123;</span><br><span class="line">    private static final String TAG = &quot;MethodSpendTimeAspect&quot;;</span><br><span class="line">    @Pointcut(&quot;execution(@com.sososeen09.aop_tech.aspect.TimeSpend * *(..))&quot;)</span><br><span class="line">    public void methodTime() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;methodTime()&quot;)</span><br><span class="line">    public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">        String methodName = methodSignature.getName();</span><br><span class="line">        String funName = methodSignature.getMethod().getAnnotation(TimeSpend.class).value();</span><br><span class="line">        //统计时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        long duration = System.currentTimeMillis() - begin;</span><br><span class="line">        Log.e(TAG, String.format(&quot;功能：%s,%s类的%s方法执行了，用时%d ms&quot;, funName, className, methodName, duration));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始Java文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">   ...</span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        StatusHolder.sHasLogin = true;</span><br><span class="line">        Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的.class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">...</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mEmailSignInButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                LoginActivity.this.attemptLogin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        JoinPoint var1 = Factory.makeJP(ajc$tjp_0, this, this);</span><br><span class="line">        attemptLogin_aroundBody1$advice(this, var1, MethodSpendTimeAspect.aspectOf(), (ProceedingJoinPoint)var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ajc$preClinit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把execution该为call，在看一下编译后的 .class 文件 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LoginActivity extends AppCompatActivity &#123;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        ...</span><br><span class="line">        mEmailSignInButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                LoginActivity.access$000(com.sososeen09.aop_tech.LoginActivity.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TimeSpend(&quot;登录&quot;)</span><br><span class="line">    private void attemptLogin() &#123;</span><br><span class="line">        StatusHolder.sHasLogin = true;</span><br><span class="line">        Toast.makeText(this, &quot;登录成功&quot;, 0).show();</span><br><span class="line">        this.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ajc$preClinit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void access$000(LoginActivity x0) &#123;</span><br><span class="line">        JoinPoint makeJP = Factory.makeJP(ajc$tjp_0, null, x0);</span><br><span class="line">        attemptLogin_aroundBody1$advice(x0, makeJP, MethodSpendTimeAspect.aspectOf(), (ProceedingJoinPoint) makeJP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到区别了吧，execution表示JPoint是执行方法的地方，AspectJ会对被执行方法做处理。而call表示JPoint是调用方法的地方，AspectJ会对调用处做处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了AOP的一些概念性的知识，简单介绍了AspectJ在Android开发中的基本使用方式。限于篇幅和水平，难以对AspectJ做一个全面的介绍，建议对AOP和AspectJ有兴趣的读者可以阅读下面的相关项目和文章，也欢迎交流。</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><ul><li><a href="https://github.com/sososeen09/android-blog-demos/tree/master/aop-tech" target="_blank" rel="noopener">aop-tech</a></li><li><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">HujiangTechnology / gradle_plugin_android_aspectjx</a></li><li><a href="https://github.com/north2016/T-MVP" target="_blank" rel="noopener">north2016 / T-MVP</a></li><li><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">JakeWharton/hugo</a></li><li><a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a></li><li><a href="https://www.jianshu.com/p/dca3e2c8608a" target="_blank" rel="noopener">安卓AOP三剑客:APT,AspectJ,Javassist</a></li><li><a href="http://www.goluck.top/2017/06/11/AspectJ%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">AspectJ在Android中的应用</a></li><li><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">devguide:ajc-ref</a></li><li><a href="https://juejin.im/post/587989f48d6d810058bbae01" target="_blank" rel="noopener">看 AspectJ 在 Android 中的强势插入</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>启用Gradle远程调试</title>
      <link href="/2018/06/22/%E5%90%AF%E7%94%A8Gradle%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
      <url>/2018/06/22/%E5%90%AF%E7%94%A8Gradle%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">Gradle学习10——自定义Gradle插件</a> 这篇文章中介绍了编写插件的几种方式。<br>编写gradle对象插件的实现方式有3种：</p><ol><li>直接写在build.gradle中，这种方式简单省事，比较适合比较小的插件编写</li><li>在项目根目录下建立buildSrc目录</li><li>建立一个独立的项目工程，以jar包的形式提供依赖</li></ol><p>在编写对象插件的过程中很多都需要进行调试，本文就介绍一下如何启动gradle远程调试。</p><h1 id="启动远程调用"><a href="#启动远程调用" class="headerlink" title="启动远程调用"></a>启动远程调用</h1><p>首先点击Run-&gt; Edit Configuration</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-309994bfec6c2b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Edit Configuration.png"></p><p>然后点击+号，Add New Configutation，我们选择Remote</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-1e7fc863d0f76c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add New Configutation.png"></p><p>我们新建一个命名为apt-debug的remote，并且复制Command Line对应下的这段语句，当然了，我们在这里实际上也可以更改端口号的。也可以用当前默认的端口号5005。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2083810-d16f55b9ea665a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Remote.png"></p><p>然后点击Android Studio右侧的gradle选项</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-36570d19faa3bb43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle.png"></p><p>假如我们要选择app模块进行调试，可以在build下的assembleRelease任何下，右击，会有一个弹出窗口。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-4cd1b97e990d5896.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="assembleRelease.png"></p><p>我们点击Create 选项。会有如下窗口：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-daffe4fd205fb632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Create.png"></p><p>在VM options下填入我们刚才复制的信息，要注意的是把<strong>suspend对应的值改为y</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-ab6b6f3806863c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VM options.png"></p><p>然后会生成一个Run Condigurations的Task group。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-6fb0774ab28686b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Run Condigurations.png"></p><p>双击这个assembleRelease的调试任务，这个这个任务就会被挂起，等待着调式</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-5705867a0ef0654c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="等待着调式.png"></p><p>然后我们选择apt-debug，在点击右侧的debug按钮，就可以开始调试了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-75c8ba6c0e73ede0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击右侧的debug按钮.png"></p><h1 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h1><p>debug 模式运行 gradle 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle :app:clean -Dorg.gradle.debug=true  --no-daemon</span><br></pre></td></tr></table></figure><p>声明环境变量 GRADLE_OPTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GRADLE_OPTS=&quot;-Xdebug - Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot;</span><br></pre></td></tr></table></figure><p>attach Debugger</p><p>记住，如果想继续调试，就以Debug方式再次运行我们在Run Configuration下生成的assembleDebug或者assembleRelease。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-bd21efd5939c5ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再次debug.png"></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">又掌握了一项新技能 - 断点调试 Gradle 插件</a></li><li><a href="https://developer.android.com/studio/run/rundebugconfig.html?hl=zh-cn" target="_blank" rel="noopener">创建和编辑运行/调试配置</a></li><li><a href="https://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">Gradle学习10——自定义Gradle插件</a> </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Apk文件构建流程</title>
      <link href="/2018/06/14/Apk%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/06/14/Apk%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>阅读本文的时候，配合demo进行演示，效果更佳哦~<br>项目地址：<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a></p></blockquote><p>现在绝大部分人应该是使用Android Studio进行app的开发，通常我们运行一个app，直接点击 <code>run</code> 按钮或者使用gradle 命令 <code>./gradlew assembleDebug</code> 等就可以构建出一个apk文件，那么这个apk文件到底是怎么生成的呢？</p><p>本文通过命令行工具构建一个完整的app，来演示app的打包过程，借此来了解一下app的构建流程。由于网上已经有很多相关的文章，本文不会对基本的打包流程做过多详细的分析，有兴趣的读者可以查看文末的相关文章。</p><h1 id="基本的打包流程"><a href="#基本的打包流程" class="headerlink" title="基本的打包流程"></a>基本的打包流程</h1><p>首先来一张Android官网比较经典的打包流程图，这张图比较早了，但是依然具有指导意义。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-f699764e629cd8da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apk打包流程.png"></p><p>从这张图上看，构建一个基本的app，主要需要经历7个过程</p><ol><li><p>java文件生成过程，</p><ul><li>通过aapt工具生成R.java文件，输入文件是res目录下的文件和AndroidManifest.xml文件</li><li>通过aidl工具把.aidl文件生成java文件</li><li><p>其实还有apt的方式生成java文件<br>使用<code>android gradle plugin</code> 打包，在build/generated目录下存放的就是这些生成的java文件。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-8c096ab632984fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java generated.png"></p><p>aapt工具存放在/android-sdk/build-tools/$version/ 目录下。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-5976b83696dbde73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aapt存放目录"></p></li></ul></li><li><p>通过aapt工具来生成生成资源索引文件，一般来说生成的文件名是resources.ap<em>，使用<code>android gradle plugin</code> 打包，这个文件命名一般是 `resources</em>${buildVariant}.ap_`，例如<br><img src="https://upload-images.jianshu.io/upload_images/2083810-e3125b22ec2985a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源索引文件.png"></p></li><li><p>使用javac命令编译java文件<br>就是使用jdk中的javac工具，做java开发的应该都知道怎么使用。</p></li><li><p>通过dx工具生成dex文件，dx工具与aapt存放目录一致。</p></li><li><p>通过apkbuilder打包apk，可以在/android-sdk/tools/lib目录下找到sdklib.jar，执行其 com.android.sdklib.build.ApkBuilderMain的main方法<br><img src="https://upload-images.jianshu.io/upload_images/2083810-c99a4d5484f4fd85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdklib.jar.png"></p></li><li><p>签名，可以使用jarsigner工具签名和apksigner工具签名。jarsigner是Java本生自带的一个工具，他可以对jar进行签名的。而apksigner是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样。jarsigner工具签名时使用的是keystore文件，apksigner工具签名时使用的是pk8,x509.pem文件。<br>想要了解更多内容可以查看一位大神的文章<a href="https://blog.csdn.net/jiangwei0910410003/article/details/50402000" target="_blank" rel="noopener">Android签名机制之—签名过程详解</a></p></li><li>zipaligin，它位于/android-sdk/build-tools/$build-tools-version 目录，是一个zip文件整理工具用来优化apk文件。它的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时速度会更快。</li></ol><blockquote><p>注意：关于apk签名和zipaligin这块，如果使用不同的工具签名，zipaligin和签名的顺序是不一致的。例如，如果使用apksigner，那么zipaligin就必须是在签名之前进行。如果使用jarsigner，zipaligin就必须是在签名之后进行。具体可查看官网介绍：<a href="https://developer.android.google.cn/studio/command-line/apksigner" target="_blank" rel="noopener">https://developer.android.google.cn/studio/command-line/apksigner</a></p></blockquote><h1 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h1><p>在<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a>中，分别通过shell脚本和gradle打包的方式来演示构建apk的过程。同时，为了增加一些知识点，demo中演示了通过类加载机制实现代码热修复的一个基本过程。</p><p>例如，有如下代码，被除数为0，对于一个已经安装的apk，执行divide()方法肯定会crash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//修复前</span><br><span class="line">public class SimpleMathUtils &#123;</span><br><span class="line">public static String divide()&#123;</span><br><span class="line">int a=10/0;</span><br><span class="line">return &quot;the divide result is  &quot;+a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修复后</span><br><span class="line">public class SimpleMathUtils &#123;</span><br><span class="line">public static String divide()&#123;</span><br><span class="line">int a=10/1;</span><br><span class="line">return &quot;the divide result is  &quot;+a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改代码后，把被除数改为1，通过javac命令生成class文件，然后再通过dex命令把class文件生成为dex文件，名称为fixed.dex。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding UTF-8 -g -target 1.7 -source 1.7 -d bin src/main/java/com/sososeen09/multidexbuild/SimpleMathUtils.java</span><br><span class="line">cd bin</span><br><span class="line">dx --dex --output=fixed.dex com/sososeen09/multidexbuild/SimpleMathUtils.class</span><br></pre></td></tr></table></figure><p>简单起见，我把修复好的dex文件存放在一个目录中了<br><img src="https://upload-images.jianshu.io/upload_images/2083810-647dff1b7f55c817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要被打包进apk中的文件.png"></p><p>打包的时候把assets目录中的内容复制到apk文件中对应的assets目录下。</p><p>整个构建前后的文件目录是这样的，bin目录下是构建过程中的产物，gen目录下是生成的R.java文件。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-f2155149561bb281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建前后的文件目录.png"></p><p>把打包后的apk文件拖入到AS中，可以看到assets目录中的内容已经复制到apk中了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-ee481e4eb0a9527d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打包后的apk文件.png"></p><p>运行效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-2206e15b531b845e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行效果图..png"></p><p>直接点击getResult按钮会crash，因为 <code>10/0</code>，运行期肯定会报错。点击fix 按钮之后通过热修复的方式把代码做了更改，把代码中的 <code>10/0</code> 改成了 <code>10/1</code>，然后再点击 getResult 按钮的时候就没问题了。</p><p>相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void fix(View view) &#123;</span><br><span class="line">    tvFix.setText(&quot;fixing...&quot;);</span><br><span class="line">    File originDex = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        originDex = copyFileFromAssets(&quot;fixed.dex&quot;, getCacheDir().getAbsolutePath());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Toast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (originDex != null) &#123;</span><br><span class="line">        File dexOptimizeDir = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);</span><br><span class="line">        String dexOutputPath = dexOptimizeDir.getAbsolutePath();</span><br><span class="line">        PathClassLoader pathClassLoader = (PathClassLoader) getClassLoader();</span><br><span class="line">        DexClassLoader dexClassLoader = new DexClassLoader(originDex.getAbsolutePath(), dexOutputPath, null,</span><br><span class="line">                pathClassLoader);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取DexClassLoader对象的pathList对象，DexPathList</span><br><span class="line">            Object dexPathListWithDexClassLoader = ReflectUtils.findField(dexClassLoader, &quot;pathList&quot;).get(dexClassLoader);</span><br><span class="line"></span><br><span class="line">            // 获取DexPathList对象Element[]数组，对应的字段名是dexElements</span><br><span class="line">            Field dexElements = ReflectUtils.findField(dexPathListWithDexClassLoader, &quot;dexElements&quot;);</span><br><span class="line">            Object[] elements = (Object[]) dexElements.get(dexPathListWithDexClassLoader);</span><br><span class="line"></span><br><span class="line">            // 获取PathClassLoader对象的pathList对象，DexPathList</span><br><span class="line">            Object dexPathListWithPathClassLoader = ReflectUtils.findField(pathClassLoader, &quot;pathList&quot;).get(pathClassLoader);</span><br><span class="line"></span><br><span class="line">            //把之前获取的Element[]数组插入到PathClassLoader对象对应的DexPathList的Element数组中</span><br><span class="line">            ReflectUtils.insertFieldArray(dexPathListWithPathClassLoader, &quot;dexElements&quot;, elements);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tvFix.setText(&quot;done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private File copyFileFromAssets(String assetName, String dexOutputDir) throws IOException &#123;</span><br><span class="line">    File originDex = null;</span><br><span class="line">    AssetManager assets = getAssets();</span><br><span class="line">    InputStream open = assets.open(assetName);</span><br><span class="line">    originDex = new File(dexOutputDir, assetName);</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(originDex);</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len = open.read(bytes)) != -1) &#123;</span><br><span class="line">        fileOutputStream.write(bytes, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    open.close();</span><br><span class="line"></span><br><span class="line">    return originDex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>热修复就是基于类加载机制，把修复好的dex插入到app的PathClassLoader关联的dex数组的前部，这样的话根据类加载机制，就会先找到修复好的class，进而实现了修复的目的。</p><p>关于类加载机制，可以阅读相关文章：</p><ul><li><a href="https://www.jianshu.com/p/2026b01fb965" target="_blank" rel="noopener">类加载机制系列1——深入理解Java中的类加载器</a></li><li><a href="https://www.jianshu.com/p/7193600024e7" target="_blank" rel="noopener">类加载机制系列2——深入理解Android中的类加载器</a></li><li><a href="https://www.jianshu.com/p/07200780dc83" target="_blank" rel="noopener">类加载机制系列3——MultiDex原理解析</a></li></ul><h1 id="gradle打包处理添加assets过程"><a href="#gradle打包处理添加assets过程" class="headerlink" title="gradle打包处理添加assets过程"></a>gradle打包处理添加assets过程</h1><p>如果我们使用android gradle plugin打包，为了要把外部assets目录下的文件打包到apk的assets目录中，需要hook gradle的打包流程。给出相关代码，也可以亲自研究一下项目<a href="https://github.com/sososeen09/android-blog-demos/tree/master/apk-build" target="_blank" rel="noopener">apk-build</a>。</p><p>在build.gradle中创建一个类实现Plugin接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class AssetPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            project.android.applicationVariants.each &#123; ApplicationVariant variant -&gt;</span><br><span class="line">                String variantName = variant.name.capitalize()</span><br><span class="line">                def packageTask = project.tasks.getByName(&quot;package$&#123;variantName&#125;&quot;)</span><br><span class="line">                project.logger.quiet(&quot;packageTask: &quot; + packageTask.class)</span><br><span class="line">                project.logger.quiet(&quot;packageTask assets path: &quot; + packageTask.assets.asPath)</span><br><span class="line">                packageTask.doFirst &#123;</span><br><span class="line">                    project.copy &#123; param -&gt;</span><br><span class="line">                        from &quot;../multidexbuild/assets&quot;</span><br><span class="line">                        //很坑的一点是，2.3.3下是packageTask.assets，到3.0就变成packageTask.assets.asPath</span><br><span class="line">                        into &quot;$&#123;packageTask.assets.asPath&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在build.gradle中引入插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: AssetPlugin</span><br></pre></td></tr></table></figure><p>想要了解gradle可以查看我之前写过的一个gradle系列文章<a href="https://www.jianshu.com/p/0bde7097abaf" target="_blank" rel="noopener">Gradle学习</a>。<br>关于gradle打包apk的过程，这里就不多做介绍了，感兴趣的可以自行了解。如果想要深入研究，推荐研究一下<a href="https://github.com/typ0520/fastdex" target="_blank" rel="noopener">fastdex</a>，是我司的大神写的，一定会让你深受启发。<br>也可以阅读他写的相关文章：<a href="https://www.jianshu.com/p/53923d8f241c" target="_blank" rel="noopener">加快apk的构建速度，如何把编译时间从130秒降到17秒</a></p><h1 id="apk打包shell脚本"><a href="#apk打包shell脚本" class="headerlink" title="apk打包shell脚本"></a>apk打包shell脚本</h1><p>为了方便起见，写了一个构建apk文件的脚本 <a href="https://github.com/sososeen09/android-blog-demos/blob/master/apk-build/apk-build-with-shell/build.sh" target="_blank" rel="noopener">build.sh</a>，<br>如果要再自己本机上运行一下脚本，需要更改配置的android sdk目录。</p><blockquote><p>注意:使用命令行打包，注意需要配置好环境变量，确保adb、dx、aapt等命令都可以正常使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;init...&apos;</span><br><span class="line">project_dir=$(pwd)</span><br><span class="line"></span><br><span class="line">echo &quot;project_dir: $&#123;project_dir&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 需要更改为自己的android sdk存放的目录</span><br><span class="line">sdk_folder=/works/android/android-sdk-macosx</span><br><span class="line">platform_folder=$&#123;sdk_folder&#125;/platforms/android-26</span><br><span class="line">android_jar=$&#123;platform_folder&#125;/android.jar</span><br><span class="line"></span><br><span class="line"># 使用通配符，因为有的命名是sdklib-26.0.0-dev.jar这样的形式</span><br><span class="line">sdklib_jar=$&#123;sdk_folder&#125;/tools/lib/sdklib*.jar</span><br><span class="line"></span><br><span class="line">src=$&#123;project_dir&#125;/src/main</span><br><span class="line">bin=$&#123;project_dir&#125;/bin</span><br><span class="line">libs=$&#123;project_dir&#125;/libs</span><br><span class="line"></span><br><span class="line">java_source_folder=$&#123;src&#125;/java</span><br><span class="line"></span><br><span class="line">if [ -d gen ];then</span><br><span class="line">rm -rf gen</span><br><span class="line">fi</span><br><span class="line">if [ -d bin ];then</span><br><span class="line">rm -rf bin</span><br><span class="line">fi</span><br><span class="line">mkdir gen</span><br><span class="line">mkdir bin</span><br><span class="line"></span><br><span class="line">#1.生成R文件</span><br><span class="line">echo &apos;generate R.java file&apos;</span><br><span class="line">aapt package -f -m -J ./gen -S $&#123;src&#125;/res -M $&#123;src&#125;/AndroidManifest.xml -I $&#123;android_jar&#125;</span><br><span class="line"></span><br><span class="line">#2.生成资源索引文件</span><br><span class="line">echo &apos;generate resourses index file&apos;</span><br><span class="line">aapt package -f -M $&#123;src&#125;/AndroidManifest.xml -S $&#123;src&#125;/res -I $&#123;android_jar&#125; -F bin/resources.ap_</span><br><span class="line"></span><br><span class="line">#3.编译java文件</span><br><span class="line">echo &apos;compile java file&apos;</span><br><span class="line">javac -encoding UTF-8 -g -target 1.7 -source 1.7 -cp $&#123;android_jar&#125; -d bin $&#123;java_source_folder&#125;/com/sososeen09/multidexbuild/*.java $&#123;java_source_folder&#125;/com/sososeen09/multidexbuild/utils/*.java gen/com/sososeen09/multidexbuild/*.java</span><br><span class="line"># javac -encoding UTF-8 -g -target 1.7 -source 1.7 -cp $android_jar -d bin src/ gen/</span><br><span class="line"></span><br><span class="line">#4.生成dex文件,这里我们把MainActivity打包到主dex中，utils打包到secondaryDex中</span><br><span class="line"># --minimal-main-dex 表示只把maindexlist.txt中指定的类打包到主dex中</span><br><span class="line">#  --set-max-idx-number=2000  表示指定没个dex的最大方法数目是2001，最大65535</span><br><span class="line">echo &apos;generate dex file&apos;</span><br><span class="line">dx --dex --output=bin/ --multi-dex --main-dex-list=maindexlist.txt --minimal-main-dex bin/</span><br><span class="line"></span><br><span class="line">#5.打包apk</span><br><span class="line">echo &apos;generate apk file&apos;</span><br><span class="line">java -cp $&#123;sdklib_jar&#125; com.android.sdklib.build.ApkBuilderMain bin/app-debug-unsigned.apk -v -u -z bin/resources.ap_ -f bin/classes.dex -rf src</span><br><span class="line"></span><br><span class="line">#6.通过aapt工具把secondarydex copy到apk中</span><br><span class="line">echo &apos;aapt add dex into apk&apos;</span><br><span class="line">cd bin</span><br><span class="line">aapt add -f app-debug-unsigned.apk classes2.dex</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">#7.把assets的内容加进去</span><br><span class="line">echo &apos;put some file into apk assets&apos;</span><br><span class="line">aapt add -f bin/app-debug-unsigned.apk assets/ic_launcher-web.png assets/fixed.dex</span><br><span class="line"></span><br><span class="line">#8 签名</span><br><span class="line">echo &apos;sign apk&apos;</span><br><span class="line">java -jar auto-sign/signapk.jar auto-sign/testkey.x509.pem auto-sign/testkey.pk8 ./bin/app-debug-unsigned.apk ./bin/app-debug.apk</span><br><span class="line"></span><br><span class="line">#9 打印方法数</span><br><span class="line">dexdump -f bin/app-debug.apk | grep method_ids_size</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="https://blog.csdn.net/chenkai19920410/article/details/60589100" target="_blank" rel="noopener">自己动手生成Android Apk</a></li><li><a href="https://blog.csdn.net/jason0539/article/details/44917745" target="_blank" rel="noopener">android Apk打包过程概述_android是如何打包apk的</a></li><li><a href="http://blog.csdn.net/chichoxian/article/details/8760456" target="_blank" rel="noopener">dx使用出现的错误总结</a></li><li><a href="https://segmentfault.com/a/1190000004062952" target="_blank" rel="noopener">Android动态加载入门 简单加载模式</a></li><li><a href="http://blog.csdn.net/jiangwei0910410003/article/details/50740026" target="_blank" rel="noopener">如何使用Ant脚本编译出Jar和Apk包</a></li><li><a href="https://dev.qq.com/topic/5913db5c29d8be2a14b64da8" target="_blank" rel="noopener">dex分包变形记</a></li><li><a href="http://blog.csdn.net/gaozhan_csdn/article/details/52024497" target="_blank" rel="noopener">multidex分包续：将指定的类打包到主dex中</a></li><li><a href="http://blog.csdn.net/mynameishuangshuai/article/details/52703029" target="_blank" rel="noopener">彻底掌握Android多分包技术MultiDex-用Ant和Gradle分别构建（一）</a></li><li><a href="https://www.zybuluo.com/linux1s1s/note/309503" target="_blank" rel="noopener">Android 打包系列-基本打包流程</a></li><li><a href="https://blog.csdn.net/jiangwei0910410003/article/details/50402000" target="_blank" rel="noopener">Android签名机制之—签名过程详解</a></li><li><a href="https://developer.android.google.cn/studio/command-line/zipalign" target="_blank" rel="noopener">https://developer.android.google.cn/studio/command-line/zipalign</a></li><li><a href="https://www.jianshu.com/p/53923d8f241c" target="_blank" rel="noopener">加快apk的构建速度，如何把编译时间从130秒降到17秒</a> </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议相关知识介绍</title>
      <link href="/2018/06/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/06/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="网络的五层划分"><a href="#网络的五层划分" class="headerlink" title="网络的五层划分"></a>网络的五层划分</h1><p>网络层次的划分有OSI（Open System Interconnect，开放式系统互联）七层模型和TCP/IP模型。<br>OSI模型按照从顶层到底层划分7层，分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。<br>由于OSI模型划分的层数太多、模型比较复杂，实现起来比较困难，因此当前网络模型使用的是TCP/IP模型。<br>TCP/IP是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将网络分成四个层次，每一层都有对应的协议：</p><ul><li>应用层，支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信，包含的协议有HTTP、STMP、FTP</li><li>传输层，负责为信源和信宿提供应用程序进程间的数据传输服务，包含的协议有TCP、UDP</li><li>网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题，对应的是协议有IP协议、ARP协议等</li><li>网络接口层，该层也可细分为数据链路层和物理层，网络层负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。数据链路层负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。协议有以太网、Wi-Fi、MPLS等。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2083810-9a2e7bb68df59264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络各层连接示意图"></p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p>先说UDP吧，UDP的全称是User Datagram Protocol，又称为<strong>用户数据报文协议</strong>，UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议），而且不保证接收端可以收到。在一些即时通讯领域会采用UDP。</p><p>TCP的全程是Transmission Control Protocol，又称为<strong>传输控制协议</strong>，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>那么TCP是如何保证可靠性的呢？</p><p>TCP保证可靠性的手段有：停止等待协议、滑动窗口协议、流量控制、拥塞控制等。</p><ul><li>应用数据被分割成TCP认为最适合发送的数据块。</li><li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<ul><li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li></ul></li><li>校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。<ul><li>TCP的接收端会丢弃重复的数据。 </li></ul></li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 </li><li>拥塞控制：当网络拥塞时，减少数据的发送。</li></ul><h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p>三次握手（Three-Way Handshake）即建立TCP连接，指的是在建立TCP连接的过程中，需要客户端和服务端总共发送3个包以确认连接的建立。</p><ul><li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li><li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li><li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2083810-32dbd1e7141ab98a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3次握手"></p><p>那么为什么需要3次握手呢？</p><p>我们先来分析一下如果只有2次握手会怎么样，客户端发送一个请求，服务端发出一个响应，此时的情况下连接有可能根本就没有建立起来，因为网络传输是要花费时间的，服务端处理一个客户端连接也可以需要时间，客户端有可能在发送一个连接请求之后马上就关闭了，而此时服务端只是向客户端发送了一个确认的包，紧接着就开始处理网络请求了，这种情况下是不可能成功的。而且既然不需要等待客户端再次发出一个确认数据包，2次握手等同于1次握手，连接不可靠。</p><p>如果超过3次握手也没这个必要，毕竟3次就已经可以保证连接建立了。</p><h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p>四次挥手（Four-Way Wavehand）即终止TCP连接，也就是说断开连接的时候需要客户端和服务端总共发送4个包来确认连接的断开。这个断开连接的过程可以由客户端和服务端任意一方来发起。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-460ddbfd1b392381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手——客户端主动关闭"></p><ul><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 </li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 </li></ul><p>4次挥手还存在着两端同时发起主动关闭的情况，流程图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-f88a83c1b0f3175f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手——双方同时主动关闭.png"></p><p>那么为什么需要4次挥手才能保证连接的断开呢？<br>这是因为客户端和服务端的读写是双向的，客户端和服务端都要分别发出两个包：</p><ul><li>一个数据包用来表示不再发送数据了</li><li>一个数据包用来表示不再接收数据了 </li></ul><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E7%9A%84%E5%B1%82" target="_blank" rel="noopener">因特网协议栈中的层</a></li><li><a href="https://blog.csdn.net/cmm0401/article/details/77878998" target="_blank" rel="noopener">我是如何讲清楚TCP协议是如何保证可靠传输的</a></li><li><a href="https://www.cnblogs.com/yangbodong/p/4964698.html" target="_blank" rel="noopener">停止等待协议,连续ARQ协议,滑动窗口协议</a></li><li><a href="https://blog.csdn.net/renzhenhuai/article/details/12105457" target="_blank" rel="noopener">TCP/IP协议 三次握手与四次挥手</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater——你应该知道的一点知识</title>
      <link href="/2018/05/19/LayoutInflater%E2%80%94%E2%80%94%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/05/19/LayoutInflater%E2%80%94%E2%80%94%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>在Android开发中我们经常使用LayoutInflater，俗称布局填充器，使用它来把布局转为一个View。一般来讲可能采用的方式如下：</p><ol><li><p>调用其静态from方法，获取LayoutInflater对象，然后调用其inflate方法获取一个View对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static LayoutInflater from(Context context)</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure></li><li><p>调用View的静态inflate方法，获取对象，不过该方法其实等同于封装了方式1。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) &#123;</span><br><span class="line">    LayoutInflater factory = LayoutInflater.from(context);</span><br><span class="line">    return factory.inflate(resource, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，其实今天想讨论的不是如何加载一个布局的问题，而是一些其它问题，比如：</p><ol><li>每次调用LayoutInflater的from方法都会创建一个新的LayoutInflater对象吗？</li><li>LayoutInflater的from方法中如果传递不同的Context对象会有什么不同？</li><li>调用View的getContext() 方法会获取一个Context，那么这个Context对象具体是谁呢？</li><li>为什么想要在xml中使用View，就必须要有两个参数的构造方法呢？</li></ol><p>下面我们就通过实践和源码分析的方式来回答一下上面的这些问题。</p><h1 id="LayoutInflater的from方法"><a href="#LayoutInflater的from方法" class="headerlink" title="LayoutInflater的from方法"></a>LayoutInflater的from方法</h1><p>先给出结论：我们通过LayoutInflater的from(Context context)方法获取一个LayoutInflater对象。传递不同的Context对象，获取到的LayoutInflater对象也不同。每一个Activity 都会持有一个 LayoutInflater 对象， 如果每次传递的Context对象都是同一个Activity 对象，只会创建一个 LayoutInflater 对象。</p><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater fromActivity1 = LayoutInflater.from(this);</span><br><span class="line">LayoutInflater fromActivity2 = LayoutInflater.from(this);</span><br><span class="line">LayoutInflater fromApplication = LayoutInflater.from(getApplication());</span><br><span class="line"></span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromActivity1);</span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromApplication);</span><br><span class="line">Log.e(TAG, &quot;onCreate: layoutInflater: &quot; + fromActivity2);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@28d214ef</span><br><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@3adebfc</span><br><span class="line">onCreate: layoutInflater: com.android.internal.policy.impl.PhoneLayoutInflater@28d214ef</span><br></pre></td></tr></table></figure><p>在打印的 log 中也可以看到调动LayoutInflater的from方法实际上创建的是它的子类 PhoneLayoutInflater 对象。从结果中也看到传递Application 或者Activity，创建的LayoutInflater 不同，而且如果传递的是Activity，多次调用只会创建一个LayoutInflater 对象。</p><p>源码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#android.view.LayoutInflater</span><br><span class="line">public static LayoutInflater from(Context context) &#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    if (LayoutInflater == null) &#123;</span><br><span class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了Context的getSystemService方法，如果我们传递的是Activity，会先调用Activity的getSystemService() 方法。，所以我们先看一下Activity中的getSystemService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(@ServiceName @NonNull String name) &#123;</span><br><span class="line">    if (getBaseContext() == null) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                &quot;System services not available to Activities before onCreate()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (WINDOW_SERVICE.equals(name)) &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125; else if (SEARCH_SERVICE.equals(name)) &#123;</span><br><span class="line">        ensureSearchManager();</span><br><span class="line">        return mSearchManager;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity 中的 getSystemService() 方法只是对<strong>WINDOW_SERVICE</strong> 和 <strong>SEARCH_SERVICE</strong> 做了单独的处理，没有对 <strong>LAYOUT_INFLATER_SERVICE</strong> 做什么处理，不过Activity是继承自 ContextThemeWrapper 的，我们再来看一下ContextThemeWrapper 的 getSystemService() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#android.view.ContextThemeWrapper</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">        if (mInflater == null) &#123;</span><br><span class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);//1</span><br><span class="line">        &#125;</span><br><span class="line">        return mInflater;</span><br><span class="line">    &#125;</span><br><span class="line">    return getBaseContext().getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果我们获取LayoutInflater对象，并且当前的 mInflater 变量为空的话就会调用1处的 LayoutInflater.from(getBaseContext()).cloneInContext(this) 方法创建一个LayoutInflater对象，下次再调用的时候直接返回这个对象，不会重复创建。<br>上面的代码中getBaseContext()方法获取的就是该Activity绑定的mBase对象，这个mBase是一个Context对象 ，但Context是一个抽象类，那么它实际上是什么对象呢，这个我们一会再来解释。</p><p>先来看一下如果我们传递的是Application对象会发生什么呢？<br>我们需要知道一点，Application是继承自ContextWrapper的，来看一下ContextWrapper的 getSystemService() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContextWrapper</span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return mBase.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了 mBase 的 getSystemService() 方法，这个mBase也不绕关子了，它就是一个ContextImpl对象。Application、Activity、Service对象在创建完毕之后他们的attach() 方法都会被调用，在 attach()  中会调用 attachBaseContext() 方法，就会给这个mBase 赋值，实际上是一个 ContextImpl对象。这个在我之前写的几篇文章中都有涉及到相关内容，想要了解的可以看下<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>、<a href="https://www.jianshu.com/p/bce3b49a3af6" target="_blank" rel="noopener">Android四大组件——Service的工作过程分析</a>。</p><p>通过上面的分析我们会发现，不管是传递Activity还是Application实际上都会先调用ContextImpl 的  getSystemService() 方法，直接来看一下它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl </span><br><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl 调用了 SystemServiceRegistry的getSystemService() 方法，需要说明一点，ContextImpl 的getSystemService() 方法在不同的版本中都会有不同。我们不需要纠结API的不同，侧重流程，看到我们想要看的即可。比如现在，我们想要看的是LayoutInflater对象是怎么创建的，跟着代码继续看 SystemServiceRegistry的getSystemService() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.app.SystemServiceRegistry</span><br><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    return fetcher != null ? fetcher.getService(ctx) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SystemServiceRegistry的getSystemService() 方法中通过一个 SYSTEM_SERVICE_FETCHERS 来根据一个 name 获取一个 ServiceFetcher 对象，然后调用它的getService 返回一个对象。我们的LayoutInflater 对象应该就是通过ServiceFetcher 获得的。SYSTEM_SERVICE_FETCHERS 实际上就是一个HashMap。SystemServiceRegistry这个类都是静态方法和静态代码块，也就是说只要这个类加载的时候就会触发注册，SystemServiceRegistry注册了App运行需要用到的所有服务，有AMS，PMS、NMS，我们需要用到 LAYOUT_INFLATER_SERVICE 也就是LayoutInflater 也在其中。</p><p>ServiceFetcher的getService中首先会看看当前是否已经缓存了对应的对象，比如我们想要获取的LayoutInflater，如果已经有的话会直接返回这个对象，如果没有的话就会调用其createService() 方法，从下面的代码中也可以看到，通过PhoneLayoutInflater 的一个参数的构造方法创建了LayoutInflater 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final class SystemServiceRegistry &#123;</span><br><span class="line">    private static final String TAG = &quot;SystemServiceRegistry&quot;;</span><br><span class="line"></span><br><span class="line">    // Service registry information.</span><br><span class="line">    // This information is never changed once static initialization has completed.</span><br><span class="line">    private static final HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class="line">            new HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">    private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line">    private static int sServiceCacheSize;</span><br><span class="line"></span><br><span class="line">    // Not instantiable.</span><br><span class="line">    private SystemServiceRegistry() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">...</span><br><span class="line">        registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,</span><br><span class="line">                new CachedServiceFetcher&lt;ActivityManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ActivityManager createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">...</span><br><span class="line">        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">                new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public LayoutInflater createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析我们也可以发现，不管是LayoutInflater的from方法中的 Context，传递Activity还是Application实际上都会先调用ContextImpl 的  getSystemService() 方法获取一个LayoutInflater。这个对象是唯一的，只要是从ContextImpl这获取的，就只有一个。对于Activity不同的是又调用了 cloneInContext() 方法来获取一个LayoutInflater对象，这个 cloneInContext() 方法是一个抽象方法，由PhoneLayoutInflater实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># com.android.internal.policy.PhoneLayoutInflater</span><br><span class="line">public PhoneLayoutInflater(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LayoutInflater cloneInContext(Context newContext) &#123;</span><br><span class="line">    return new PhoneLayoutInflater(this, newContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected PhoneLayoutInflater(LayoutInflater original, Context newContext) &#123;</span><br><span class="line">    super(original, newContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> #android.view.LayoutInflater</span><br><span class="line">protected LayoutInflater(LayoutInflater original, Context newContext) &#123;</span><br><span class="line">    mContext = newContext;</span><br><span class="line">    mFactory = original.mFactory;</span><br><span class="line">    mFactory2 = original.mFactory2;</span><br><span class="line">    mPrivateFactory = original.mPrivateFactory;</span><br><span class="line">    setFilter(original.mFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中也可以看到，调用 LayoutInflater的cloneInContext() 方法实际上就是创建了一个新的LayoutInflater对象，并且会把原来对象上的一些属性拷贝过来，如mFactory、mFactory2、mPrivateFactory、mFilter。这些factory 和 filter 就是为了从xml中加载布局来创建View对象时候用到的。</p><p>不过还有一点需要注意，PhoneLayoutInflater的一个构造方法中的Context是由ContextImpl的getOuterContext() 方法获取到的，那么这个mOuterContext是什么呢？</p><p>ContextImpl对象与Application、Activity、Service对象是一一绑定的。我们的ContextImpl 中的mOuterContext对象，这个在Activity中就是当前Activity对象，在Service中就是当前的Service对象。赋值时机是在ContextImpl对象创建后。ContextImpl的创建时机都是在ActivityThead中每次启动Activity或者Service或者一个新的Application的时候。</p><h1 id="LayoutInflater-的创建时机"><a href="#LayoutInflater-的创建时机" class="headerlink" title="LayoutInflater 的创建时机"></a>LayoutInflater 的创建时机</h1><p>上面我们讲到的是开发者主动调用LayoutInflater的from方法来返回一个对象，但是我们知道一点是当在Activity中调用 setContentView(layoutRes) 方法的时候，会调用到PhoneWindow的setContentView(layoutRes) 方法，在该方法中通过LayoutInflater对象来创建View树了，那么这个LayoutInflater是什么时候创建的呢？</p><p>实际上，LayoutInflater的创建时机就是在Activity对象被创建出来之后。当Activity创建后，其attach方法就会被调用，在这个过程中Activity相关的对象或者属性就会被绑定，比如，PhoneWindow就是在这个时候被创建出来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PhoneWindow中有两个构造函数，一个有3个参数，一个有1个参数。3个参数的首先会调用1个参数的。在这个过程中调用了LayoutInflater的from 方法。来创建LayoutInflater对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PhoneWindow(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这个context对象就是Activity。</p></blockquote><h1 id="LayoutInflater的inflate-方法"><a href="#LayoutInflater的inflate-方法" class="headerlink" title="LayoutInflater的inflate() 方法"></a>LayoutInflater的inflate() 方法</h1><p>我们使用LayoutInflater的inflate方法的时候一般会使用2个参数或者3个参数的方法，第一个参数代表所要加载的布局，第二个参数是跟ViewGroup，这个参数需要与第3个参数配合使用，attachToRoot如果为true，表示要把当前的布局添加到ViewGroup中，作为其子View。如果为false就是表示只是采用ViewGroup的LayoutParams作为测量的依据。如果ViewGroup为null的话也能够得到一个View，不过这个View的尺寸有可能不是我们想要的。所以尽量不要使第二个参数为null。如果你只想从布局中加载View，而不想添加到ViewGroup中，可以使用3个参数的方法，attachToRoot为false即可。</p><p>下面这两个方法表示从资源中找到对应的布局xml，然后创建一个XmlResourceParser对象用来解析便签。解析方式采用的是pull解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">    return inflate(resource, root, root != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res = getContext().getResources();</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;</span><br><span class="line">                + Integer.toHexString(resource) + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    try &#123;</span><br><span class="line">        return inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面两个我们开发者经常使用的方法，还有一个3个参数的inflate方法。第一个参数是XmlPullParser对象，我们把它当做一个解析标签的对象即可。在这个inflate() 方法中会对所有的view标签（包括自定义View）、include、merge、ViewStub等进行处理。</p><p>在该方法中有一个含有两个元素的数组 mConstructorArgs，这个就是在使用View的两个参数的构造方法时用于提供参数的。mConstructorArgs的第一个元素就是inflaterContext，实际上就是创建LayoutInflater对象的mContext。在一个Activity创建的LayoutInflater，mContext指向的就是这个Activity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">        final Context inflaterContext = mContext;</span><br><span class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">        mConstructorArgs[0] = inflaterContext;</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                // Empty</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">            final String name = parser.getName();</span><br><span class="line">...</span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml  //1</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // Set the layout params for temp if we are not</span><br><span class="line">                        // attaching. (If we are, we use addView, below)</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">                // Inflate all children under temp against its context.</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line">...</span><br><span class="line">                // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                // to root. Do that now.</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Decide whether to return the root that was passed in or the</span><br><span class="line">                // top view found in xml.</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">...</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1调用了 createViewFromTag() 方法。该方法又会调用其重载方法。在createViewFromTag 重载方法中，会一次判断mFactory2、mFactory、mPrivateFactory是否会null，如果不为null的就按照优先级调用mFactory2、mFactory、mPrivateFactory的相关方法来创建View，只有前一个返回的View为null的时候，才会由后一个来创建，如果这几个创建的View都会null的话，就会调用LayoutInflater自身的方法来创建View。</p><p>mFactory2、mFactory、mPrivateFactory均有相关的set方法用于设置。<br>相信看到这里，就应该明白了我们之前讲的在clone一个原始的LayoutInflater的作用了，就是可以复用它的mFactory2、mFactory、mPrivateFactory，不需要再重新设置了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    return createViewFromTag(parent, name, context, attrs, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</span><br><span class="line">        boolean ignoreThemeAttr) &#123;</span><br><span class="line">    if (name.equals(&quot;view&quot;)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Apply a theme wrapper, if allowed and one is specified.</span><br><span class="line">    if (!ignoreThemeAttr) &#123;</span><br><span class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        final int themeResId = ta.getResourceId(0, 0);</span><br><span class="line">        if (themeResId != 0) &#123;</span><br><span class="line">            context = new ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">// 1 开始创建View</span><br><span class="line">    try &#123;</span><br><span class="line">        View view;</span><br><span class="line">        if (mFactory2 != null) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; else if (mFactory != null) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            view = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            final Object lastContext = mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] = context;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    view = createView(name, null, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mConstructorArgs[0] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return view;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下Factory、Factory2，Factory2继承自Factory，它们的接口方法都是用来创建View对象的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    public View onCreateView(String name, Context context, AttributeSet attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Factory2 extends Factory &#123;</span><br><span class="line">    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一下LayoutInflater的createView方法，首先通过View的名称来获取它的构造函数Constructor。如果Constructor为null的话就会采用ClassLoader去加载对应的class。需要注意的时候我们在xml填写的View的名称比如TextView，实际上是有全路径名的，即为：android.widget.TextView，类加载器加载必须要使用全路径名，因此对于TextView这样的Android系统自带的空间，需要加上全路径，因此可以在注释1处看到使用了prefix。当Class加载成功的时候就会通过mConstructorSignature创建一个两个参数的构造器，对应的参数是 Context.class, AttributeSet.class。之后就可以看到利用的反射的方式创建View对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public final View createView(String name, String prefix, AttributeSet attrs)</span><br><span class="line">        throws ClassNotFoundException, InflateException &#123;</span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</span><br><span class="line">        constructor = null;</span><br><span class="line">        sConstructorMap.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends View&gt; clazz = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line"></span><br><span class="line">        if (constructor == null) &#123;</span><br><span class="line">            // Class not found in the cache, see if it&apos;s real, and try to add it </span><br><span class="line">            //1</span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">            if (mFilter != null &amp;&amp; clazz != null) &#123;</span><br><span class="line">                boolean allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                if (!allowed) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If we have a filter, apply it to cached constructor</span><br><span class="line">            if (mFilter != null) &#123;</span><br><span class="line">                // Have we seen this name before?</span><br><span class="line">                Boolean allowedState = mFilterMap.get(name);</span><br><span class="line">                if (allowedState == null) &#123;</span><br><span class="line">                    // New class -- remember whether it is allowed</span><br><span class="line">                    clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                            prefix != null ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                    mFilterMap.put(name, allowed);</span><br><span class="line">                    if (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object lastContext = mConstructorArgs[0];</span><br><span class="line">        if (mConstructorArgs[0] == null) &#123;</span><br><span class="line">            // Fill in the context if not already within inflation.</span><br><span class="line">            mConstructorArgs[0] = mContext;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = mConstructorArgs;</span><br><span class="line">        args[1] = attrs;</span><br><span class="line"></span><br><span class="line">        final View view = constructor.newInstance(args);</span><br><span class="line">        if (view instanceof ViewStub) &#123;</span><br><span class="line">            // Use the same context when inflating ViewStub later.</span><br><span class="line">            final ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</span><br><span class="line">        &#125;</span><br><span class="line">        mConstructorArgs[0] = lastContext;</span><br><span class="line">        return view;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过View的两个参数的构造函数创建了View对象，第一个参数Context，传递的是LayoutInflater自身的mContext，对于Activity中的LayoutInflater，这个mContext就是Activity自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public View(Context context, @Nullable AttributeSet attrs)</span><br></pre></td></tr></table></figure><p>所以你应该明白了，在View中的Context实际上就是其所在的Activity对象。那么对于Fragment中的View也是这样的。</p><h1 id="Fragment中的LayoutInflater"><a href="#Fragment中的LayoutInflater" class="headerlink" title="Fragment中的LayoutInflater"></a>Fragment中的LayoutInflater</h1><p>Fragment中有一个onCreateView() 方法，方法中有一个参数是LayoutInflater，这么LayoutInflater对象是从哪来的呢？</p><p>这个对象也是clone而来，而且是由Activity中的LayoutInflater clone而来。Fragment中的LayoutInflater与Activity中的LayoutInflater不是同一个对象，但既然是clone，Fragment中的LayoutInflater中把是Activity中的LayoutInflater中的mFactory、mFactory2、mPrivateFactory、mFilter变量全部赋值给自己相应的成员变量。注意：这是一个浅拷贝，也就是对象中的成员变量拷贝的是引用而不是实例。</p><p>我们来分析一下源码，Fragment是由FragmentManager来管理的，Fragment在创建阶段的生命周期方法是由FragmentManager的moveToState() 方法中回调的。代码很长，我们截取一些关键的信息，可以看到在这个方法中，Fragment的生命周期方法被回调。其中我们看到调用了Fragment的performCreateView() 方法，在参数中传递了LayoutInflater，而这个是通过调用的Fragment的 performGetLayoutInflater() 方法获得的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"># android.app.FragmentManagerImpl</span><br><span class="line">@SuppressWarnings(&quot;ReferenceEquality&quot;)</span><br><span class="line">void moveToState(Fragment f, int newState, int transit, int transitionStyle,</span><br><span class="line">        boolean keepActive) &#123;</span><br><span class="line">    if (DEBUG &amp;&amp; false) Log.v(TAG, &quot;moveToState: &quot; + f</span><br><span class="line">        + &quot; oldState=&quot; + f.mState + &quot; newState=&quot; + newState</span><br><span class="line">        + &quot; mRemoving=&quot; + f.mRemoving + &quot; Callers=&quot; + Debug.getCallers(5));</span><br><span class="line"></span><br><span class="line">    // Fragments that are not currently added will sit in the onCreate() state.</span><br><span class="line">    if ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        newState = Fragment.CREATED;</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">        if (f.mState == Fragment.INITIALIZING &amp;&amp; f.isInBackStack()) &#123;</span><br><span class="line">            // Allow the fragment to be created so that it can be saved later.</span><br><span class="line">            newState = Fragment.CREATED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // While removing a fragment, we can&apos;t change it to a higher state.</span><br><span class="line">            newState = f.mState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Defer start if requested; don&apos;t allow it to move to STARTED or higher</span><br><span class="line">    // if it&apos;s not already started.</span><br><span class="line">    if (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    if (f.mState &lt;= newState) &#123;</span><br><span class="line">...</span><br><span class="line">        switch (f.mState) &#123;</span><br><span class="line">            case Fragment.INITIALIZING:</span><br><span class="line">...</span><br><span class="line">                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);</span><br><span class="line">                    f.mCalled = false;</span><br><span class="line">                    f.onAttach(mHost.getContext());</span><br><span class="line">...</span><br><span class="line">            case Fragment.CREATED:</span><br><span class="line">                // This is outside the if statement below on purpose; we want this to run</span><br><span class="line">                // even if we do a moveToState from CREATED =&gt; *, CREATED =&gt; CREATED, and</span><br><span class="line">                // * =&gt; CREATED as part of the case fallthrough above.</span><br><span class="line">                ensureInflatedFragmentView(f);</span><br><span class="line"></span><br><span class="line">                if (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;moveto ACTIVITY_CREATED: &quot; + f);</span><br><span class="line">                    if (!f.mFromLayout) &#123;</span><br><span class="line">                        ViewGroup container = null;</span><br><span class="line">                 ...</span><br><span class="line">                            container = mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">                            if (container == null &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                                String resName;</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    resName = f.getResources().getResourceName(f.mContainerId);</span><br><span class="line">...</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mContainer = container;</span><br><span class="line">                        f.mView = f.performCreateView(f.performGetLayoutInflater(</span><br><span class="line">                                f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">                        if (f.mView != null) &#123;</span><br><span class="line">                            f.mView.setSaveFromParentEnabled(false);</span><br><span class="line">                            if (container != null) &#123;</span><br><span class="line">                                container.addView(f.mView);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (f.mHidden) &#123;</span><br><span class="line">                                f.mView.setVisibility(View.GONE);</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</span><br><span class="line">                                    false);</span><br><span class="line">                            // Only animate the view if it is visible. This is done after</span><br><span class="line">                            // dispatchOnFragmentViewCreated in case visibility is changed</span><br><span class="line">                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</span><br><span class="line">                                    &amp;&amp; f.mContainer != null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);</span><br><span class="line">                    if (f.mView != null) &#123;</span><br><span class="line">                        f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mSavedFragmentState = null;</span><br><span class="line">                &#125;</span><br><span class="line">                // fall through</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下Fragment的 performGetLayoutInflater() 方法，在该方法中又调用了其onGetLayoutInflater() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.Fragment</span><br><span class="line">LayoutInflater performGetLayoutInflater(Bundle savedInstanceState) &#123;</span><br><span class="line">    LayoutInflater layoutInflater = onGetLayoutInflater(savedInstanceState);</span><br><span class="line">    mLayoutInflater = layoutInflater;</span><br><span class="line">    return mLayoutInflater;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LayoutInflater getLayoutInflater(Bundle savedFragmentState) &#123;</span><br><span class="line">    if (mHost == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;onGetLayoutInflater() cannot be executed until the &quot;</span><br><span class="line">                + &quot;Fragment is attached to the FragmentManager.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutInflater result = mHost.onGetLayoutInflater();</span><br><span class="line">    getChildFragmentManager(); // Init if needed; use raw implementation below.</span><br><span class="line">    LayoutInflaterCompat.setFactory2(result, mChildFragmentManager.getLayoutInflaterFactory());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Fragment的getLayoutInflater() 方法中，通过调用 mHost.onGetLayoutInflater()获取了一个LayoutInflater对象。mHost 就是FragmentHostCallback对象，来看一下它的onGetLayoutInflater() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.FragmentHostCallback</span><br><span class="line">public LayoutInflater onGetLayoutInflater() &#123;</span><br><span class="line">    return (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FragmentHostCallback的onGetLayoutInflater() 方法实际上就是调用了mContext的getSystemService方法，这个就跟我们前面分析的通过LayoutInflater的from方法是一个意思，mContext实际上就是Fragment所在的Activity。再加上之前的分析我们可以得出一个结论，Fragment中的LayoutInflater是由Activity中的LayoutInflater clone而来，它们不是同一个对象，不过Fragment中的LayoutInflater把Activity的LayoutInflater设置的一些factory copy过来，相当于它们使用的是同样的工厂。</p><p>在Fragmen的getLayoutInflater方法中调用了 <code>LayoutInflaterCompat.setFactory2(result, mChildFragmentManager.getLayoutInflaterFactory());</code> ，其实就调用LayoutInflater的setFactory2() 方法。这个方法我们下一小结再讲。</p><h1 id="LayoutInflater的setFactory2-方法"><a href="#LayoutInflater的setFactory2-方法" class="headerlink" title="LayoutInflater的setFactory2() 方法"></a>LayoutInflater的setFactory2() 方法</h1><p>LayoutInflater的setFactory2方法很有意思，如果原来LayoutInflater上面的mFactory为null，就是把实际上mFactory、mFactory2均赋值为当前设置的factory。如果不为null创建了一个FactoryMerger对象赋值给mFactory、mFactory2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.view.LayoutInflater</span><br><span class="line">public void setFactory2(Factory2 factory) &#123;</span><br><span class="line">    if (mFactorySet) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (factory == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Given factory can not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mFactorySet = true;</span><br><span class="line">    if (mFactory == null) &#123;</span><br><span class="line">        mFactory = mFactory2 = factory;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们之前在Activity中设置了mFactory2，那么当在Fragment中的LayoutInflater调用setFactory2方法的时候，mFactory 、mFactory2 均不为空，那么就会走到else里面，也就是说创建了一个FactoryMerger对象。FactoryMerger实际上实现了Factory2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class FactoryMerger implements Factory2 &#123;</span><br><span class="line">    private final Factory mF1, mF2;</span><br><span class="line">    private final Factory2 mF12, mF22;</span><br><span class="line"></span><br><span class="line">    FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) &#123;</span><br><span class="line">        mF1 = f1;</span><br><span class="line">        mF2 = f2;</span><br><span class="line">        mF12 = f12;</span><br><span class="line">        mF22 = f22;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">        View v = mF1.onCreateView(name, context, attrs);</span><br><span class="line">        if (v != null) return v;</span><br><span class="line">        return mF2.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">        View v = mF12 != null ? mF12.onCreateView(parent, name, context, attrs)</span><br><span class="line">                : mF1.onCreateView(name, context, attrs);</span><br><span class="line">        if (v != null) return v;</span><br><span class="line">        return mF22 != null ? mF22.onCreateView(parent, name, context, attrs)</span><br><span class="line">                : mF2.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想到没有，当Fragment中的LayoutInflater中的Factory方法去执行的时候，实际上先执行的是mF12和mF1的onCreateView，我们知道在Fragment中设置的是mChildFragmentManager.getLayoutInflaterFactory()，mChildFragmentManager是FragmentManager，我们在Activity中通过getSupportFragmentManager获取也是FragmentManager对象。FragmentManager的实现类FragmentManagerImpl实现了Factory2接口，是用来解析<code>fragment</code>标签的。<br>可以看到，如果标签不是fragment，实际上它还是会直接返回的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.FragmentManager$FragmentManagerImpl</span><br><span class="line">@Override</span><br><span class="line">public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    if (!&quot;fragment&quot;.equals(name)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    return fragment.mView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实想想，这样的设计真的挺好，Fragment会复用了Activity的Factory对象，只是在解析fragment标签的时候，采用用FragmentManagerImpl来解析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信看完上面的内容，你对LayoutInflater应该有一个比较全面的了解了，具体怎么灵活运用就要看你的需求了。比如你想完成一个换肤框架，那么你首先肯定要获得所有需要换肤的控件，此时LayoutInflater的Factory2就可以派上用场了。通过给LayoutInflater设置Factory2，可以自己处理View的创建逻辑，获取相关的View，当你需要换肤的时候，给这些View设置新的属性即可。</p><p>我们再来回顾一些问题，现在你能够自己解答了吗？</p><ol><li>每次调用LayoutInflater的from方法都会创建一个新的LayoutInflater对象吗？</li><li>LayoutInflater的from方法中如果传递不同的Context对象会有什么不同？</li><li>调用View的getContext() 方法会获取一个Context，那么这个Context对象具体是谁呢？</li><li>为什么想要在xml中使用View，就必须要有两个参数的构造方法呢？</li><li>Fragment中有一个onCreateView方法，有一个参数是LayoutInflater，这么LayoutInflater对象是从哪来的呢？</li><li>LayoutInflater对象的真正创建时机是什么时候？</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AsyncTask需要注意的一些点</title>
      <link href="/2018/05/07/%E4%BD%BF%E7%94%A8AsyncTask%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/"/>
      <url>/2018/05/07/%E4%BD%BF%E7%94%A8AsyncTask%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>AsyncTask在面试中应该比较经常会问到，虽然我们现在开发中可能用的并不多。<br>它的使用还是比较简单的。</p><h1 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h1><p>下面以一个保存短信示例来演示一下AsyncTask的使用。<br><img src="https://upload-images.jianshu.io/upload_images/2083810-d910a0c137b90175.gif?imageMogr2/auto-orient/strip" alt="AsyncTask备份短信.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    private TextView tv_desc;</span><br><span class="line">    private ProgressBar progressBar;</span><br><span class="line">    private Button btn_backup;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv_desc = (TextView) findViewById(R.id.tv_desc);</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progressBar);</span><br><span class="line">        btn_backup = (Button) findViewById(R.id.btn_backup);</span><br><span class="line">        btn_backup.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                // new AsyncTask&lt;输入值, 进度, 处理结果&gt;;</span><br><span class="line">                new AsyncTask&lt;Void, Integer, Void&gt;() &#123;</span><br><span class="line">                    private int processCount = 0;</span><br><span class="line"></span><br><span class="line">                    //在子线程运行的方法</span><br><span class="line">                    @Override</span><br><span class="line">                    protected Void doInBackground(Void... params) &#123;</span><br><span class="line">                        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                            SystemClock.sleep(500);</span><br><span class="line">                            processCount++;</span><br><span class="line">                            //传递给onProgressUpdate</span><br><span class="line">                            //当然也可以直接用全局变量processCount</span><br><span class="line">                            publishProgress(processCount);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onPreExecute() &#123;</span><br><span class="line">                        //初始化数据</span><br><span class="line">                        progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">                        progressBar.setMax(100);</span><br><span class="line">                        progressBar.setProgress(0);</span><br><span class="line">                        tv_desc.setText(&quot;正在备份0/20条短信&quot;);</span><br><span class="line">                        btn_backup.setEnabled(false);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onPostExecute(Void aVoid) &#123;</span><br><span class="line">                        progressBar.setVisibility(View.GONE);</span><br><span class="line">                        tv_desc.setText(&quot;共备份了20条短信&quot;);</span><br><span class="line">                        btn_backup.setEnabled(true);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">                        System.out.println(values[0]);</span><br><span class="line">                        int num = values[0];</span><br><span class="line">                        progressBar.setProgress(num * 100 / 20);</span><br><span class="line">                        tv_desc.setText(&quot;正在备份&quot; + num + &quot;/20条短信&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AsyncTask需要注意的地方"><a href="#AsyncTask需要注意的地方" class="headerlink" title="AsyncTask需要注意的地方"></a>AsyncTask需要注意的地方</h3><p>AsyncTask算是应用了模板方法设计模式，具体的调用流程都已经封装好了，子类只需要重写一些必须的回调方法就可以轻松的完成任务了。</p><p>AsyncTask有四个比较重要的方法doInBackground、onPreExecute、onPostExecute、onProgressUpdate，虽然这些方法都标了有注解，比如WorkerThread是在工作线程调用，MainThread是在主线程中调用，但是这个实际上只是一个规则，如果你不按照这个规则来，程序运行也不会crash。这4个方法都是protected的，因此不能直接在AsyncTask的外部直接调用，doInBackground方法是必须要重写的，而其它3个方法需要结合实际看是都需要重写。另外如果你需要在AsyncTask中回调onProgressUpdate方法，需要自己在doInBackground中自己主动调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doInBackground // WorkerThread，抽象方法，需要重写</span><br><span class="line">onPreExecute // MainThread</span><br><span class="line">onPostExecute // MainThread</span><br><span class="line">onProgressUpdate // MainThread</span><br><span class="line"></span><br><span class="line">publishProgress // 开发者在doInBackground中主动调用，然后AsyncTask的onProgressUpdate方法会被回调。</span><br></pre></td></tr></table></figure><p>AsyncTask在每个版本都会有一些关键地方的变化，所以需要注意一些事项：</p><p>我们使用AsyncTask，一般是想在子线程中做耗时操作，然后把结果发送到主线程中，既然涉及到线程切换，那必须有Handler机制来保证。而且要必须保证Handler所关联的Looper对象已经创建，而且这个Looper是在主线程中创建。<br>这也就引出了AsyncTask类的加载实际和对象的初始化问题。</p><ol><li><p>AsyncTask类的加载线程问题。AsyncTask 类中有一个InternalHandler（也就是一个Handler）类型的类成员 sHandler，AsyncTask是使用sHandler对象来做线程切换。 在6.0以前（包括6.0），InternalHandler只有一个无参构造，因此sHandler引用所指向的InternalHandler对象必须在主线程中创建，因为只有主线程默认情况下已经创建了Looper对象。从Andorid4.1到Android5.0，sHandler的创建时饿汉式，也就是说当AsyncTask类加载的时候就会创建InternalHandler对象，为了保证InternalHandler是在主线程中创建，必须保证AsyncTask是在主线程中加载。当一个App进程启动的时候，在ActivityThread的main方法中会调用AsyncTask的的类方法init，这会触发AsyncTask类的加载，也就保证了AsyncTask是在主线程中加载的，继而保证了在主线程中创建InternalHandler对象，进而保证任务结果正常的切换到主线程。</p><p> 6.0的时候已经没有init方法了，但是有一个静态方法getHandler，这个时候InternalHandler的创建时属于懒汉式。此时InternalHandler同样能保证关联的Looper是主线程，因为InternalHandler在无参构造方法中，调用了super，传递了Looper.getMainLooper()。所以在6.0的时候没有必要再去管是不是在主线程中加载了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static Handler getHandler() &#123;</span><br><span class="line">    synchronized (AsyncTask.class) &#123;</span><br><span class="line">        if (sHandler == null) &#123;</span><br><span class="line">            sHandler = new InternalHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>到8.0之后，AysncTask的构造方法变为3个，不过对于开发者来说只能看到1个，另外两个是隐藏的API。所以可以认为和6.0、7.0的使用情况是一样的。InternalHandler还是懒加载创建。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">    this((Looper) null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public AsyncTask(@Nullable Handler handler) &#123;</span><br><span class="line">    this(handler != null ? handler.getLooper() : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>一些博客或者书籍里说，AsyncTask对象必须是在主线程中创建，并在主线程中调用其execute方法。这个说法并不完全准确。你真要是想在子线程中去创建AsyncTask对象并在子线程中去调用其execute方法，这个也没什么问题的。只不过通常来说，我们是为了让AsyncTask在子线程中做耗时操作，在主线程中回调进度方法并且收到结果回调，而且通常还有一个onPreExecute方法来做一些初始化的工作，这个onPreExecute方法是在execute方法中调用的，通常我们需要onPreExecute在主线程中回调，从这个角度上来说，AsyncTask对象应该是在主线程中创建并且在主线程中执行其execute方法。</p></li><li><p>不要在AsyncTask之外直接调用doInBackground、onPreExecute、onPostExecute 、onProgressUpdate ，这几个方法是有AsyncTask对象自己内部回调的。</p></li><li><p>AsyncTask只能执行一次，其内部有一个枚举类型的Status用于维护执行状态：PENDING、RUNNING、FINISHED。默认情况下是PENDING，表示可以执行，当调用execute方法之后，会检查其状态是否是PENDING，如果不是的话就会抛出异常。</p></li><li><p>在1.6之前AsyncTask是串行执行任务的，1.6的时候改为线程池并行执行任务，3.0之后为了防止并发执行错误，又改为了默认情况是的串行执行任务，不过添加了executeOnExecutor方法，通过由开发者自己提供Executor来实现并行执行任务。这种方式算是依赖注入的方式，符合设计模式中的里氏替换原则（Liskov Substitution principle），从这我们也可以看出依赖注入的好处，当目前的实现不满足开发者使用的时候可以由开发者自己来实现，解耦而且扩展性好。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android进程保活招数概览</title>
      <link href="/2018/05/01/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E6%8B%9B%E6%95%B0%E6%A6%82%E8%A7%88/"/>
      <url>/2018/05/01/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E6%8B%9B%E6%95%B0%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>Android中的进程保活应该分为两个方面：</p><ul><li>提高进程的优先级，减少被系统杀死的可能性</li><li>在进程已经被杀死的情况下，通过一些手段来重新启动应用进程</li></ul><p>本文针对这两方面来进程阐述，并给出相应的示例。其实主要也是在前人的基础上做了一个总结，并进行了一些实践。</p><blockquote><p>阅读本文的时候，可以先clone一份代码 <a href="https://github.com/sososeen09/android-process-daemon" target="_blank" rel="noopener">android-process-daemon</a>，这样的话可能理解更清晰。</p></blockquote><h1 id="进程等级与Low-Memory-Killer"><a href="#进程等级与Low-Memory-Killer" class="headerlink" title="进程等级与Low Memory Killer"></a>进程等级与Low Memory Killer</h1><p>在开始之前，首先有必要了解一下进程等级的概念。Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会对进程进行分类。 需要时，系统会首先消除重要性最低的进程，然后是清除重要性稍低一级的进程，依此类推，以回收系统资源。</p><p>进程等级：</p><ul><li><p>前台进程</p><ul><li>与用户正在交互的Activity</li><li>前台Activity以bind方式启动的Service</li><li>Service调用了startForground，绑定了Notification</li><li>正在执行生命周期的Service，例如在执行onCreate、onStart、onDestory</li><li>正在执行onReceive方法的BroadcastReceiver</li></ul></li><li><p>可见进程</p><ul><li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li><li>托管绑定到可见（或前台）Activity 的 Service。</li></ul></li><li><p>服务进程<br>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p></li><li><p>后台进程<br>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p></li><li><p>空进程<br>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p></li></ul><p>进程等级参考谷歌官方文档 <a href="https://developer.android.google.cn/guide/components/processes-and-threads.html?hl=zh-cn。" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/processes-and-threads.html?hl=zh-cn。</a></p><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫 Low Memory Killer，它是一种根据 OOM_ADJ 阈值级别触发相应力度的内存回收的机制。</p><p>关于 OOM_ADJ 的说明如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-12de25557189a20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自——腾讯Bugly干货分享】Android 进程保活招式大全.png"></p><p>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在Low Memory Killer 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p><p>Android 手机中进程被杀死可能有如下情况：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-56c4b4339858dfa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自——腾讯Bugly干货分享】Android 进程保活招式大全.png"></p><p>所以，想要应用降低被杀死的可能性就要尽量提高进程的优先级，这样才会在系统内存不足的时候减少被杀死的可能性。在这里，我们只是说减少被杀死的可能性，而不是说一定不会杀死。除了系统应用，或者厂商白名单中的应用，一般的应用都有被杀死的可能性。</p><p>我们可以通过adb命令来查看进程的优先级<br>首先使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | grep  packageName</span><br></pre></td></tr></table></figure><p>获取进程的PID，然后使用命令获取进程的oom_adj值，这个值越小，代表优先级越高越不容易被杀死：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/PID/oom_adj</span><br></pre></td></tr></table></figure><p>比如，先获取adb进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># adb shell ps |grep com.sososeen09.process</span><br><span class="line">u0_a85    1740  486  1013428 64840 00000000 f7491e65 S com.sososeen09.process.daemon.sample</span><br></pre></td></tr></table></figure><p>然后获取oom_adj值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># adb shell cat /proc/1740/oom_adj</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>此时该进程运行在前台，它的优先级为0，这种情况下被杀死的可能性很小。当通过Home键把当前引用退回后台的时候，重新查看一下oom_adj，这个值可能会变为6（不同的rom情况可能不一样）。</p><h1 id="提升进程优先级"><a href="#提升进程优先级" class="headerlink" title="提升进程优先级"></a>提升进程优先级</h1><h2 id="利用Activity提升权限"><a href="#利用Activity提升权限" class="headerlink" title="利用Activity提升权限"></a>利用Activity提升权限</h2><p>前面我们也讲了，当应用切换后后台的时候进程的优先级变得很低，被杀死的可能性就增大了。如果此时用户通过电源键进行息屏了。可以考虑通过监听息屏和解锁的广播，在息屏的时候启动一个只有一个像素的Activity。这样的话，在息屏这段时间，应用的进程优先级很高，不容易被杀死。采用这种方案要注意的是要使用户无感知。</p><p>该方案主要解决第三方应用及系统管理工具在检测到锁屏事件后一段时间（一般为5分钟以内）内会杀死后台进程，已达到省电的目的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class KeepLiveActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;KeepLiveActivity&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        Log.e(TAG,&quot;start Keep app activity&quot;);</span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        //设置这个act 左上角</span><br><span class="line">        window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line">        //宽 高都为1</span><br><span class="line">        WindowManager.LayoutParams attributes = window.getAttributes();</span><br><span class="line">        attributes.width = 1;</span><br><span class="line">        attributes.height = 1;</span><br><span class="line">        attributes.x = 0;</span><br><span class="line">        attributes.y = 0;</span><br><span class="line">        window.setAttributes(attributes);</span><br><span class="line"></span><br><span class="line">        KeepLiveManager.getInstance().setKeep(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        Log.e(TAG,&quot;stop keep app activity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让无用无感知，Activity要设置的小（只有一个像素），无背景并且是透明的。此外还要注意一点，需要设置Activity的taskAffinity 属性，要与我们的应用默认的taskAffinity不同，否则当这个Activity启动的时候，会把我们的应用所在的任务栈移动到前台，当屏幕解锁之后，会发现我们的应用移动到前台了。而用户在息屏的时候明明已经把我们的应用切换到后台了，这会给用户造成困扰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.keepliveactivity.KeepLiveActivity&quot;</span><br><span class="line">    android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:finishOnTaskLaunch=&quot;false&quot;</span><br><span class="line">    android:taskAffinity=&quot;com.sososeen09.daemon.keep.live&quot;</span><br><span class="line">    android:theme=&quot;@style/KeepLiveTheme&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;KeepLiveTheme&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>要有一个BroadcastReceiver，用于监听屏幕的点亮和关闭的广播，在这里我们使用了<code>Intent.ACTION_USER_PRESENT</code>这个action，它会早于系统发出的<code>Intent.ACTION_SCREEN_OFF</code> 广播。这样可以更早的结束之前息屏的时候启动的Activity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class KeepLiveReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    private static final String TAG = &quot;KeepLiveReceiver&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        Log.e(TAG, &quot;receive action:&quot; + action);</span><br><span class="line">        //屏幕关闭事件</span><br><span class="line">        if (TextUtils.equals(action, Intent.ACTION_SCREEN_OFF)) &#123;</span><br><span class="line">            //关屏 开启1px activity</span><br><span class="line">            KeepLiveManager.getInstance().startKeepLiveActivity(context);</span><br><span class="line">            // 解锁事件</span><br><span class="line">        &#125; else if (TextUtils.equals(action, Intent.ACTION_USER_PRESENT)) &#123;</span><br><span class="line">            KeepLiveManager.getInstance().finishKeepLiveActivity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeepLiveManager.getInstance().startKeepLiveService(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service绑定一个Notification的方式："><a href="#Service绑定一个Notification的方式：" class="headerlink" title="Service绑定一个Notification的方式："></a>Service绑定一个Notification的方式：</h2><p>应用启动一个Service，并且Service通过调用startForeground方法来绑定一个前台的通知时，可以有效的提升进程的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    NotificationCompat.Builder builder = new NotificationCompat.Builder(this);</span><br><span class="line">    builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">    builder.setContentTitle(&quot;Foreground&quot;);</span><br><span class="line">    builder.setContentText(&quot;I am a foreground service&quot;);</span><br><span class="line">    builder.setContentInfo(&quot;Content Info&quot;);</span><br><span class="line">    builder.setWhen(System.currentTimeMillis());</span><br><span class="line">    Intent activityIntent = new Intent(this, MainActivity.class);</span><br><span class="line">    PendingIntent pendingIntent = PendingIntent.getActivity(this, 1, activityIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    builder.setContentIntent(pendingIntent);</span><br><span class="line">    Notification notification = builder.build();</span><br><span class="line">    startForeground(FOREGROUND_ID, notification);</span><br><span class="line">    return super.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的话会在通知栏显示一个通知，该方式属于比较文明的。</p><p>我们可以使用 命令来查看当前正在运行的服务信息，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services com.sososeen09.process</span><br></pre></td></tr></table></figure><p>可以得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ACTIVITY MANAGER SERVICES (dumpsys activity services)</span><br><span class="line">  User 0 active services:</span><br><span class="line">  * ServiceRecord&#123;d18c80d u0 com.sososeen09.process.daemon.sample/.service.WhiteService&#125;</span><br><span class="line">    intent=&#123;cmp=com.sososeen09.process.daemon.sample/.service.WhiteService&#125;</span><br><span class="line">    packageName=com.sososeen09.process.daemon.sample</span><br><span class="line">    processName=com.sososeen09.process.daemon.sample:white</span><br><span class="line">    baseDir=/data/app/com.sososeen09.process.daemon.sample-2/base.apk</span><br><span class="line">    dataDir=/data/data/com.sososeen09.process.daemon.sample</span><br><span class="line">    app=ProcessRecord&#123;696d809 2478:com.sososeen09.process.daemon.sample:white/u0a85&#125;</span><br><span class="line">    isForeground=true foregroundId=1001 foregroundNoti=Notification(pri=0 contentView=com.sososeen09.process.daemon.sample/0x1090077 vibrate=null sound=null defaults=0x0 flags=0x62 color=0x00000000 vis=PRIVATE)</span><br><span class="line">    createTime=-44s879ms startingBgTimeout=--</span><br><span class="line">    lastActivity=-44s860ms restartTime=-44s860ms createdFromFg=true</span><br><span class="line">    startRequested=true delayedStop=false stopIfKilled=false callStart=true lastStartId=1</span><br><span class="line"></span><br><span class="line">  * ServiceRecord&#123;e4782a4 u0 com.sososeen09.process.daemon.sample/.service.NormalService&#125;</span><br><span class="line">    intent=&#123;cmp=com.sososeen09.process.daemon.sample/.service.NormalService&#125;</span><br><span class="line">    packageName=com.sososeen09.process.daemon.sample</span><br><span class="line">    processName=com.sososeen09.process.daemon.sample:normal</span><br><span class="line">    baseDir=/data/app/com.sososeen09.process.daemon.sample-2/base.apk</span><br><span class="line">    dataDir=/data/data/com.sososeen09.process.daemon.sample</span><br><span class="line">    app=ProcessRecord&#123;2402ea0e 2459:com.sososeen09.process.daemon.sample:normal/u0a85&#125;</span><br><span class="line">    createTime=-48s510ms startingBgTimeout=--</span><br><span class="line">    lastActivity=-48s479ms restartTime=-48s479ms createdFromFg=true</span><br><span class="line">    startRequested=true delayedStop=false stopIfKilled=false callStart=true lastStartId=1</span><br><span class="line"></span><br><span class="line">  Connection bindings to services:</span><br><span class="line">  * ConnectionRecord&#123;3b4eb582 u0 CR DEAD com.sososeen09.process.daemon.sample/.acount.AuthenticationService:@2a1598cd&#125;</span><br><span class="line">    binding=AppBindRecord&#123;d621c2f com.sososeen09.process.daemon.sample/.acount.AuthenticationService:system&#125;</span><br><span class="line">    conn=android.app.LoadedApk$ServiceDispatcher$InnerConnection@2a1598cd flags=0x1</span><br></pre></td></tr></table></figure><p>可以看到，调用了startForeground方法的Service是一个前台进程了，有一个属性是isForeground=true。</p><p>在这种情况下，当应用所在进程退回到后台时，oom_adj的值为1，不容易被杀死。</p><h2 id="隐藏Notification的Service"><a href="#隐藏Notification的Service" class="headerlink" title="隐藏Notification的Service"></a>隐藏Notification的Service</h2><p>前面讲的startForeground，会在通知栏中显示一个通知。有一种方式利用了系统漏洞，把通知栏给隐藏，让用户无感知。不过这种方式跟版本有关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Notification notification = new Notification();</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; 18) &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">            // start InnerService</span><br><span class="line">            startService(new Intent(this, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在InnerService中关闭Notification</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    try &#123;</span><br><span class="line">        startForeground(NOTIFICATION_ID, new Notification());</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    stopSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以发现，在Tinker中，由于在Patch的过程是在另一个服务进程中，为了保证这个服务进程不被干掉，Tinker也利用了这个系统的漏洞。具体可以查看<a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java" target="_blank" rel="noopener">TinkerPatchService</a></p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-22f9de159b910a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tinker中Service进程保活.png"></p><h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>上面讲了提升进程优先级的方式了来减少应用被杀死的可能性，但是当应用真的被杀死的时候，我们就要想办法来拉活进行了。</p><h2 id="利用广播拉活"><a href="#利用广播拉活" class="headerlink" title="利用广播拉活"></a>利用广播拉活</h2><p>这个在推送中比较常见，当几个App都集成了同一家的推送，只要有一个App起来，就会发送一个广播，这样其它的App接收到这个广播之后，开启一个服务，就把进程给启动起来了。各大厂家的全家桶也是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class WakeReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1001;</span><br><span class="line">    public final static String ACTION_WAKE = &quot;com.sososeen09.wake&quot;;</span><br><span class="line">    private final static String TAG = &quot;WakeReceiver&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        if (action != null &amp;&amp; action.equals(ACTION_WAKE)) &#123;</span><br><span class="line">            context.startService(new Intent(context, WakeService.class));</span><br><span class="line"></span><br><span class="line">            Log.e(TAG, &quot;onReceive: &quot; + &quot;收到广播，兄弟们要起来了。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class WakeService extends Service &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Notification notification = new Notification();</span><br><span class="line">                if (Build.VERSION.SDK_INT &lt; 18) &#123;</span><br><span class="line">                    startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    startForeground(NOTIFICATION_ID, notification);</span><br><span class="line">                    // start InnerService</span><br><span class="line">                    startService(new Intent(this, WakeInnerService.class));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, &quot;onReceive: &quot; + &quot;我是 WakeService，我起来了，谢谢兄弟。。。&quot; + ProcessUtils.getProcessName(this));</span><br><span class="line">            return super.onStartCommand(intent, flags, startId);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class WakeInnerService extends Service &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCreate() &#123;</span><br><span class="line">            super.onCreate();</span><br><span class="line">            try &#123;</span><br><span class="line">                startForeground(NOTIFICATION_ID, new Notification());</span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onDestroy() &#123;</span><br><span class="line">            stopForeground(true);</span><br><span class="line">            super.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也可以监听系统的广播来达到启动应用进程的方式，但是从android 7.0开始，对广播进行了限制，而且在8.0更加严格<a href="https://developer.android.google.cn/about/versions/oreo/background.html#broadcasts" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background.html#broadcasts</a></p><p>可静态注册广播列表：<br><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p><h2 id="系统Service机制拉活"><a href="#系统Service机制拉活" class="headerlink" title="系统Service机制拉活"></a>系统Service机制拉活</h2><p>将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活。</p><ul><li>START_STICKY：<br>  “粘性”。如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。</li><li>START_NOT_STICKY：<br>  “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。</li><li>START_REDELIVER_INTENT：<br>  重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。</li><li>START_STICKY_COMPATIBILITY：<br>  START_STICKY的兼容版本，但不保证服务被kill后一定能重启。<br>只要 targetSdkVersion 不小于5，就默认是 START_STICKY。<br>但是某些ROM 系统不会拉活。并且经过测试，Service 第一次被异常杀死后很快被重启，第二次会比第一次慢，第三次又会比前一次慢，一旦在短时间内 Service 被杀死4-5次，则系统不再拉起。</li></ul><h2 id="使用账户同步拉活"><a href="#使用账户同步拉活" class="headerlink" title="使用账户同步拉活"></a>使用账户同步拉活</h2><p>手机系统设置里会有“帐户”一项功能，任何第三方APP都可以通过此功能将数据在一定时间内同步到服务器中去。系统在将APP帐户同步时，会将未启动的APP进程拉活。 如何利用账户同步可以参考 <a href="https://github.com/googlesamples/android-BasicSyncAdapter" target="_blank" rel="noopener">https://github.com/googlesamples/android-BasicSyncAdapter</a></p><p>但是账户同步这个东西，在不同的手机上可能在同步时间不同。</p><p>关于这种方式，这里就不多讲了，有兴趣的可以搜索相关文章，在<a href="[https://github.com/sososeen09/android-process-daemon">示例代码</a>中也有相关的介绍。](<a href="https://github.com/sososeen09/android-process-daemon)中也有相关的介绍。" target="_blank" rel="noopener">https://github.com/sososeen09/android-process-daemon)中也有相关的介绍。</a>)</p><h2 id="使用JobSchedule拉活"><a href="#使用JobSchedule拉活" class="headerlink" title="使用JobSchedule拉活"></a>使用JobSchedule拉活</h2><p>JobScheduler允许在特定状态与特定时间间隔周期执行任务。可以利用它的这个特点完成保活的功能，效果类似开启一个定时器，与普通定时器不同的是其调度由系统完成。它是在Android5.0之后推出的，在5.0之前无法使用。</p><p>首先写一个Service类继承自JobService，在小于7.0的系统上，JobInfo可以周期性的执行，但是在7.0以上的系统上，不能周期性的执行了。因此可以在JobService的onStartJob回调方法中继续开启一个任务来执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public class MyJobService extends JobService &#123;</span><br><span class="line">    private static final String TAG = &quot;MyJobService&quot;;</span><br><span class="line"></span><br><span class="line">    public static void startJob(Context context) &#123;</span><br><span class="line">        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line"></span><br><span class="line">        JobInfo.Builder builder = new JobInfo.Builder(10, new ComponentName(context.getPackageName(), MyJobService.class.getName())).setPersisted(true);</span><br><span class="line"></span><br><span class="line">        //小于7.0</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">            // 每隔1s 执行一次 job</span><br><span class="line">            builder.setPeriodic(1_000);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //延迟执行任务</span><br><span class="line">            builder.setMinimumLatency(1_000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (jobScheduler != null) &#123;</span><br><span class="line">            jobScheduler.schedule(builder.build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(JobParameters params) &#123;</span><br><span class="line">        Log.e(TAG, &quot;start job schedule&quot;);</span><br><span class="line">        //如果7.0以上 轮训</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">            startJob(this);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters params) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AndroidManifest.xml并需要声明权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.jobschedule.MyJobService&quot;</span><br><span class="line">    android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; /&gt;</span><br></pre></td></tr></table></figure><p>不过在某些ROM可能并不能达到需要的效果(某米)</p><h2 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h2><p>我们都直到Service可以以bind方式启动，当Service被系统杀死的时候，会在ServiceConnection的onServiceDisconnected方法中会收到回调。利用这个原理，可以在主进程中进行有一个LocalService，在子进程中有RemoteService。LocalService中以bind和start方式启动RemoteService，同时RemoteService以bind和start方式启动LocalService。并且在它们各自的ServiceConnection的onServiceDisconnected方法中重新bind和start。</p><p>这种Java层通过Service这种双进程守护的方式，可以有效的保证进程的存活能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LocalService extends Service &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1003;</span><br><span class="line">    private static final String TAG = &quot;LocalService&quot;;</span><br><span class="line">    private ServiceConnection serviceConnection;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        serviceConnection = new LocalServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class LocalServiceConnection implements ServiceConnection &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            //服务连接后回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.e(TAG, &quot;remote service died，make it alive&quot;);</span><br><span class="line">            //连接中断后回调</span><br><span class="line">            startService(new Intent(LocalService.this, RemoteService.class));</span><br><span class="line">            bindService(new Intent(LocalService.this, RemoteService.class), serviceConnection,</span><br><span class="line">                    BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyBinder extends IMyAidlInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoteService也类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteService extends Service &#123;</span><br><span class="line">    private final static int NOTIFICATION_ID = 1002;</span><br><span class="line">    private static final String TAG = &quot;RemoteService&quot;;</span><br><span class="line">    private ServiceConnection serviceConnection;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        serviceConnection = new RemoteServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RemoteServiceConnection implements ServiceConnection &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            //服务连接后回调</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.e(TAG, &quot;main process local service died，make it alive&quot;);</span><br><span class="line">            //连接中断后回调</span><br><span class="line">            startService(new Intent(RemoteService.this, LocalService.class));</span><br><span class="line">            bindService(new Intent(RemoteService.this, LocalService.class), serviceConnection,</span><br><span class="line">                    BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyBinder extends IMyAidlInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了提高Service所在进程的优先级，可以结合我们之前讲的startForground来开启一个Notification的方式，提高进程的优先级，以降低被杀风险。</p><h2 id="其它方式拉活"><a href="#其它方式拉活" class="headerlink" title="其它方式拉活"></a>其它方式拉活</h2><p>其它我们还可以使用推送拉活，根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送，这样也可以保证进程可以被推送唤醒。</p><p>Native拉活，Native fork子进程用于观察当前app主进程的存亡状态。这种在5.0以前的系统上效果比较高，对于5.0以上成功率极低。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>提升进程优先级的方式</p><ul><li><p>Activity提权，监听屏幕的息屏和解锁，使用一个1个像素的Activity</p></li><li><p>Service提权，Service通过startForground方法来开启一个Notification</p></li></ul><p>进程拉活</p><ul><li><p>通过广播的方式</p></li><li><p>通过Service在onStartCommand的返回值，START_STICK，由系统拉活，在短时间内如果多次被杀死可能就再也启动不了了</p></li><li><p>通过账户同步拉活</p></li><li><p>通过JobSchedule拉活</p></li><li><p>通过Service的bind启动的方式，双进程守护拉活</p></li><li><p>推送拉活</p></li><li><p>Native fork子进程的方式拉活</p></li></ul><blockquote><p>更多详情，请查看 <a href="https://github.com/sososeen09/android-process-daemon" target="_blank" rel="noopener">android-process-daemon</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.google.cn/about/versions/oreo/background#broadcasts" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background#broadcasts</a></li><li><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></li><li><a href="https://github.com/googlesamples/android-BasicSyncAdapter" target="_blank" rel="noopener">https://github.com/googlesamples/android-BasicSyncAdapter</a></li><li><a href="https://segmentfault.com/a/1190000006251859" target="_blank" rel="noopener">【腾讯Bugly干货分享】Android 进程保活招式大全</a></li><li><a href="https://www.jianshu.com/p/63aafe3c12af" target="_blank" rel="noopener">关于 Android 进程保活，你所需要知道的一切</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件——ContentProvider的工作过程</title>
      <link href="/2018/04/14/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ContentProvider%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/04/14/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ContentProvider%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>ContentProvider是内容提供者，对外提供数据。内部运行依赖Binde机制。想要自己写一个ContentProvider向外部提供数据，需要继承ContentProvider并重写一下六个方法，在ContentProvider中提供了增删改查的方法，一般这个增删改查会通过SqliteDataBase这个数据库的方式对外提供增删改查的功能。也可以不这么做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onCreate() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public String getType(@NonNull Uri uri) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在AndroidManifest.xml中去注册：<br>authorities 相当于是个地址<br>permission 用于控制权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;.provider.BookProvider&quot;</span><br><span class="line">    android:authorities=&quot;com.sososeen09.knowledge.provider.book&quot;</span><br><span class="line">    android:permission=&quot;com.sososeen09.PROVIDER&quot;</span><br><span class="line">    android:process=&quot;:provider&quot;/&gt;</span><br></pre></td></tr></table></figure><p>其它客户端查询，需要用到ContentResolver对象，ContentResolver是抽象类，它的实现是ContextImpl中的ApplicationContentResolver，是在ContextImpl的构造方法中创建的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uri bookUri = Uri.parse(&quot;content://com.sososeen09.knowledge.provider.book/book&quot;);</span><br><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;_id&quot;, 6);</span><br><span class="line">getContentResolver().insert(bookUri, values);</span><br><span class="line">Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);</span><br></pre></td></tr></table></figure><p>Context的getContentResolver方法实际上获取的就是ContextImpl的ApplicationContentResolver类型的成员mContentResolver。</p><p>当ContentProvider所在进程还未创建时，第一次访问ContentProvider会触发ContentProvider所在进程的创建和ContentProvider对象的创建。通过ContentProvider的4个方法中的任何一个都会触发ContentProvider的启动过程。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们分析<code>getContentResolver().query</code> 方法触发的流程。</p><p>ContextWrapper的getContentResolver的方法如下，还是通过mBase来获取，这个mBase实际上是ContextImpl对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return mBase.getContentResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下ContextImpl的getContentResolver方法，直接返回了一个成员变量mContentResolver。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return mContentResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个mContentResolver实际上是ContentResolver的子类ApplicationContentResolver，该对象是在ContextImpl的构造方法中创建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private ContextImpl(ContextImpl container, ActivityThread mainThread,</span><br><span class="line">                    LoadedApk packageInfo, IBinder activityToken, UserHandle user, int flags,</span><br><span class="line">                    Display display, Configuration overrideConfiguration, int createDisplayWithId) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    mContentResolver = new ApplicationContentResolver(this, mainThread, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取了ContentResolver对象之后，调用它的query方法。在ContentResolver的query方法中首先会调用acquireUnstableProvider来获取一个IContentProvider对象。</p><p>在这里要说一下，返回值是IContentProvider对象，它继承自IInterface，也就是说它的实现类会是一个Binder对象。这也是因此ContentProvider不是一个Binder对象，而且一般ContentProvider和客户端不再同一个进程中。它的增删改查方法的结果肯定是需要一个通过一个Binder对象来进行IPC过程的传输。在这里就是IContentProvider。在这里它的实现是ContentProviderNative的子类ContentProvider.Transport。ContentProvider.Transport对象运行在ContentProvider的同一个进程，在远程有个特代理是ContentProviderProxy。</p><p>acquireUnstableProvider方法由ApplicationContentResolver实现，在ApplicationContentResolver中还有一个重写的方法是acquireProvider，它们都是做一个中转，调用的是ActivityThread的acquireProvider方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final IContentProvider acquireProvider(</span><br><span class="line">        Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // There is a possible race here.  Another thread may try to acquire</span><br><span class="line">    // the same provider at the same time.  When this happens, we want to ensure</span><br><span class="line">    // that the first one wins.</span><br><span class="line">    // Note that we cannot hold the lock while acquiring and installing the</span><br><span class="line">    // provider since it might take a long time to run and it could also potentially</span><br><span class="line">    // be re-entrant in the case where the provider is in the same process.</span><br><span class="line">    IActivityManager.ContentProviderHolder holder = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Install provider will increment the reference count for us, and break</span><br><span class="line">    // any ties in the race.</span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            true /*noisy*/, holder.noReleaseNeeded, stable);</span><br><span class="line">    return holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它首先调用acquireExistingProvider，查看是否有缓存的IContentProvider对象，如果有的话就直接返回这个缓存对象。缓存存放在mProviderMap这个Map集合中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// The lock of mProviderMap protects the following variables.</span><br><span class="line">final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class="line">        = new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure><p>如果当前没有缓存的话，就需要通过一个IPC过程调用AMS的getContentProvider方法来获取一个ContentProviderHolder，ContentProviderHolder实现了Parcelable接口，因此它可以被进程间传递，它就是客户端的ContentProvider的一个代理对象的包装类。之后调用installProvider方法还要修改ContentProvider的引用计数器。</p><p>AMS的getContentProvider方法又会调用getContentProviderImpl方法，在该方法中会判断所要请求的ContentProvider进程是否已经存在，如果不存在的话就会调用startProcessLocked方法来创建ContentProvider的进程并安装ContentProvider。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private ContentProviderHolder getContentProviderImpl(IApplicationThread caller,</span><br><span class="line">                                                     String name, IBinder token, boolean stable, int userId) &#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = null;</span><br><span class="line">    ProviderInfo cpi = null;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ProcessRecord r = null;</span><br><span class="line">      ...</span><br><span class="line">        boolean checkCrossUser = true;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, &quot;getContentProviderImpl: getProviderByName&quot;);</span><br><span class="line"></span><br><span class="line">        // First check if this content provider has been published...</span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">        // If that didn&apos;t work, check if it exists for user 0 and then</span><br><span class="line">        // verify that it&apos;s a singleton provider before using it.</span><br><span class="line">   ...</span><br><span class="line">        boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed;</span><br><span class="line">   ...</span><br><span class="line">        if (!providerRunning) &#123;</span><br><span class="line">            ...</span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, false);</span><br><span class="line">                    if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                           </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, false, 0, &quot;content provider&quot;,</span><br><span class="line">                                new ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                        cpi.name), false, false, false);</span><br><span class="line">                       ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">    return cpr != null ? cpr.newHolder(conn) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法可以看出，如果ContentProvider没有在运行，而且它所在的进程没有存在的话就会调用AMS自身的startProcessLocked方法来创建进程。AMS的startProcessLocked会调用Process的start方法，在该方法表明所要启动一个新进程，并且调用android.app.ActivityThread的main方法作为入口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">                                      String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">  ...</span><br><span class="line">        // Start the process.  It will either succeed and return a result containing</span><br><span class="line">        // the PID of the new process, or else throw a RuntimeException.</span><br><span class="line">        boolean isActivityProcess = (entryPoint == null);</span><br><span class="line">        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line">     ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App进程启动的流程如下，这里我们就不细讲了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-dc58c61994176d36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="App进程启动的流程.png"></p><p>最终ActivityThread的main方法会被调用，该方法中会创建ActivityThread对象，并创建主线程的Looper对象，调用ActivityThread的attach方法，并且传递的参数为false，表明不是系统进程。之后就开始消息循环了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityThread的attach方法中，会通过一个IPC过程调用AMS的attachApplication方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">    ...</span><br><span class="line">        final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        try &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS的attachApplication方法又会调用其attachApplicationLocked方法，在该方法中又会通过IPC过程调用ApplicationThread的bindApplication方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                                  List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                                  ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                                  IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                                  IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                                  boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">                                  boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">                                  CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">    if (services != null) &#123;</span><br><span class="line">        // Setup the service cache in the ServiceManager</span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppBindData是一个JavaBean独享，用于ActivityThreadThread绑定的App的信息。<br>ApplicationThread的bindApplication方法是在Binder线程池中执行，因此通过一个Handler发送<br>H.BIND_APPLICATION消息切换到主线程。在Handler H的handleMessage方法中会从msg中取出AppBindData对象，并且调用ActivityThread的handleBindApplication方法。</p><p>在这里面做了5步操作：</p><ol><li>创建ContextImpl对象</li><li>创建Instrumentation对象</li><li>创建Application对象</li><li>调用<code>installContentProviders(app, data.providers)</code>方法启动当前进程的ContentProvider并调用其onCreate方法</li><li>调用Application的onCreate方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    // If the app is Honeycomb MR1 or earlier, switch its AsyncTask</span><br><span class="line">    // implementation to use the pool executor.  Normally, we use the</span><br><span class="line">    // serialized executor as the default. This has to happen in the</span><br><span class="line">    // main thread so the main looper is set right.</span><br><span class="line">    if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    // Instrumentation info affects the class loader, so load it before</span><br><span class="line">    // setting up the app context.</span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    if (data.instrumentationName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ii = new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ii = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1 创建 ContextImpl对象</span><br><span class="line">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">...</span><br><span class="line">    // 2 创建Instrumentation对象</span><br><span class="line">    // Continue loading instrumentation.</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        final ApplicationInfo instrApp = new ApplicationInfo();</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), false, true, false);</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                            + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ComponentName component = new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation = new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...// 3 创建 Applcation对象</span><br><span class="line">    try &#123;</span><br><span class="line">        // If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">        // a restricted environment with the base application class.</span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        // don&apos;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">        // app&apos;s custom Application class</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 4 启动当前进程的ContentProvider，并调用其方法</span><br><span class="line">        if (!data.restrictedBackupMode) &#123;</span><br><span class="line">            if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">                // For process that contains content providers, we want to</span><br><span class="line">                // ensure that the JIT is enabled &quot;at some point&quot;.</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">        // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">...     // 5 调用Application的onCreate方法</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下ActivityThread的installContentProviders方法。在该方法中主要遍历当前进程的ProviderInfo信息，通过调用installProvider方法来构建一个IActivityManager.ContentProviderHolder对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void installContentProviders(</span><br><span class="line">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">            new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    for (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        if (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = new StringBuilder(128);</span><br><span class="line">            buf.append(&quot;Pub &quot;);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(&quot;: &quot;);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</span><br><span class="line">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</span><br><span class="line">        if (cph != null) &#123;</span><br><span class="line">            cph.noReleaseNeeded = true;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们之前说的吗，ContentProvider对象是无法跨进程调用的，因此需要一个Binder对象用于给客户端使用。ContentProviderHolder实现了Pacelable接口，可以在进程间传递数据。它实际上就是一个JavaBean对象，但是里面封装了IContentProvider，它实际上会作为一个Binder对象用于进程间方法的调用。我们前面也已经提了。IContentProvider的实现是ContentProviderNative的子类ContentProvider.Transport。ContentProvider.Transport对象运行在ContentProvider的同一个进程，在远程有个特代理是ContentProviderProxy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static class ContentProviderHolder implements Parcelable &#123;</span><br><span class="line">    public final ProviderInfo info;</span><br><span class="line">    public IContentProvider provider;</span><br><span class="line">    public IBinder connection;</span><br><span class="line">    public boolean noReleaseNeeded;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下ActivityThread的installProvider方法，可以看到首先通过类加载器创建了ContentProvider对象，然后调用了ContentProvider的attachInfo方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private IActivityManager.ContentProviderHolder installProvider(Context context,</span><br><span class="line">                                                               IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">                                                               boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">    ContentProvider localProvider = null;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    if (holder == null || holder.provider == null) &#123;</span><br><span class="line">       ...</span><br><span class="line">        Context c = null;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">        if (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; else if (mInitialApplication != null &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            final java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            localProvider = (ContentProvider)cl.</span><br><span class="line">                    loadClass(info.name).newInstance();</span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">...</span><br><span class="line">            // XXX Need to create the correct context for this provider.</span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line">        &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        provider = holder.provider;</span><br><span class="line">        if (DEBUG_PROVIDER) Slog.v(TAG, &quot;Installing external provider &quot; + info.authority + &quot;: &quot;</span><br><span class="line">                + info.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">    return retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一下ContentProvider的attachInfo方法，该方法会调用3个参数的重载方法，在该方法中调用了ContextProvider的onCreate方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123;</span><br><span class="line">    mNoPerms = testing;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Only allow it to be set once, so after the content service gives</span><br><span class="line">     * this to us clients can&apos;t change it.</span><br><span class="line">     */</span><br><span class="line">    if (mContext == null) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        if (context != null) &#123;</span><br><span class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                    Context.APP_OPS_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mMyUid = Process.myUid();</span><br><span class="line">        if (info != null) &#123;</span><br><span class="line">            setReadPermission(info.readPermission);</span><br><span class="line">            setWritePermission(info.writePermission);</span><br><span class="line">            setPathPermissions(info.pathPermissions);</span><br><span class="line">            mExported = info.exported;</span><br><span class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0;</span><br><span class="line">            setAuthorities(info.authority);</span><br><span class="line">        &#125;</span><br><span class="line">        ContentProvider.this.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面的分析可知，ContentProvider的onCreate方法是在Application的onCreate方法之前调用的。当然了，还是要晚于Application的attachBaseContext方法。</p><p>ContentProvider创建完毕并启动之后还没有完事，会通过一个IPC过程调用AMS的publishContentProviders方法，此时传递ApplicationThread对象和创建完毕的ContentProviderHolder集合。publishContentProviders方法中也即是在AMS端存一下ContentProvider的记录，这里就不再细说了。</p><p>到此，ContentProvider所在的进程已经创建完毕，并且ContentProvider也已经全部启动起来。但是还没有完，调起ContentResolver发起query方法的那边还在等着返回结果呢。回到ContentResolver的query方法。注意此时客户端获取的IContentProvider对象是ContentProviderProxy，它是ContentProviderNative的内部类，通过IPC过程调用到ContentProviderNative.ContentProvider.Transport中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContentResolver</span><br><span class="line">public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,</span><br><span class="line">                                    @Nullable String[] projection, @Nullable String selection,</span><br><span class="line">                                    @Nullable String[] selectionArgs, @Nullable String sortOrder,</span><br><span class="line">                                    @Nullable CancellationSignal cancellationSignal) &#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, &quot;uri&quot;);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    if (unstableProvider == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = null;</span><br><span class="line">    Cursor qCursor = null;</span><br><span class="line">    try &#123;</span><br><span class="line">  ...</span><br><span class="line">        try &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">            // The remote process has died...  but we only hold an unstable</span><br><span class="line">            // reference though, so we might recover!!!  Let&apos;s try!!!!</span><br><span class="line">            // This is exciting!!1!!1!!!!1</span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            if (stableProvider == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (qCursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Force query execution.  Might fail and throw a runtime exception here.</span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        long durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);</span><br><span class="line"></span><br><span class="line">        // Wrap the cursor object into CursorWrapperInner object.</span><br><span class="line">        final IContentProvider provider = (stableProvider != null) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = null;</span><br><span class="line">        qCursor = null;</span><br><span class="line">        return wrapper;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下ContentProvider.Transport的query方法，由于ContentProvider.Transport是非静态内部类，因此持有ContentProvider的引用，所以内部调用了ContentProvider的query方法的返回值，返回的结果也会通过一个IPC过程返回到调用者那里。ContentProvider对外提供数据的方法，query、insert、delete、update方法也都是通过Transport进行调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContentProvider.Transport</span><br><span class="line">@Override</span><br><span class="line">public Cursor query(String callingPkg, Uri uri, String[] projection,</span><br><span class="line">                    String selection, String[] selectionArgs, String sortOrder,</span><br><span class="line">                    ICancellationSignal cancellationSignal) &#123;</span><br><span class="line">    validateIncomingUri(uri);</span><br><span class="line">    uri = getUriWithoutUserId(uri);</span><br><span class="line">    if (enforceReadPermission(callingPkg, uri, null) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        // The caller has no access to the data, so return an empty cursor with</span><br><span class="line">        // the columns in the requested order. The caller may ask for an invalid</span><br><span class="line">        // column and we would not catch that but this is not a problem in practice.</span><br><span class="line">        // We do not call ContentProvider#query with a modified where clause since</span><br><span class="line">        // the implementation is not guaranteed to be backed by a SQL database, hence</span><br><span class="line">        // it may not handle properly the tautology where clause we would have created.</span><br><span class="line">        if (projection != null) &#123;</span><br><span class="line">            return new MatrixCursor(projection, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Null projection means all columns but we have no idea which they are.</span><br><span class="line">        // However, the caller may be expecting to access them my index. Hence,</span><br><span class="line">        // we have to execute the query as if allowed to get a cursor with the</span><br><span class="line">        // columns. We then use the column names to return an empty cursor.</span><br><span class="line">        Cursor cursor = ContentProvider.this.query(uri, projection, selection,</span><br><span class="line">                selectionArgs, sortOrder, CancellationSignal.fromTransport(</span><br><span class="line">                        cancellationSignal));</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Return an empty cursor for all columns.</span><br><span class="line">        return new MatrixCursor(cursor.getColumnNames(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    final String original = setCallingPackage(callingPkg);</span><br><span class="line">    try &#123;</span><br><span class="line">        return ContentProvider.this.query(</span><br><span class="line">                uri, projection, selection, selectionArgs, sortOrder,</span><br><span class="line">                CancellationSignal.fromTransport(cancellationSignal));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        setCallingPackage(original);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>访问一个ContentProvider需要用到ContentResolver对象，它是一个抽象类，实际上用的是它的实现类ContextImpl的ApplicationContentResolver。</p></li><li><p>访问ContextProvider时一个IPC过程，由于ContentProvider不能跨进程访问。调用ContentResolver的query等方法首先需要从AMS端获取一个ContextProvider的代理对象，这个代理对象实现了IContentProvider接口，它用于代理远端的Binder对象ContextProvider.Trasnport。ContextProvider.Trasnport继承自ContentProviderNative，ContentProviderNative实现了IContentProvider接口。通过ContextProvider.Trasnport的本地代理对象，可以调用ContextProvider.Trasnport的query方法，Trasnport是ContextProvider的内部类，持有ContextProvider的引用，它再去调用ContextProvider的方法并通过IPC过程返回结果。</p></li><li><p>第一次访问ContentProvider的时候，如果它还没有创建，AMS会通过startProcessLock方法调用Process的start方法，通过Zygote去fork一个进程之后调用ActivityThread的main方法，在main方法中创建ActivityThread对象，并调用其attach方法，在此过程创建了Instrumentation对象、Application对象，并创建该进程中对应的ContentProvider并调用其onCreate方法，此后调用Application的onCreate方法，因此ContentProvider的onCreate方法早于Application的onCreate方法执行，这也是四大组件中唯一一个比较特别的。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件——BroadCastReceiver的工作过程</title>
      <link href="/2018/04/12/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94BroadCastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/04/12/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94BroadCastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>BroadCastReceiver的工作过程分为包含两方面的内容：</p><ol><li>注册</li><li>发送和接收</li></ol><p>使用BroadcastReceiver很简单，只需要继承BroadcastReceiver并重写它的onReceive方法即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        //TODO something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使BroadcastReceiver工作，就需要对它进程注册。注册BroadCastReceiver分为在AndroidManifest.xml静态注册和代码中动态注册。</p><p>静态注册示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.sososeen.09.demo.my.receiver&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><p>动态注册也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">intentFilter.addAction(&quot;com.sososeen.09.demo.my.receiver&quot;);</span><br><span class="line">registerReceiver(new MyReceiver(), intentFilter);</span><br></pre></td></tr></table></figure><p>不过动态注册别忘了反注册，否则会造成内存泄漏。</p><p>发送广播示例如下，通过给Intent设置action，对应的广播接收者的onReveive就会被回调了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(&quot;com.sososeen.09.demo.my.receiver&quot;);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>注册广播和发送广播中间过程是怎么进行的，我们今天就来分析一下。由于静态注册牵涉到在应用安装时有系统自动完成注册，确切的说是通过PackageManagerService完成注册，相对比较复杂。今天先来分析一下动态注册的BroadCastReceiver的工作过程。</p><p>在本文的分析中，ActivityManagerService简称AMS。</p><h1 id="动态注册BroadCastReceiver"><a href="#动态注册BroadCastReceiver" class="headerlink" title="动态注册BroadCastReceiver"></a>动态注册BroadCastReceiver</h1><p>注册广播接收者是通过ContextWrapper来进行的，但是类似启动Service，真正干事的还是ContextImpl，我们直接来看它的方法。2个参数的registerReceiver方法，会调用4个参数的registerReceiver方法，然后会调用registerReceiverInternal方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">    return registerReceiver(receiver, filter, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">                               String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    return registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在registerReceiverInternal方法中主要干了两件事：</p><ol><li><p>mPackageInfo指的是LoadedApk对象，通过调用LoadedApk的getReceiverDispatcher方法把BroadcastReceiver包装为ReceiverDispatcher.InnerReceiver对象，这是因为BroadcastReceiver是不具有跨进程通信能力的，想要最终调用到BroadcastReceiver的onReceive方法，必须有一个Binder对象用来进行IPC，在这里就是ReceiverDispatcher.InnerReceiver对象。InnerReceiver对象持有ReceiverDispatcher对象的引用。当AMS端调用InnerReceiver的接收广播的方法，InnerReceiver对象会找到对应的ReceiverDispatcher进而找到BroadcastReceiver对象并调用其onReceive方法。这个过程我们后面再分析。这种方式与bind方式启动Service的中包装ServiceConnection是类似的，有兴趣的可以看一下<a href="https://www.jianshu.com/p/bce3b49a3af6" target="_blank" rel="noopener">Android四大组件——Service的工作过程分析</a>。</p></li><li><p>ActivityManagerNative.getDefault()获取的是AMS在本地的代理，该代理通过IPC过程调用AMS的registerReceiver方法。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">                                        IntentFilter filter, String broadcastPermission,</span><br><span class="line">                                        Handler scheduler, Context context) &#123;</span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            // 1 创建ReceiverDispatcher.InnerReceiver对象</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler,</span><br><span class="line">                    mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 2 IPC过程调用AMS的registerReceiver方法</span><br><span class="line">        final Intent intent = ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看一下LoadedApk的getReceiverDispatcher方法，就是创建一个ReceiverDispatcher对象并将其保存起来，在ReceiverDispatcher的构造方法中创建InnerReceiver对象，ReceiverDispatcher对象中保存了BroadcastReceiver和InnerReceiver对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">                                             Context context, Handler handler,</span><br><span class="line">                                             Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;</span><br><span class="line">        if (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            if (map != null) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rd == null) &#123;</span><br><span class="line">            rd = new ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line">            if (registered) &#123;</span><br><span class="line">                if (map == null) &#123;</span><br><span class="line">                    map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        rd.mForgotten = false;</span><br><span class="line">        return rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下AMS的registerReceiver方法，该方法很长，我们选取一些关键的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">                               IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;registerReceiver&quot;);</span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = null;</span><br><span class="line">    ProcessRecord callerApp = null;</span><br><span class="line">      ...</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        if (rl == null) &#123;</span><br><span class="line">            rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            if (rl.app != null) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    return sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = true;</span><br><span class="line">            &#125;</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId);</span><br><span class="line">        rl.add(bf);</span><br><span class="line">       ...</span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法中 mRegisteredReceivers 是一个HashMap对象，用于追踪客户端BroadcastReceiver对应的ReceiverDispatcher.InnerReceiver对象。ReceiverList是一个ArrayList集合，用于存放BroadcastFilter，BroadcastFilter用于包装IntentFilter。我们需要知道一点，同一个BroadcastReceiver是可以对应多个IntentFilter的，只要匹配一个就能够接收消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>说明： BroadcastFilter中封装了ReceiverList对象，而ReceiverList对象中包含了客户端BroadcastReceiver对应的IIntentReceiver对象（实际上就是ReceiverDispatcher.InnerReceiver对象），将来在发送广播的阶段，通过Intent找到所有匹配到的动态注册的BroadcastFilter集合。</p></blockquote><p>到此，BroadcastReceiver的动态注册过程就完毕了。</p><h1 id="广播的发送和接收过程"><a href="#广播的发送和接收过程" class="headerlink" title="广播的发送和接收过程"></a>广播的发送和接收过程</h1><p>广播的发送分为普通广播、有序广播和粘性广播。有序广播是按照广播接收者的优先级，从高优先级到低优先级依次接收，而且在高优先级的广播接收者中是可以打断广播，造成低优先级的广播接收不到。而粘性广播表示想要当发送广播的时候，BroadcastReceiver还没有创建，当BroadcastReceiver创建后，它的onReveive方法会被立即调用。</p><p>在这里我们分析一下普通广播的发送和接收流程。</p><p>调用Context的方法发送广播，实际上还是会调用ContextImpl的方法，来一下ContextImpl的sendBroadcast方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个过程中看，通过一个IPC过程调用到AMS的broadcastIntent方法，在该方法又调用了AMS的broadcastIntentLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">                                 Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">                                 int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">                                 String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">                                 boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        int res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != null ? callerApp.info.packageName : null,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broadcastIntentLocked方法非常长，我们尽量选取一些关键的地方来分析，在方法的开始会有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intent = new Intent(intent);</span><br><span class="line"></span><br><span class="line">// By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br></pre></td></tr></table></figure><p>表示会重新创建一个Intent对象用于包裹传递过来的的Intent对象，并且为Intent添加了一个flag，Intent.FLAG_EXCLUDE_STOPPED_PACKAGES，表示默认情况下广播不会发送给已经停止运行的App，这也是为了方式一些App想要利用广播来启动进程。</p><p>从Android3.1开始，添加了两个标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 表示不包含已经停止的应用，如果广播设置这个标记，就不会发送给已经停止的应用</span><br><span class="line">public static final int FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;</span><br><span class="line"> </span><br><span class="line">// 表示包含已经停止的应用，如果广播设置这个标记，就会发送给已经停止的应用</span><br><span class="line">public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;</span><br></pre></td></tr></table></figure><p>从Android 3.1开始，默认情况下都是添加一个FLAG_EXCLUDE_STOPPED_PACKAGES标记，表示不会发送给停止的应用，如果确实需要的话，需要给广播显式的设置FLAG_INCLUDE_STOPPED_PACKAGES标记。</p><p>在broadcastIntentLocked内部，会根据IntentFilter查找出匹配的BroadcastReceiver，经过一系列条件的筛选和过滤，将满足条件的接收者放在BroadcastQueue中，接下来BroadcastQueue就会将广播发送出去。注意在这个过程中会先把找出来的动态注册的广播发出去，然后再把静态注册的广播发出去。因此，动态注册的广播优先级是高于静态注册的广播的。而且，如果BroadcastReceiver同时注册了静态广播和动态广播，其onReceive方法会被调用两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">        || resultTo != null) &#123;</span><br><span class="line">    BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line"></span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</span><br><span class="line">            + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">            &quot;Enqueueing broadcast &quot; + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">    if (!replaced) &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>BroadcastQueue发送广播的实现如下，通过Handler发送一个BROADCAST_INTENT_MSG类型的消息，Handler收到消息之后会调用BroadcastQueue的processNextBroadcast方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">            + mQueueName + &quot;]: current=&quot;</span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    if (mBroadcastsScheduled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BroadcastQueue的processNextBroadcast方法很长，我们选取发送普通广播的部分来看，可以看到无序广播存放在mParallelBroadcasts集合中，通过遍历这个集合来发送广播给BroadcastReceiver。具体的发送过程是deliverToRegisteredReceiverLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">       ...</span><br><span class="line">        // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">        while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(0);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            final int N = r.receivers.size();</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">            for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</span><br><span class="line">                                + target + &quot;: &quot; + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">            if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</span><br><span class="line">                    + mQueueName + &quot;] &quot; + r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>再来看一下BroadcastQueue的deliverToRegisteredReceiverLocked方法，该方法负责将一个特定的广播发送给特定的接收者，具体的发送过程是调用了performReceiveLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                        new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br></pre></td></tr></table></figure><p>来看一下performReceiveLocked方法，app.thread指的就是ApplicationThread在本地的代理对象，app.thread != null 条件满足，会通过IPC过程调用ApplicationThread的scheduleRegisteredReceiver方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.BroadcastQueue</span><br><span class="line"></span><br><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">                          Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">                          boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">            // If we have an app thread, do the call through that so it is</span><br><span class="line">            // correctly ordered with other one-way calls.</span><br><span class="line">            try &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">              ...</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Application has died. Receiver doesn&apos;t exist.</span><br><span class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ApplicationThread的scheduleRegisteredReceiver方法中调用了receiver的performReceive方法，而这个receiver我们知道，实际上就是ReceiverDispatcher.InnerReceiver对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">                                       int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">                                       boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下ReceiverDispatcher.InnerReceiver对象的performReceive方法，在该方法中首先获取InnerReceiver持有的ReceiverDispatcher对象，如果ReceiverDispatcher对象不为空的话就会调用它的performReceive方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher.InnerReceiver</span><br><span class="line">@Override</span><br><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                           Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">        rd = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    if (rd != null) &#123;</span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReceiverDispatcher的performReceive方法中，会封装一个Args对象，Args是ReceiverDispatcher的非静态内部类，因此持有ReceiverDispatcher的引用，可以访问ReceiverDispatcher的参数和方法，并且它实现了Runnable接口。mActivityThread是一个Handler，通过post方法，把调用切换到主线程中来，Args的run方法会被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher</span><br><span class="line">public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                           Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">    final Args args = new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    if (intent == null) &#123;</span><br><span class="line">        Log.wtf(TAG, &quot;Null intent received&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (intent == null || !mActivityThread.post(args)) &#123;</span><br><span class="line">        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    &quot;Finishing sync broadcast to &quot; + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Args的run方法如下，最后会调用BroadcastReceiver的onReceive方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ReceiverDispatcher.Args</span><br><span class="line">public void run() &#123;</span><br><span class="line">    final BroadcastReceiver receiver = mReceiver;</span><br><span class="line">...</span><br><span class="line">    ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">    intent.setExtrasClassLoader(cl);</span><br><span class="line">    intent.prepareToEnterProcess();</span><br><span class="line">    setExtrasClassLoader(cl);</span><br><span class="line">    receiver.setPendingResult(this);</span><br><span class="line">    receiver.onReceive(mContext, intent);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，广播的发送和接收过程也分析完毕了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>注册广播的时候是把BroadcastReceiver封装到ReceiverDispatcher中，并且把与此对应的ReceiverDispatcher.InnerReceiver作为一个Binder对象传递到AMS端，AMS端会通过一个Map集合来存放ReceiverDispatcher.InnerReceiver对象和对应的IntentFilter包装类。</p></li><li><p>发送广播的时候，通过一个IPC过程调用到AMS端，AMS端会找到匹配的广播接收者并添加到BroadcastQueue中，在BroadcastQueue中进程处理之后通过一个IPC过程调用到ApplicationThread的scheduleRegisteredReceiver方法，然后会调用ReceiverDispatcher.InnerReceiver的方法，再经过ReceiverDispatcher、以及它的内部类Args，最终调用到BroadcastReceiver的onReveive方法。</p></li><li><p>动态注册的广播优先级是高于静态注册的广播的。而且，如果BroadcastReceiver同时注册了静态广播和动态广播，其onReceive方法会被调用两次。</p></li><li><p>从过程中也可以看到，AMS端如果想要与客户端打交道的话都是通过ApplicationThread。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android四大组件——Service的工作过程分析</title>
      <link href="/2018/04/12/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Service%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2018/04/12/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Service%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>启动Service分为两种方式，分别是start方式和bind方式。</p><p>start方式对应的是Service由Context.startService(Intent service)方法来启动，从创建到销毁经历的生命周期方法是onCreate、onStartCommand、onDestory。已经在后台运行的Service，如果外界调用Context.stopService(Intent service)方法或者Service自己调用stopSelf()方法，Service会执行onDestory生命周期方法，然后结束运行。start状态的Service与Activity相互独立，即使Activity销毁，Service还是会存在。每次start方式启动Service，其onStartCommand方法均会被调用。</p><p>bind方式对应的是Service由Context.bindService(Intent service, ServiceConnection conn,  int flags)方法来启动，从创建到销毁经历的生命周期方法是onCreate、onBind、onUnbind、onDestory。bind状态的Service与Activity相互关联，可以认为Service与Activity的生命周期绑定。多次bind启动同一个Service，其onBind方法只会被调用一次。bind启动的Service，可以调用Context.unbindService(ServiceConnection conn)方法来解除绑定，Activity销毁的时候也会自动与bind状态的Service解除绑定。当Service上的所有绑定都解除后，Service会被销毁。</p><blockquote><p>注意：Service的周期方法中不管是多次start还是多次bind启动，onCreate方法只会调用一次。Service不同状态的启动方法和销毁方法是对应的，假如用start方式启动，调用unbind是没有效果的，只有调用对用的stop方法才可以销毁Service；反之同理。</p></blockquote><p>简单来说，start状态和bind状态的区别有4点：</p><p>a. 启动方式不同<br>b. 生命周期阶段不同<br>c. 销毁方式不同。<br>d. 交互不同，以start方式启动的Service，组件与Service是无法交互的。以bind方式启动的Service，组件可以与Service进行交互。</p><p>Service可以以start方式和bind方式混合启动，如果一个Service通过start方式和bind方式启动，想要停止这个Service的话，它的stopService和unbindService都要调用，调用顺序没有关系，只调用一个是无法停止Service的。还要注意一点，多次startService只要一次stopService就可以了，但是如果多次bindService就需要多次unBindService，或者与Service绑定的组件结束其生命周期。</p><p>下面按照start方式和bind方式来分别介绍Service的启动过程。</p><h1 id="start方式启动"><a href="#start方式启动" class="headerlink" title="start方式启动"></a>start方式启动</h1><p>不管是start方式还是bind方式，启动一个Service都是通过ContextWrapper的方法来的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ContextWrapper</span><br><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    return mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最终它还是通过mBase来启动，这是典型的桥接模式。Application、Activity、Service在对象创建完毕之后第一件事就是调用他们自身的attach方法，在attach方法中又会调用attachBaseContext方法，进而对mBase进行赋值。这个mBase实际上就是ContextImpl对象，ContextImpl的创建过程在<a href="https://www.jianshu.com/p/7bab8afb6de0" target="_blank" rel="noopener">Activity启动过程之生命周期方法回调分析</a>中也有介绍。</p><p>我们直接看一下ContextImpl的startService方法，这个方法后面调用了startServiceCommon方法。而startServiceCommon中通过ActivityManagerNative的getDefault对象去startService。相信看过<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>这篇文章的应该很明白，ActivityManagerNative.getDefault()获取的是ActivityManagerService在本地进程的一个代理对象，通过Binder机制，进行一次IPC过程调用到ActivityManagerService的startService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public ComponentName startService(Intent service) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (cn != null) &#123;</span><br><span class="line">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Not allowed to start service &quot; + service</span><br><span class="line">                                + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Unable to start service &quot; + service</span><br><span class="line">                                + &quot;: &quot; + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cn;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityManagerNative相关内容我们就不多做介绍了，直接看一下ActivityManagerService的startService方法。在该方法中又会调用mServices的startServiceLocked方法，这个mServices是ActiveServices类型，用来是辅助AMS对Service进行启动管理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">                                  String resolvedType, String callingPackage, int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">   ...</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        final int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActiveServices的startServiceLocked中会对所要启动的Service进行检查，包括其它一些安全方面的校验。如果所有的检查都通过，就会调用ActiveServices自身的startServiceInnerLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">                                 int callingPid, int callingUid, String callingPackage, final int userId)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">  ...</span><br><span class="line">    // 对所要启动的Service进行检查</span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                    callingPid, callingUid, userId, true, callerFg, false);</span><br><span class="line">    if (res == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res.record == null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!&quot;, res.permission != null</span><br><span class="line">                ? res.permission : &quot;private to package&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActiveServices的startServiceInnerLocked中，会继续调用bringUpServiceLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">                                      boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">  ...</span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    return r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActiveServices的startServiceInnerLocked中，如注释1处，首先判断当前的Service是否已经启动过，如果已经启动多的话会通过一个IPC过程调用ApplicationThread的scheduleServiceArgs，然后通过Hander的切换调用到ActivityThread的handleServiceArgs方法，进而调用Service的onStartCommand方法。这里我们先不细说了，继续分析Service的启动过程。</p><p>在这个方法中还是根据当前启动的Service是否需要一个独立的进程，如果不需要独立的进程并且当前的进程已经存在的话就会调用realStartServiceLocked。如果进程不存在话还会先创建一个进程，进程的创建是通过ActivityManagerService的startProcessLocked方法来进行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">                                    boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    //Slog.i(TAG, &quot;Bring up service:&quot;);</span><br><span class="line">    //r.dump(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line"> //  1 判断当前的Service是否已经启动过</span><br><span class="line">    if (r.app != null &amp;&amp; r.app.thread != null) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!whileRestarting &amp;&amp; r.restartDelay &gt; 0) &#123;</span><br><span class="line">        // If waiting for a restart, then do nothing.</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Bringing up &quot; + r + &quot; &quot; + r.intent);</span><br><span class="line"></span><br><span class="line">    // We are now bringing the service up, so no longer in the</span><br><span class="line">    // restarting state.</span><br><span class="line">    if (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure this service is no longer considered delayed, we are starting it now.</span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (bring up): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure that the user who owns this service is started.  If not,</span><br><span class="line">    // we don&apos;t want to allow it to run.</span><br><span class="line">    if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                + r.intent.getIntent() + &quot;: user &quot; + r.userId + &quot; is stopped&quot;;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Service is now being launched, its package can&apos;t be stopped.</span><br><span class="line">    try &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, false, r.userId);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Failed trying to unstop package &quot;</span><br><span class="line">                + r.packageName + &quot;: &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 2 判断是否需要独立的进程</span><br><span class="line">    final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;</span><br><span class="line">    final String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">        if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid</span><br><span class="line">                + &quot; app=&quot; + app);</span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">      // 3 进程存在，</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                return null;</span><br><span class="line">            &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If this service runs in an isolated process, then each time</span><br><span class="line">        // we call startProcessLocked() we will get a new isolated</span><br><span class="line">        // process, starting another process if we are currently waiting</span><br><span class="line">        // for a previous process to come up.  To deal with this, we store</span><br><span class="line">        // in the service any current isolated process it is running in or</span><br><span class="line">        // waiting to have come up.</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Not running -- get it started, and enqueue this service record</span><br><span class="line">    // to be executed when the app comes up.</span><br><span class="line">    // 4 进程不存在，需要创建进程</span><br><span class="line">    if (app == null &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;</span><br><span class="line">            String msg = &quot;Unable to launch app &quot;</span><br><span class="line">                    + r.appInfo.packageName + &quot;/&quot;</span><br><span class="line">                    + r.appInfo.uid + &quot; for service &quot;</span><br><span class="line">                    + r.intent.getIntent() + &quot;: process is bad&quot;;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (in bring up): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设进程已经存在，现在开始分析ActiveServices的realStartServiceLocked方法，看名字也能猜到，在这里是真的要启动一个Service了。在该方法中有一段代码<code>app.thread.scheduleCreateService</code>，app.thread 表示的就是IApplicationThread在本地的一个代理，这个方法通过一个IPC过程会调用到ApplicationThread的scheduleCreateService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">                                          ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">    if (app.thread == null) &#123;</span><br><span class="line">        throw new RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    final boolean newService = app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">    mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    boolean created = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">            String nameTerm;</span><br><span class="line">            int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">            nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        // 1 通过IPC过程创建Service</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Application dead when creating service &quot; + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!created) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            // Cleanup.</span><br><span class="line">            if (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Retry.</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    // If the service is in the started state, and there are no</span><br><span class="line">    // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">    // be called.</span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2 在该方法中会通过IPC过程调动Service的onStartCommand方法</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下，ApplicationThread的scheduleCreateService方法，其实ApplicationThread的中的方法都像套路一样，均会发送一个消息，然后进入ActivityThread的内部类H的handleMessage方法中。这个传递的参数对象是一个CreateServiceData，就是一个JavaBean对象，封装了IBinder、ServiceInfo、CompatibilityInfo，可以看到这里面传递的也是一个IBinder的token，这个token就是用于识别这个对应的Service。AMS那边实际上存的也是这个token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">                                        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    CreateServiceData s = new CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Handler中又会调用ActivityThread的handleCreateService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">    。。。</span><br><span class="line">        case CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityThread的handleCreateService方法中，做的事情清晰明了，其实与Activity的创建过程类似，可以查看<a href="https://www.jianshu.com/p/7bab8afb6de0" target="_blank" rel="noopener">Activity启动过程之生命周期方法回调分析</a>。</p><ol><li>通过getPackageInfoNoCheck方法获取LoadedApk对象</li><li>通过LoadedApk中的ClassLoader对象创建Service对象，对于一个已经安装的Apk来讲，这个ClassLoader一般指的就是PathClassLoader。</li><li>创建ContextImpl对象</li><li>调用LoadedApk的makeApplication创建Application对象，一个LoadedApk只会对应一个Application，如果已经存在的话直接返回该对象。</li><li>调用attach方法，绑定一些必须的参数，注意这个context就是ContextImpl对象，也就是我们之前讲的在ContextWrapper中获取的mBase对象就是它</li><li>调用Service的onCreate方法</li><li>mServices.put(data.token, service)，用于缓存一个App进程中已经创建的Service</li><li>通过IPC调用AMS的serviceDoneExecuting方法，这个传递的type是SERVICE_DONE_EXECUTING_ANON类型，实际上在AMS那边是没有做处理的。这里我们暂时不分析它。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread</span><br><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    // 1 获取LoadedApk对象</span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = null;</span><br><span class="line">    // 2 创建Service对象</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">        // 3 创建ContextImpl对象，</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        </span><br><span class="line">        //4 调用LoadedApk的makeApplication创建Application对象，一个LoadedApk只会对应一个Application</span><br><span class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        // 5 调用attach方法，绑定一些必须的参数，注意这个context就是ContextImpl对象，也就是我们之前讲的在ContextWrapper中获取的mBase对象就是它</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        // 6 调用Service的onCreate方法</span><br><span class="line">        service.onCreate();</span><br><span class="line">        // 7 存储起来</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        // 8 通过IPC调用AMS的serviceDoneExecuting方法</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法执行完毕之后，这次IPC过程就结束了。但是AMS那边的方法还没有执行完毕呢？<br>我们接着分析realStartServiceLocked方法。<br>在这个方法中实际上还会尝试通过requestServiceBindingsLocked进而来调用bindService的方法，不过因为我们是以start方式启动的，因此ServiceRecord中是没有bind意图的，因此也不会调用bind方法，这里我们就不分析它了，留到在bind方式启动的时候再来看它。<br>在方法中还会调用sendServiceArgsLocked方法，该方法中会通过IPC过程调动Service的onStartCommand方法，还记得我们之前说过吗，如果Service已经创建的话实际上ActiveServices就是会直接调用sendServiceArgsLocked这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">                                          ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">...</span><br><span class="line">        // 1 通过IPC过程创建Service</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    // 2 请求调用bindService</span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">  </span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    // If the service is in the started state, and there are no</span><br><span class="line">    // pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">    // be called.</span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3 在该方法中会通过IPC过程调动Service的onStartCommand方法</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">        r.delayedStop = false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下ActiveServices的sendServiceArgsLocked方法，在该方法中会调用r.app.thread.scheduleServiceArgs方法，这是一个IPC过程，调用ApplicationThread的 scheduleServiceArgs方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,</span><br><span class="line">                                         boolean oomAdjusted) throws TransactionTooLargeException &#123;</span><br><span class="line">    final int N = r.pendingStarts.size();</span><br><span class="line">    if (N == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (r.pendingStarts.size() &gt; 0) &#123;</span><br><span class="line">        Exception caughtException = null;</span><br><span class="line">        ServiceRecord.StartItem si = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            si = r.pendingStarts.remove(0);</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Sending arguments to: &quot;</span><br><span class="line">                    + r + &quot; &quot; + r.intent + &quot; args=&quot; + si.intent);</span><br><span class="line">            if (si.intent == null &amp;&amp; N &gt; 1) &#123;</span><br><span class="line">                // If somehow we got a dummy null intent in the middle,</span><br><span class="line">                // then skip it.  DO NOT skip a null intent when it is</span><br><span class="line">                // the only one in the list -- this is to support the</span><br><span class="line">                // onStartCommand(null) case.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.deliveredStarts.add(si);</span><br><span class="line">            si.deliveryCount++;</span><br><span class="line">            if (si.neededGrants != null) &#123;</span><br><span class="line">                mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                        si.getUriPermissionsLocked());</span><br><span class="line">            &#125;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</span><br><span class="line">            if (!oomAdjusted) &#123;</span><br><span class="line">                oomAdjusted = true;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line">            int flags = 0;</span><br><span class="line">            if (si.deliveryCount &gt; 1) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            if (si.doneExecutingCount &gt; 0) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">            &#125;</span><br><span class="line">           // 1 通过IPC调用ApplicationThread的 scheduleServiceArgs方法</span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line">        &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,</span><br><span class="line">                                      int flags ,Intent args) &#123;</span><br><span class="line">    ServiceArgsData s = new ServiceArgsData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.taskRemoved = taskRemoved;</span><br><span class="line">    s.startId = startId;</span><br><span class="line">    s.flags = flags;</span><br><span class="line">    s.args = args;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># andorid.app.ActivityThread$H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">...</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case SERVICE_ARGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">   ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下ActivityThread的handleServiceArgs方法，该方法比较简单</p><ol><li>就是首先通过token从mServices中获取对应的Service</li><li>给Intent设置extrasClassLoader，主要是为了反序列化Intent中携带的一个Parcelable类型的对象</li><li>调用Service的onStartCommand方法，获取其返回值</li><li>通过IPC告知AMS调用结果，注意这个时候把onStartCommand的返回值传递过去了，结果类型type为SERVICE_DONE_EXECUTING_START。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    // 1 获取Service</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 2. 给Intent设置extrasClassLoader，主要是为了反序列化Intent中携带的一个Parcelable类型的对象</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            // 3 调用Service的onStartCommand方法</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            </span><br><span class="line">            // 4 通过IPC告知AMS调用结果，注意这个时候把onStartCommand的返回值传递过去了</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to start service &quot; + s</span><br><span class="line">                                + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下ActivityManagerService的serviceDoneExecuting方法，其实也就是做了一下中转，中间做了一下校验，要保证客户端传递来的token是正确的类型。之后会调用ActiveServices的serviceDoneExecutingLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, &quot;serviceDoneExecuting: Invalid service token=&quot; + token);</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 serviceDoneExecutingLocked方法中会根据传递过来的type，来进行对应的处理，此时传递的是SERVICE_DONE_EXECUTING_START，然后就会根据对应的res来进行处理。正常情况下这个res就是Service的onStartCommand的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123;</span><br><span class="line">    boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            // This is a call from a service start...  take care of</span><br><span class="line">            // book-keeping.</span><br><span class="line">            r.callStart = true;</span><br><span class="line">            switch (res) &#123;</span><br><span class="line">                case Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                case Service.START_STICKY: &#123;</span><br><span class="line">                    // We are done with the associated start arguments.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    // Don&apos;t stop if killed.</span><br><span class="line">                    r.stopIfKilled = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_NOT_STICKY: &#123;</span><br><span class="line">                    // We are done with the associated start arguments.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    if (r.getLastStartId() == startId) &#123;</span><br><span class="line">                        // There is no more work, and this service</span><br><span class="line">                        // doesn&apos;t want to hang around if killed.</span><br><span class="line">                        r.stopIfKilled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line">                    // We&apos;ll keep this item until they explicitly</span><br><span class="line">                    // call stop for it, but keep track of the fact</span><br><span class="line">                    // that it was delivered.</span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, false);</span><br><span class="line">                    if (si != null) &#123;</span><br><span class="line">                        si.deliveryCount = 0;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line">                        // Don&apos;t stop if killed.</span><br><span class="line">                        r.stopIfKilled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line">                    // Special processing for onTaskRemoved().  Don&apos;t</span><br><span class="line">                    // impact normal onStartCommand() processing.</span><br><span class="line">                    r.findDeliveredStart(startId, true);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default:</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                            &quot;Unknown service start result: &quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">            if (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            // This is the final call from destroying the service...  we should</span><br><span class="line">            // actually be getting rid of the service at this point.  Do some</span><br><span class="line">            // validation of its state, and ensure it will be fully removed.</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                // Not sure what else to do with this...  if it is not actually in the</span><br><span class="line">                // destroying list, we don&apos;t need to make sure to remove it from it.</span><br><span class="line">                // If the app is null, then it was probably removed because the process died,</span><br><span class="line">                // otherwise wtf</span><br><span class="line">                if (r.app != null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Service done with onDestroy, but not inDestroying: &quot;</span><br><span class="line">                            + r + &quot;, app=&quot; + r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (r.executeNesting != 1) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Service done with onDestroy, but executeNesting=&quot;</span><br><span class="line">                        + r.executeNesting + &quot;: &quot; + r);</span><br><span class="line">                // Fake it to keep from ANR due to orphaned entry.</span><br><span class="line">                r.executeNesting = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Done executing unknown service from pid &quot;</span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onStartCommand方法的返回值是int型，返回值有4种。</p><ol><li><p>START_STICKY_COMPATIBILITY = 0，这个是START_STICKY的兼容版本，被杀死后重启并不保证一定调用onStartCommand方法。这个一般是在android系统小于5 的时候使用。</p></li><li><p>START_STICKY = 1，当Service已经启动后，如果onStartCommand方法返回值是这个，表示的是如果因内存不足Service被系统杀掉，系统会在后续内存空闲时尝试着重新创建这个Service，但是不会再传递上次启动Service的Intent，onStartCommand中的Intent参数会为null。</p></li><li><p>START_NOT_STICKY = 2，系统把Service杀死后，不会尝试重新创建这个Service。</p></li><li><p>START_REDELIVER_INTENT = 3，系统把Service杀死后，会尝试重新创建这个Service，并且会把之前启动Service的最后一个Intent重新传递回来。</p></li></ol><p>到此，我们就分析完Service的start方式启动的过程了。我们小结一下</p><p><strong>小结</strong></p><ol><li><p>startService启动Service调用的是ContextImpl的startService方法，在ContextImpl中通过一个IPC过程调用到AMS端的startService方法，AMS再去委托ActiveServices去对Service的启动进行管理。ActiveServices首先回去校验Service的合法性，如果合法的话判断Service所在进程是否已经启动，如果没有启动的话会先去创建进程再来启动Service。如果Service所在进程已经启动，就会通过一个IPC过程调用ApplicationThread的scheduleCreateService方法，进而调用ActivityThread的handleCreateService方法，完成Service的创建以及绑定上下文环境并调用Service的onCreate方法。</p></li><li><p>创建Service的IPC过程结果之后，会返回ActiveServices的方法调用处接着执行方法，然后会再通过一个IPC过程来调用Service的onStartCommand方法，并且该方法结束之后会把onStartCommand的返回值告知AMS，AMS又会通知ActiveServices去进行处理。当Service因空间不足被系统杀死后，会根据不同的返回值来对Service进行相应处理。</p></li></ol><h1 id="bind方式启动Service"><a href="#bind方式启动Service" class="headerlink" title="bind方式启动Service"></a>bind方式启动Service</h1><p>前面也说了，startService、bindService均是通过ContextImpl进行。直接看一下ContextImpl的bindService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">@Override</span><br><span class="line">public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">                           int flags) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bindService方法有3个参数，第一个参数Intent，不同说就是表示启动的Service对应的意图，第2个参数ServiceConnection是一个接口用来监控bind方式启动的Service的连接状态。第3个参数是一个flag，一般传递的是Context.BIND_AUTO_CREATE。</p><p>需要说明的是，ServiceConnection的onServiceConnected会在Service的onBind方法返回IBinder对象之后调用，而其onServiceDisconnected是在Service意外挂掉，比如Service被系统杀死的时候才会被回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android.content.ServiceConnection</span><br><span class="line">public interface ServiceConnection &#123;</span><br><span class="line">    public void onServiceConnected(ComponentName name, IBinder service);</span><br><span class="line">    public void onServiceDisconnected(ComponentName name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl的bindService方法会调用其bindServiceCommon方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler</span><br><span class="line">        handler, UserHandle user) &#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    if (conn == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;connection is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 1 调用LoadedApk的getServiceDispatcher方法</span><br><span class="line">    if (mPackageInfo != null) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(this);</span><br><span class="line">        // 2 通过IPC过程调用AMS的bindService方法</span><br><span class="line">        int res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line">        return res != 0;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package android.app;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line"></span><br><span class="line">oneway interface IServiceConnection &#123;</span><br><span class="line">    void connected(in ComponentName name, IBinder service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bindServiceCommon方法中主要完成两件事情。<br>首先会调用LoadedApk的getServiceDispatcher方法，该方法会创建一个IServiceConnection对象，IServiceConnection是用AIDL写的，在这里实际上就是ServiceDispatcher.InnerConnection对象。这是因为ServiceConnection必须借助Binder来让远端server回调自己的方法，但是ServiceConnection不具有跨进程通信的能力，而ServiceDispatcher.InnerConnection是一个Binder对象，刚好可以充当这个跨进程通信的角色。ServiceDispatcher在ServiceDispatcher.InnerConnection和ServiceConnection之间起着桥梁的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk</span><br><span class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</span><br><span class="line">                                                     Context context, Handler handler, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sd == null) &#123;</span><br><span class="line">            sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            if (map == null) &#123;</span><br><span class="line">                map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        return sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法中mServices是一个ArrayMap，存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系。键表示一个Context，说明每个Context对象中是可以存放一组映射关系的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span><br><span class="line">        = new ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt;();</span><br></pre></td></tr></table></figure><p>系统首先会搜索ServiceConnection对应 ServiceDispatcher是否存在，如果不存在的话会创建一个ServiceDispatcher对象，在ServiceDispatcher的构造方法中会创建一个InnerConnection对象并持有ServiceDispatcher的引用，而ServiceDispatcher中又持有ServiceConnection的引用，因此当服务端回调的时候可以通过InnerConnection间接的找到ServiceConnection，回调它的方法。</p><p>接着分析ContextImpl的bindServiceCommon方法，LoadedApk的getServiceDispatcher返回一个IServiceConnection对象（InnerConnection类型），接着通过一个IPC过程调用了AMS的bindService方法来完成Service的绑定过程，注意此时把IServiceConnection对象传递到了服务端，当然了，服务端拿到的实际上是IServiceConnection的代理对象。</p><p>看一下AMS的bindService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int bindService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">                       String resolvedType, IServiceConnection connection, int flags, String callingPackage,</span><br><span class="line">                       int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;bindService&quot;);</span><br><span class="line"></span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callingPackage == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bindService中主要做了一些校验，接下来，AMS会调用ActiveServices的bindServiceLocked方法。bindServiceLocked方法会调用bringUpServiceLocked，bringUpServiceLocked会调用realStartServiceLocked方法，realStartServiceLocked方法和之前讲的start方式启动Service的逻辑一致，均是通过ApplicationThread来完成Service的创建并执行其onCreate方法，这里就不重复讲解了。和start方式不同的是，在realStartServiceLocked方法中，当执行完<code>app.thread.scheduleCreateService</code>过程，完成Service的创建和onCreate方法回调之后，还会接着调用ActiveServices的requestServiceBindingsLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)</span><br><span class="line">        throws TransactionTooLargeException &#123;</span><br><span class="line">    for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">                                                  boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">    if (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">        // If service is not currently running, can&apos;t yet bind.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            if (!rebind) &#123;</span><br><span class="line">                i.requested = true;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = true;</span><br><span class="line">            i.doRebind = false;</span><br><span class="line">        &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r, e);</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Crashed while binding &quot; + r);</span><br><span class="line">            // Keep the executeNesting count accurate.</span><br><span class="line">            final boolean inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service有一个特性，同一个ServiceConnection多次绑定一个Service，Service的onBind方法只会被调用一次。一个ServiceConnection对应AMS端的一个IntentBindRecord。在上面的代码中也可以看出，对于同一个IntentBindRecord只会调用onBind一次。</p><p>在ActiveServices的bindServiceLocked方法中会调用ServiceRecord的retrieveAppBindingLocked方法，在这里会用一个Map集合bindings存放bind信息。Intent.FilterComparison是键，它实际上包裹了一个请求Service的Intent，比较两个Intent.FilterComparison是否相等是根据Intent的filterHashCode方法，这个与Intent的mAction、mType、mType、mPackage、mComponent、mCategories有关。我们知道，5.0以上的系统，Service只能够显式启动。具体的是在ContextImpl的validateServiceIntent方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings</span><br><span class="line">            = new ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;();</span><br></pre></td></tr></table></figure><p>在requestServiceBindingLocked中， <code>r.app.thread</code>指的就是ApplicationThread的本地代理对象，通过一个IPC过程调用到ApplicationThread的scheduleBindService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">                                      boolean rebind, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    BindServiceData s = new BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;scheduleBindService token=&quot; + token + &quot; intent=&quot; + intent + &quot; uid=&quot;</span><br><span class="line">                + Binder.getCallingUid() + &quot; pid=&quot; + Binder.getCallingPid());</span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种套路我们已经分析太多了，通过Handler H来发送一个H.BIND_SERVICE消息。然后会交给ActivityThread的handleBindService方法。在该方法中首先根据token获取对应的Service，然后给Intent设置extrasClassLoader， 如果不是重新绑定，就调用Service的onBind方法，并且返回IBinder对象，并传递给AMS。如果是重新绑定，调用Service的onRebind方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">    // 1 根据token获取Service</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 2. 给Intent设置extrasClassLoader</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 3 如果不是重新绑定，就调用Service的onBind方法，并且返回IBinder对象，并传递给AMS</span><br><span class="line">                if (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 4 如果是重新绑定，直接调用Service的onRebind方法</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to bind to service &quot; + s</span><br><span class="line">                                + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Service的onBind方法调用之后，会通过IPC过程调用AMS的publishService方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">    // Refuse possible leaked file descriptors</span><br><span class="line">    if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，AMS的publishService方法将具体的工作交给了ActiveServices来完成，调用了它的publishServiceLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActiveServices</span><br><span class="line">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;PUBLISHING &quot; + r</span><br><span class="line">                + &quot; &quot; + intent + &quot;: &quot; + service);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = new Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            if (b != null &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = true;</span><br><span class="line">                b.received = true;</span><br><span class="line">                for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    for (int i=0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        if (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                         ...</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;Publishing to: &quot; + c);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                           ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publishServiceLocked方法中看起来很多，核心点就一个地方<code>c.conn.connected(r.name, service)</code>。c的类型是ConnectionRecord，c.conn返回的是IServiceConnection对象，实际上就是一个本地代理。真实的对象是ServiceDispatcher.InnerConnection。<code>c.conn.connected</code>实际上就是一个IPC过程调用到ServiceDispatcher.InnerConnection的connected方法。参数中的service就是调用Service的onBind方法返回的Ibinder对象。</p><p>来看一下ServiceDispatcher.InnerConnection的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher.InnerConnection</span><br><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">    final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void connected(ComponentName name, IBinder service) throws RemoteException &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">        if (sd != null) &#123;</span><br><span class="line">            sd.connected(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnerConnection的connected方法中会调用ServiceDispatcher的connected方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher</span><br><span class="line">public void connected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    if (mActivityThread != null) &#123;</span><br><span class="line">        mActivityThread.post(new RunConnection(name, service, 0));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mActivityThread是一个Handler，实际上就是ActivityThread的H这个Handler，是在ContextImpl的bindService方法中一路传递过来的，作为了ServiceDispatcher的成员变量。所以mActivityThread不为null，就会调用Handler的post方法来切换到主线程中。后面RunConnection的run方法会执行。注意此时传递的第三个参数为0。</p><p>看一下RunConnection。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher.RunConnection</span><br><span class="line">private final class RunConnection implements Runnable &#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, int command) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (mCommand == 0) &#123;</span><br><span class="line">            doConnected(mName, mService);</span><br><span class="line">        &#125; else if (mCommand == 1) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ComponentName mName;</span><br><span class="line">    final IBinder mService;</span><br><span class="line">    final int mCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunConnection是ServiceDispatcher的非静态内部类，在run方法中又调用了ServiceDispatcher的doConnected方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># android.app.LoadedApk.ServiceDispatcher</span><br><span class="line">public void doConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mForgotten) &#123;</span><br><span class="line">            // We unbound before receiving the connection; ignore</span><br><span class="line">            // any connection received.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        if (old != null &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            // Huh, already have this one.  Oh well!</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (service != null) &#123;</span><br><span class="line">            // A new service is being connected... set it all up.</span><br><span class="line">            info = new ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = new DeathMonitor(name, service);</span><br><span class="line">            try &#123;</span><br><span class="line">                service.linkToDeath(info.deathMonitor, 0);</span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                // This service was dead before we got it...  just</span><br><span class="line">                // don&apos;t do anything with it.</span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // The named service is being disconnected... clean up.</span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (old != null) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If there was an old service, it is not disconnected.</span><br><span class="line">    if (old != null) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    // If there is a new service, it is now connected.</span><br><span class="line">    if (service != null) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ServiceDispatcher的doConnected方法最后，调用了mConnection的onServiceConnected方法，也就是调用了在bindService的时候传递的ServiceConnection的onServiceConnected方法。</p><p>到此，Service的bind启动过程也分析完毕了。</p><p>至于Service的unBind过程，会调用到ActiveServices的unbindServiceLocked方法，在该方法中又调用removeConnectionLocked方法。会去移除ServiceConnetion，当Service上所有的bind 的ServiceConnetion都移除的时候，会通过IPC调用ApplicationThread的scheduleUnbindService方法，然后调用Service的unBind方法。接下来，unbindServiceLocked中还会调用其bringDownServiceLocke方法，在该方法中调用ApplicationThread的scheduleStopService方法，进而调用Service的onDestory方法。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>关于Service的onBind方法只会被调用一次，每一个App对应一个AppBindeRecord，我们要知道一个问题就是一个App是可以bind多个Service的，但是一个App只会对应一个AppBindRecord。</p><p>考虑一个问题，App可以bind多个Service，同时一个Service也可以被多个App绑定，这是多对多的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class AppBindRecord &#123;</span><br><span class="line">    final ServiceRecord service;    // The running service.</span><br><span class="line">    final IntentBindRecord intent;  // The intent we are bound to.</span><br><span class="line">    final ProcessRecord client;     // Who has started/bound the service.</span><br><span class="line"></span><br><span class="line">    final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;&gt;();</span><br><span class="line">                                    // All ConnectionRecord for this client.</span><br><span class="line">..</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final class IntentBindRecord &#123;</span><br><span class="line">    /** The running service. */</span><br><span class="line">    final ServiceRecord service;</span><br><span class="line">    /** The intent that is bound.*/</span><br><span class="line">    final Intent.FilterComparison intent; // </span><br><span class="line">    /** All apps that have bound to this Intent. */</span><br><span class="line">    final ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps</span><br><span class="line">            = new ArrayMap&lt;ProcessRecord, AppBindRecord&gt;();</span><br><span class="line">    /** Binder published from service. */</span><br><span class="line">    IBinder binder;</span><br><span class="line">    /** Set when we have initiated a request for this binder. */</span><br><span class="line">    boolean requested;</span><br><span class="line">    /** Set when we have received the requested binder. */</span><br><span class="line">    boolean received;</span><br><span class="line">    /** Set when we still need to tell the service all clients are unbound. */</span><br><span class="line">    boolean hasBound;</span><br><span class="line">    /** Set when the service&apos;s onUnbind() has asked to be told about new clients. */</span><br><span class="line">    boolean doRebind;</span><br><span class="line">    </span><br><span class="line">    String stringName;      // caching of toString</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动过程之生命周期方法回调分析</title>
      <link href="/2018/04/10/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90/"/>
      <url>/2018/04/10/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>和<a href="https://www.jianshu.com/p/61807be57916" target="_blank" rel="noopener">Hook一个Activity的启动过程</a>中均分析了Activity的启动过程，不过前者的分析侧重点在AMS这块，而后者侧重寻找启动过程的Hook点。</p><p>而本文要分析一下Activity的具体创建过程和需要关注的一些地方，这也为了理解插件化机制打下一个好的基础。AMS通过Binder调用ApplicationThread的scheduleLaunchActivity方法，我们就以这个方法开始分析。</p><p>scheduleLaunchActivity方法中的第2个参数，还记得我们上文<a href="https://www.jianshu.com/p/61807be57916" target="_blank" rel="noopener">Hook一个Activity的启动过程</a>讲的吗，这个token就是用于标示Activity启动相关的一个记录，AMS就是通过这个token来控制Activity的生命周期方法的调用，ActivityThread这端就是通过token来获取对应的ActivityClientRecord，进而对对应的Activity进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$ApplicationThread</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationThread的scheduleLaunchActivity方法是在Binder线程池中调用，所以通过发送一个H.LAUNCH_ACTIVITY的消息通过H 和这个Hander来切换到主线程，在其handleMessage方法中会调用ActivityThread的handleLaunchActivity方法。注意在此之前调用了ActivityThread的getPackageInfoNoCheck方法，该方法用于获取一个LoadedApk对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadedApk对象的注释是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local state maintained about a currently loaded .apk.</span><br></pre></td></tr></table></figure><p>意思就是LoadedApk表示的是当前被加载的Apk文件对应的一个数据对象。<br>getPackageInfoNoCheck方法这里我们先不介绍，回头再介绍插件化相关知识的时候再来说明。</p><p>接下来看一下ActivityThread的handleLaunchActivity方法，在该方法中主要干了两件事，一件是调用performLaunchActivity方法创建Activity，attach上下文，并执行Activity的onCreate、onStart、onRestoreInstanceState等方法。在handleResumeActivity方法中回调Activity的onResume方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看一下performLaunchActivity方法，先从ActivityClientRecord获取ActivityInfo，这个ActivityInfo表示的就是在AndroidManifest.xml中一个activity标签所代表的Activity信息。r.packageInfo 表示的是LoadedApk对象，如果该对象为null就会调用一个public的getPackageInfo方法来获取LoadedApk，还记得我们之前说的getPackageInfoNoCheck方法吗，其实他们最终都是调用一个private的getPackageInfo方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">// ActivityInfo表示的就是在AndroidManifest.xml中一个activity标签所代表的Activity信息。</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 在该方法中，下面这段代码表示的是如果是隐式调用，需要通过PackageManager来进行解析，获取正确的跳转对象。</span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 通过LoadedApk中的ClassLoader来创建Activity</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">       // 通过LoadedApk来穿件Application对象</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                        + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                        + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                        + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                        + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            // 实际上创建的是ComtextImpl对象</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (r.overrideConfig != null) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            Window window = null;</span><br><span class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = null;</span><br><span class="line">                r.mPendingRemoveWindowManager = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 调用attach方法，关联一些必要的对象，比如创建Window对象，绑定上下文等</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            // 调用Instrumentation的callActivityOnCreate方法，会回调Activity的onCreate方法</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">          // 如果还没有调用Finish方法，就接着调用Activity的performStart方法，其实还是通过Instrumentation来调用Activity的onStart方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         // 如果还没有调用Finish方法，就接着调用Instrumentation的callActivityOnRestoreInstanceState方法，会回调Activity的onRestoreInstanceState方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           // 如果还没有调用Finish方法，就接着调用Instrumentation的callActivityOnPostCreate方法，会回调Activity的onPostCreate方法</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                            &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                    &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line">        </span><br><span class="line">        // 到这里把token和对应的ActivityClientRecord放在ArrayMap mActivities中</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to start activity &quot; + component</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们在注释中大致讲了一下Activity的创建流程，下面我们来关注一下细节，Instrumentation通过调用newActivity方法来创建Activity，我们来看一下这个方法干了什么。代码很简单，就是通过ClassLoader去加载Class并创建对象。注意这个ClassLoader是从LoadedApk中获取的。这个LoadedApk表示的是当前正在运行的App。</p><p>那么我们在这里想一想，如果要加载一个未安装的Apk，该怎么去加载呢，可不可以想办法构造一个未安装的Apk对应的LoadedApk对象，并让它的ClassLoader变为DexClassLoader，而DexClassLoader是可以加载一个未安装的Apk文件中的dex的，这样不就可以实现一个加载未安装Apk中的代码了吗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public Activity newActivity(ClassLoader cl, String className,</span><br><span class="line">                            Intent intent)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们接着分析，创建完Activity对象之后，会调用LoadedApk的makeApplication方法来创建一个Application对象，看一下这个方法。首先Application如果已经创建过的话会赋值给mApplication变量，那么就直接返回mApplication。然后还需要判断需要创建哪个Application对象，如果我们App中没有指定Application，就直接创建android.app.Application对象。如果自定义了Application，就创建指定的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">                                   Instrumentation instrumentation) &#123;</span><br><span class="line">    // 如果已经创建过，直接返回</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    // 根据条件判断创建哪个Application对象</span><br><span class="line">    Application app = null;</span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 也是通过LoadedApk中的ClassLoader来创建Application</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            // 如果包名不是android，还需要初始化上下文ClassLoader</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建ContextImpl对象</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用Instrumentation的newApplication方法来创建Application对象</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 调用Instrumentation的callApplicationOnCreate方法，会回调Application的onCreate方法</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instrumentation的newApplication方法，最后会调用到它的一个静态的newApplication方法，我们来看一下。就是根据传递的className，来创建Application对象，创建完对象之后，还会调用Application的attach方法，在attach方法中会调用attachBaseContext方法，而该方法也是我们应用开发层面能够最早接收到Application的一个回调方法，所以像MultiDex等都要在这个方法中调用比较合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void attach(Context context) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在performLaunchActivity中，当创建完Activity对象和拿到Application对象之后，调用createBaseContextForActivity方法返回一个Context对象，该对象实际上是一个ContextImpl对象。后面会调用Activity的attach方法，这个方法很重要，调用了attachBaseContext方法，设置Activity的baseContext为ContextImpl对象。创建了Window对象并设置Callback为当前的Activity对象，因此Activity可以接收到Window的回调，并且Window对象设置了WindowManager。拿到ActivityThread和Instrumentation的引用，需要说明的是，在整个App进程中，只有一个ActivityThread和Instrumentation对象，所有的Activity中拿到的都是同一个引用。在这个方法中也可以看到，Activity拿到了表示它自身的一个IBinder对象 token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">                  Instrumentation instr, IBinder token, int ident,</span><br><span class="line">                  Application application, Intent intent, ActivityInfo info,</span><br><span class="line">                  CharSequence title, Activity parent, String id,</span><br><span class="line">                  NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                  Window window) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.uiOptions != 0) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    if (voiceInteractor != null) &#123;</span><br><span class="line">        if (lastNonConfigurationInstances != null) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity的attach方法调用之后，紧接着调用了Instrumentation的callActivityOnCreate方法，我们只看两个参数的就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在callActivityOnCreate方法中又调用了Activity的performCreate方法，在performCreate方法中又调用了Activity自身的onCreate方法，在onCreate方法中会把mCalled设置为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">    if (mLastNonConfigurationInstances != null) &#123;</span><br><span class="line">        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mActivityInfo.parentActivityName != null) &#123;</span><br><span class="line">        if (mActionBar == null) &#123;</span><br><span class="line">            mEnableDefaultActionBarUp = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (savedInstanceState != null) &#123;</span><br><span class="line">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null</span><br><span class="line">                ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    getApplication().dispatchActivityCreated(this, savedInstanceState);</span><br><span class="line">    if (mVoiceInteractor != null) &#123;</span><br><span class="line">        mVoiceInteractor.attachActivity(this);</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity生命周期方法中，任何一个方法都可能调用finish来结束。所以，在执行onStart、onRestoreInstanceState、onPostCreate等之前，都会判断是否结束了。根据的就是Activity的一个变量mFinished，当Activity中调用finish方法，该变量会为true。后面的生命周期方法就不会再执行了。</p><p>在performLaunchActivity方法中其它生命周期方法的回调也很简单，这里就不多讲了，有兴趣的可以自行查看。我们只需要记住一些关键过程就好了。</p><p>下面来分析一下ActivityThread的handleResumeActivity方法，该方法先根据传递的参数token来获取对应的ActivityClientRecord，之后就会调用performResumeActivity方法，注意这个返回值是ActivityClientRecord对象，相当于要更新这个记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">    // TODO Push resumeArgs into the activity for consideration</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一下performResumeActivity方法，在该方法中如果ActivityClientRecord 的pendingIntents不为null，就会调用 <code>deliverNewIntents(r, r.pendingIntents)</code> ，最终会回调Activity的onNewIntent方法。后面<code>r.activity.performResume()</code>会调用到Activity的performResume方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token,</span><br><span class="line">                                                        boolean clearHide, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r</span><br><span class="line">            + &quot; finished=&quot; + r.activity.mFinished);</span><br><span class="line">    if (r != null &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">        if (clearHide) &#123;</span><br><span class="line">            r.hideForNow = false;</span><br><span class="line">            r.activity.mStartedActivity = false;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            r.activity.onStateNotSaved();</span><br><span class="line">            r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">            if (r.pendingIntents != null) &#123;</span><br><span class="line">                // 回调Activity的onNewIntent方法</span><br><span class="line">                deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">                r.pendingIntents = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.pendingResults != null) &#123;</span><br><span class="line">                deliverResults(r, r.pendingResults);</span><br><span class="line">                r.pendingResults = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 调用Activity的performResume方法</span><br><span class="line">            r.activity.performResume();</span><br><span class="line"></span><br><span class="line">            // If there is a pending local relaunch that was requested when the activity was</span><br><span class="line">            // paused, it will put the activity into paused state when it finally happens.</span><br><span class="line">            // Since the activity resumed before being relaunched, we don&apos;t want that to happen,</span><br><span class="line">            // so we need to clear the request to relaunch paused.</span><br><span class="line">            for (int i = mRelaunchingActivities.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                final ActivityClientRecord relaunching = mRelaunchingActivities.get(i);</span><br><span class="line">                if (relaunching.token == r.token</span><br><span class="line">                        &amp;&amp; relaunching.onlyLocalRequest &amp;&amp; relaunching.startsNotResumed) &#123;</span><br><span class="line">                    relaunching.startsNotResumed = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(),</span><br><span class="line">                    r.activity.getComponentName().getClassName(), reason);</span><br><span class="line"></span><br><span class="line">            r.paused = false;</span><br><span class="line">            r.stopped = false;</span><br><span class="line">            r.state = null;</span><br><span class="line">            r.persistentState = null;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to resume activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity的performResume方法中会执行performRestart方法，但是也是通过Instrumentation来执行具体的onRestart、onStart方法，不过该方法执行的前提是已经执行了onStop方法。这里面没有什么难点，无非就是通过Instrumentation执行Activity的生命周期方法，后面接着会执行onResume、onPostResume方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">    performRestart();</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">    mCalled = false;</span><br><span class="line">    // mResumed is set by the instrumentation</span><br><span class="line">    mInstrumentation.callActivityOnResume(this);</span><br><span class="line">    if (!mCalled) &#123;</span><br><span class="line">        throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onResume()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // invisible activities must be finished before onResume() completes</span><br><span class="line">    if (!mVisibleFromClient &amp;&amp; !mFinished) &#123;</span><br><span class="line">        Log.w(TAG, &quot;An activity without a UI must call finish() before onResume() completes&quot;);</span><br><span class="line">        if (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt; android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                            &quot; did not call finish() prior to onResume() completing&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now really resume, and install the current status bar and menu.</span><br><span class="line">    mCalled = false;</span><br><span class="line"></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    onPostResume();</span><br><span class="line">    if (!mCalled) &#123;</span><br><span class="line">        throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostResume()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续来分析ActivityThread的handleResumeActivity方法，执行完performResumeActivity方法之后，还有一部分主要用于处理Window的，从Window中取出DecorView，并且调用WindowManager的addView方法，这个具体的调用时通过WindowManager的实现类WindowManagerImpl，实际上这个它也是个不干事的，会继续委托给WindowManagerGlobal来处理，最终会创建ViewRootImpl，并触发整个View视图的绘制流程，这里过程在这里就不详细分析了。不过我们从这个也可以看出，当Activity的onResume方法执行之后，才会开始触发整个View的绘制流程，也就是说实际上在onResume方法中我们是无法获取View的宽高的。在Activity的onWindowFocusChanged方法中如果参数为true，表明Actvity中的视图全部绘制完毕，可以正确的拿到宽高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"> ...</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                        a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                        + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line"></span><br><span class="line">        final int forwardBit = isForward ?</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line"></span><br><span class="line">        // If the window hasn&apos;t yet been added to the window manager,</span><br><span class="line">        // and this guy didn&apos;t finish itself or start another activity,</span><br><span class="line">        // then go ahead and add the window.</span><br><span class="line">        boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">        if (!willBeVisible) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(</span><br><span class="line">                        a.getActivityToken());</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            if (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                r.mPreserveWindow = false;</span><br><span class="line">                // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                // the decor view we have to notify the view root that the</span><br><span class="line">                // callbacks may have changed.</span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                if (impl != null) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If the window has already been added, but during resume</span><br><span class="line">            // we started another activity, then don&apos;t yet make the</span><br><span class="line">            // window visible.</span><br><span class="line">        &#125; else if (!willBeVisible) &#123;</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">            r.hideForNow = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Get rid of anything left hanging around.</span><br><span class="line">        cleanUpPendingRemoveWindows(r, false /* force */);</span><br><span class="line"></span><br><span class="line">        // The window is now visible if it has been added, we are not</span><br><span class="line">        // simply finishing, and we are not starting another activity.</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            if (r.newConfig != null) &#123;</span><br><span class="line">                performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig);</span><br><span class="line">                r.newConfig = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;</span><br><span class="line">                    + isForward);</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            if ((l.softInputMode</span><br><span class="line">                    &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                    != forwardBit) &#123;</span><br><span class="line">                l.softInputMode = (l.softInputMode</span><br><span class="line">                        &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                        | forwardBit;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    ViewManager wm = a.getWindowManager();</span><br><span class="line">                    View decor = r.window.getDecorView();</span><br><span class="line">                    wm.updateViewLayout(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.mVisibleFromServer = true;</span><br><span class="line">            mNumVisibleActivities++;</span><br><span class="line">            if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!r.onlyLocalRequest) &#123;</span><br><span class="line">            r.nextIdle = mNewActivities;</span><br><span class="line">            mNewActivities = r;</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">            Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">        &#125;</span><br><span class="line">        r.onlyLocalRequest = false;</span><br><span class="line"></span><br><span class="line">        // Tell the activity manager we have resumed.</span><br><span class="line">        if (reallyResume) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If an exception was thrown when trying to resume, then</span><br><span class="line">        // just end this activity.</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity的生命周期方法回调就分析到这里了，在这里我们可以做一下小结：</p><ul><li>Application和Activity都是通过LoadedApk中的ClassLoader以及className创建。</li><li>LoadedApk对象是根据ActivityThread的getPackageInfo方法创建</li><li>Application和Activity都要attach一个ContextImpl对象。</li><li>在Activity的attach方法中会创建Window对象，也就是说一个Activity对应一个Window对象。</li><li>onResume方法之后才开始View视图的绘制</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的垃圾回收机制</title>
      <link href="/2018/04/08/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/04/08/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机会在执行Java程序的时候把它所管理的内存区域分为若干个不同的数据区域。</p><ul><li>程序计数器</li><li>Java虚拟机栈</li><li>本地方法栈</li><li>Java堆区</li><li>方法区，方法区中包含运行时常量池</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2083810-235b3bccd4c4bbd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存结构.png"></p><p>程序计数器、虚拟机栈、本地方法栈随线程而生随线程而灭。栈中的栈帧，随方法的进入和退出有条不紊的进行入栈出栈操作。每一个栈帧分配多少内存基本上是在类结构确定的时候就知道了。这3个地方不用考虑内存回收的问题，因为方法或者线程退出的时候，内存自然就被回收了。而Java堆和方法区则不一样，内存的分配和回收都是动态的，垃圾回收器所关注的是这部分内存。</p><p>Jvm的垃圾回收机制，本质上就是做3件事：</p><ol><li>确定哪些对象可以被回收</li><li>什么时候回收</li><li>怎么回收这些对象</li></ol><h1 id="判断对象时候可以被回收"><a href="#判断对象时候可以被回收" class="headerlink" title="判断对象时候可以被回收"></a>判断对象时候可以被回收</h1><ol><li><p>引用计数法，给每个对象增加一个引用计数器，例如一个对象A，每增加一个引用，它的引用计数就加1，每减少一个引用，引用计数就减1。如果该对象的引用计数为0，那么垃圾回收器就认为该对象可以被回收了。这种算法实现起来简单，判定效率也很高，但是有一个缺点，例如，A和B如果互相引用，那它们的引用计数器就永远不为0，也就意味着垃圾回收器永远不会回收它们了，这明显的不合理。</p></li><li><p>可达性分析算法<br>该算法是在主流的商用领域采用，算法的思想是通过一系列的称为“GC Root”的对象作为起始点，从这个起始点向下搜索，搜索所走过的路径称为引用链，当一个对象到达GC Root没有任何引用链可用，就认为该对象是不可达的，将会被回收。</p></li></ol><p>例如，在下图中，Object5、Object6、Object7到GC Root之间没有引用链，尽管它们之间存在着引用关系，但是它们还是会被回收。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-92323ba50676a96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p><p>GC Root实际上也是对象，那么哪些对象可以作为GC Root呢？</p><ul><li>虚拟机栈中的引用对象</li><li>方法区中类的静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p><strong>标记-清除算法 Mark-Sweep</strong> ，算法分为标记和清除阶段，首先标记需要被回收的对象，在标记完成后统一回收所有被标记的对象。不足之处有两个：一是效率问题，两个阶段效率都不高，二是空间问题，标记清除之后会产生大量的空间碎片，后面如果需要分配较大对象时有可能因为连续内存空间不足而导致需要重新出发一次垃圾回收。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-5c112c3d15e44222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p><p><strong>复制算法 Coping</strong>，把内存区域按容量分为两个相等的部分，每次只使用一块，当空间使用完毕之后就把还存活的对象赋值到另一块内存区域上，并把使用过的内存空间清空。不用考虑碎片问题，使用简单，但是浪费空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-015486f96314ec1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p><p><strong>标记整理算法 Mark-Compact</strong>，标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有的存活对象都向一端移动，然后直接清理掉端边界以外的对象，也就是需要被回收的对象。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-e89f0915d56e8903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自深入理解Java虚拟机.png"></p><p>分代垃圾回收算法，Generational Collection，商用的JVM、DVM均使用该算法。根据对象存活周期的不同将内存划分几块，一般把Java堆分为新生代和老年代，不同的代采用不同的垃圾回收算法，在新生代中每次垃圾回收都会有大量的对象死去，只有少量存活，就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中对象存活时间较长，没有额外空间进行担保，就必须使用标记-清除或者标记-整理算法来进行回收。</p><p>新生代中将内存分为一块较大的Eden和两块较小的Survivor区域，每次对象分配只使用Eden和其中一块Survivor区域，当进行GC的时候会有大量的对象死去，少部分存活的对象复制到空闲的Survivor区域。空闲的这个区域相当于是个担保，避免了纯粹的复制算法那样需要一半的空闲区域，浪费空间。<br>那么为什么需要两块Survivor区域呢，一块就不行吗？如果只有一块的话，相当于在下次复制存活对象的时候，Survivor区域上已经有了对象，这一点是有问题的，要么复制算法复杂，要么造成空间碎片。（这点是我自己理解的，有误的话还请指正）</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾回收算法只是内存回收的方法论，提供理论指导，真正的具体实现是垃圾收集器。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚 拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/sinat_36246371/article/details/52998505" target="_blank" rel="noopener">垃圾回收算法之分代回收算法</a></li><li>深入理解Java虚拟机——JVM高级特性与最佳实践，周志明</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hook一个Activity的启动过程</title>
      <link href="/2018/04/04/Hook%E4%B8%80%E4%B8%AAActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/04/04/Hook%E4%B8%80%E4%B8%AAActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在前一篇文章<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>中，通过源码分析的方式介绍了Activity的大致启动过程。今天就来实战一下，一个是加深对Activity启动过程的理解，另外一个就是让我们知道阅读源码有助于拓宽视野，提升开发能力。</p><p>首先先抛出需求：</p><ol><li><p>我们想启动一个Activity A页面，但是想要进入这个A页面必须是已经登录过的，如果没有登录的话就启动登录页面B，并且在B页面登录成功之后需要跳转到页面A</p></li><li><p>提升一下难度，Activity页面A、B均没有在清单文件中注册，但是要完成正常的跳转（这是为插件化的研究做准备）</p></li></ol><blockquote><p>在阅读本文之前，可以先clone一份  <strong><a href="https://github.com/sososeen09/apk-plugin-technology" target="_blank" rel="noopener">apk-plugin-technology</a></strong>，参考此项目的<code>binder-hook</code>模块。运行一下Demo，让你有个更感性的认识</p></blockquote><h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook，就是钩子，也就是说可以干预某些代码的正常执行流程。关于Hook的详细介绍，可以自行搜索相关文章。</p><p>完成Hook过程，需要注意3点，也可以说是3个步骤：</p><ol><li><p>寻找Hook点，Hook点一般要选择类的静态成员变量，因为静态成员变量一般不容易发生变化，只需要Hook一次就好了。如果想要Hook的成员变量不是静态的，那么可以找这个变量所持有的引用中是否有静态的成员变量。而且最好是public的，public的一般不容易发生变化。如果是非public的，就要考虑适配问题了。</p></li><li><p>选择合适的代理方式，一般来说我们不可能Hook一个对象的所有方法，所以就要通过代理的方式来Hook，如果是想要Hook的方法，就要走我们自己的逻辑，如果是不需要Hook的方法，还是要调用原对象的方法。</p></li><li><p>用代理对象替换原始对象</p></li></ol><p>这个过程可能还有点不是很清晰，没关系，继续往下看就明白了。</p><h1 id="Activity启动过程寻找Hook点"><a href="#Activity启动过程寻找Hook点" class="headerlink" title="Activity启动过程寻找Hook点"></a>Activity启动过程寻找Hook点</h1><p>我们知道，启动一个Activity，可以通过Activity本身的startActivity方法，也可以调用Context的startActivity方法，虽然Activity也是继承自Context，但是Activity重写了相关的启动方法，这是因为Activity本身有Activity任务栈，而其它的Context，比如Service中并没有任务栈，所以启动的时候需要加上一个flag <code>Intent.FLAG_ACTIVITY_NEW_TASK</code>，Context是一个抽象类，其启动Activity的方法，实际上调用的是ContextImpl的startActivity方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line"></span><br><span class="line">    // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is</span><br><span class="line">    // generally not allowed, except if the caller specifies the task id the activity should</span><br><span class="line">    // be launched in.</span><br><span class="line">    if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0</span><br><span class="line">            &amp;&amp; options != null &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) &#123;</span><br><span class="line">        throw new AndroidRuntimeException(</span><br><span class="line">                &quot;Calling startActivity() from outside of an Activity &quot;</span><br><span class="line">                + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span><br><span class="line">                + &quot; Is this really what you want?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), null,</span><br><span class="line">            (Activity) null, intent, -1, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果不加<code>FLAG_ACTIVITY_NEW_TASK</code>标记的话会抛出异常。<br>另外，从这个方法结合我们之前<a href="https://www.jianshu.com/p/13b07beacb1f" target="_blank" rel="noopener">Activity启动过程分析</a>中所分析的，不管是通过Activity调用还是通过Context调用，最终调用的均是Instrumentation的execStartActivity方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">   ...</span><br><span class="line">    try &#123;</span><br><span class="line">      ... </span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execStartActivity中会调用ActivityManagerNative.getDefault()方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">    return gDefault.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">        &#125;</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in != null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityManagerNative的gDefault 是一个静态变量，它是Singleton的一个匿名类，Singleton类其实就是用于获取单例对象的，gDefault的get方法获取的是IActivityManager的一个实现类。知道Binder的应该知道，这个获取的实际上是ActivityManagerProxy对象，如果不明白的建议先去看看 <a href="https://www.jianshu.com/p/a50d3f2733d6" target="_blank" rel="noopener">Binder学习概要</a>这篇文章。</p><p>ActivityManagerProxy对应的server端就是ActivityManagerService，也就是真正负责管理启动Activity的地方。我们启动一个Activity就是调用的ActivityManagerService的startActivity方法。</p><p>那么我们想一想，是否可以在gDefault这个方法做点文章呢。我们推理一下这个逻辑：</p><ol><li>hook 的是Activity的启动过程</li><li>ActivityManagerService负责管理启动，但是它在Server端，我们拿不到，但是通过gDefault我们可以拿到它在本地的代理对象ActivityManagerProxy对象。</li><li>我们需要为这个ActivityManagerProxy对象创建一个代理对象，当它调用startActivity方法的时候，需要做一些处理，比如按照需求1，判断被跳转的页面是否需要登录，如果需要登录的话就更改这个Intent，跳转到登录页面。当调用其它的方法的时候，直接使用原始的ActivityManagerProxy对象去处理。</li></ol><p>讲到这，其实我们就可以解决需求1了。但是我想把需求2一起解决了，这样的话上面的逻辑就有点不够完善，毕竟我们所要启动的Activity A和登录页面B都是没有在AndroidManifest.xml中声明的，启动一个未声明的Activity肯定会报一个ActivityNotFoundException。</p><p>再来回想一下Activity的启动过程：</p><p>调用startActivity方法启动一个目标Activity的时候，实际上会通过Instrumentation进行启动，再通过ActivityManagerService的本地代理对象调用ActivityManagerService的方法来启动一个Activity，这是一个IPC过程，在ActivityManagerService中会校验被启动的Activity的合法性，如果合法，会通过IPC过程调用ApplicationThread的方法，进而调用ActivityThread的handleLaunchActivity方法创建Activity，并执行Activity的生命周期方法。</p><p>看到没，Activity的启动过程是分两步的</p><ul><li>ActivityManagerService去校验被启动Activity合法性，并做好启动Activity的必要准备</li><li>在ActivityThread中真正的创建Activity，并完成Activity的启动阶段的生命周期回调。</li></ul><p>既然没法办通过AMS去启动一个未注册的Activity，那么我们换一个思路来：</p><ol><li>我们找一个在AndroidManifest.xml中声明一个代理页面ProxyActivity，当发起请求A页面的时候，我们hook ActivityManagerProxy的startActivity方法，把A页面的Intent替换为请求启动ProxyActivity页面的Intent，这样的话至少可以通过ActivityManagerService校验这一关。</li><li>当调用回我们ActivityThread的内部中的时候，做一下处理，把代理页面ProxyActivity对应的Intent替换成我们想要启动的Activity A对应的Intent，当然了，在这一过程还需要判断是否需要登录，如果需要登录的话，就需要替换成B页面。示例代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private void hookActivityManagerApi25() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 反射获取ActivityManagerNative的静态成员变量gDefault, 注意，在8.0的时候这个已经更改了</span><br><span class="line">        Class&lt;?&gt; activityManagerNativeClass = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</span><br><span class="line">        Field gDefaultField = activityManagerNativeClass.getDeclaredField(&quot;gDefault&quot;);</span><br><span class="line">        gDefaultField.setAccessible(true);</span><br><span class="line">        Object gDefaultObj = gDefaultField.get(null);</span><br><span class="line">        </span><br><span class="line">        // 我们在这里拿到的instanceObj对象一定不为空，如果为空的话就没办法使用</span><br><span class="line">        Class&lt;?&gt; singletonClass = Class.forName(&quot;android.util.Singleton&quot;);</span><br><span class="line">        Field mInstanceField = singletonClass.getDeclaredField(&quot;mInstance&quot;);</span><br><span class="line">        mInstanceField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        Object instanceObj = mInstanceField.get(gDefaultObj);</span><br><span class="line"></span><br><span class="line">        // 需要动态代理IActivityManager，把Singleton的成员变量mInstance的值设置为我们的这个动态代理对象</span><br><span class="line">        // 但是有一点，我们不可能完全重写一个IActivityManager的实现类</span><br><span class="line">        // 所以还是需要用到原始的IActivityManager对象，只是在调用某些方法的时候做一些手脚</span><br><span class="line">        Class&lt;?&gt; iActivityManagerClass = Class.forName(&quot;android.app.IActivityManager&quot;);</span><br><span class="line">        InterceptInvocationHandler interceptInvocationHandler = new InterceptInvocationHandler(instanceObj);</span><br><span class="line">        Object iActivityManagerObj = Proxy.newProxyInstance(context.getClassLoader(), new Class[]&#123;iActivityManagerClass&#125;, interceptInvocationHandler);</span><br><span class="line">        mInstanceField.set(gDefaultObj, iActivityManagerObj);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterceptInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    Object originalObject;</span><br><span class="line">    public InterceptInvocationHandler(Object originalObject) &#123;</span><br><span class="line">        this.originalObject = originalObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        LogUtils.d(&quot;method:&quot; + method.getName() + &quot; called with args:&quot; + Arrays.toString(args));</span><br><span class="line">        //如果是startActivity方法，需要做一些手脚</span><br><span class="line">        if (METHOD_START_ACTIVITY.equals(method.getName())) &#123;</span><br><span class="line">            Intent newIntent = null;</span><br><span class="line">            int index = 0;</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                Object arg = args[i];</span><br><span class="line">                if (arg instanceof Intent) &#123;</span><br><span class="line">                    Intent wantedIntent = (Intent) arg;</span><br><span class="line">                    // 加入目标Activity没有在清单文件中注册，我们就欺骗ActivityManagerService，启动一个代理页面</span><br><span class="line">                    // 真正启动页面，会开始回调ActivityThread的handleLaunchActivity方法</span><br><span class="line">                    // 调用这个方法前可以做点文章，启动我们想要启动的页面</span><br><span class="line">                    newIntent = new Intent();</span><br><span class="line">                    ComponentName componentName = new ComponentName(context, ProxyActivity.class);</span><br><span class="line">                    newIntent.setComponent(componentName);</span><br><span class="line">                    //把原始的跳转信息当作参数携带给代理类</span><br><span class="line">                    newIntent.putExtra(EXTRA_REAL_WANTED_INTENT, wantedIntent);</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args[index] = newIntent;</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(originalObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在ActivityThread中怎么找Hook点呢？<br>首先要明确一点，我们找找个Hook点是要为了替换之前代理ProxyActivity的Intent的，有了找个思路，我们就可以有目的的去寻找了。</p><p>AMS启动一个Activity，会调用ApplicationThread的scheduleLaunchActivity方法，这个方法应该是在Activity启动过程中我们的App最先被AMS调用的了，在这个方法中第一个参数就是Intent，这个Intent就是我们发起请求启动ProxyActivity的Intent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">// 注意这个参数</span><br><span class="line">    r.intent = intent;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationThread继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口。我们考虑一下，能否像Hook ActivityManagerProxy那样，采用一个动态代理的方式，创建IApplicationThread的代理类，当调用IApplicationThread的scheduleLaunchActivity方法的时候，我们更改这个方法的Intent参数，变为我们想要的那个Intent，然后就可以按照我们的需求来跳转了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends ApplicationThreadNative</span><br><span class="line"></span><br><span class="line">public abstract class ApplicationThreadNative extends Binder</span><br><span class="line">        implements IApplicationThread</span><br></pre></td></tr></table></figure><p>想法是很好的，但是很遗憾，我们做不到，至于为什么，请接着往下看。</p><p>我们想要Hook ApplicationThread的scheduleLaunchActivity，那么我们先看一下这个ApplicationThread对象是什么时候创建的。ApplicationThread是ActivityThread的非静态内部类，在ActivityThread中，它的创建时机是在ActivityThread对象初始化的时候，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ApplicationThread mAppThread = new ApplicationThread();</span><br></pre></td></tr></table></figure><p>由于它没有采用多态的方式来创建ApplicationThread，我们创建的动态代理对象实际上是没有办法赋值给mAppThread这个变量的，也就是说实际上这个点我们是没有办法hook的。</p><p>那么我们接着这个方法来看，在scheduleLaunchActivity方法中，通过ActivityThread的一个H类型的成员mH来发送一个类型为 H.LAUNCH_ACTIVITY （int 型，值为100）的消息，这个H是ActivityThread的非静态内部类，实际上是继承自Handler的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class H extends Handler</span><br></pre></td></tr></table></figure><p>至于为什么需要用Handler来切换，在<a href="https://www.jianshu.com/p/a50d3f2733d6" target="_blank" rel="noopener">Binder学习概要</a><br>已经介绍过，因为scheduleLaunchActivity是在Binder线程池中被调用的，需要用Hander来切换到主线程。H.LAUNCH_ACTIVITY类型的消息发送之后，H的handleMessage方法会被调用，在这里就会根据msg.what的来处理，对应LAUNCH_ACTIVITY类型的，会调用ActivityThread的handleLaunchActivity来创建Activity并完成Activity启动过程的生命周期回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">// 调用ActivityThread的方法来启动Activity</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下就要走到ActivityThread的handleLaunchActivity方法中了，难道我们要去Hook ActivityThread的handleLaunchActivity方法？</p><p>首先，获取这个ActivityThread对象是没有难度的，ActivityThread对象可以在它的类成员变量sCurrentActivityThread获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static volatile ActivityThread sCurrentActivityThread;</span><br></pre></td></tr></table></figure><p>应用的启动入口是ActivityThread的main方法，在这个方法中会创建ActivityThread对象，接着又会调用它的attach方法，在这个方法中，把ActivityThread对象赋值给其类的静态成员变量sCurrentActivityThread。静态成员变量就很好说了，通过反射就可以获取这个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> ...</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然获取了这个ActivityThread对象，但是我们怎么准备一个代理对象来代理ActivityThread对象呢？</p><p>由于ActivityThread没有继承或实现任何类或接口，好像为它准备代理对象有点难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityThread</span><br></pre></td></tr></table></figure><p>难道没有办法了吗？<br>当然不是，否则我还写这篇文章干嘛？</p><p>想一想Handler那块，从发送消息到处理消息，实际上中间是有一个消息分发过程的，也就是Handler的dispatchMessage方法会被调用，在这个方法中实际上Handler本身的handleMessage方法是最后才可能会被调用到的。<code>msg.callback</code> 这块我们没办法处理，因为消息创建是我们控制不了，而在else中，<code>mCallback != null</code> 这块，我们似乎可以给Hander设置一个mCallback，由这个Callback先一步处理消息，替换Intent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下mCallBack的类型，它是Handler内部的一个接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">    public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们赶紧去找找怎么设置Callback，不过很遗憾的是设置Callback只有一种方式就是作为Handler构造方法参数传递，但我们的mH对象已经创建了。既然正常的路径没办法了，那只要采用反射的方式来设置成员变量了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void hookActivityThreadHandler() &#123;</span><br><span class="line">    //需要hook ActivityThread</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取ActivityThread的成员变量 sCurrentActivityThread</span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">        Field sCurrentActivityThread = activityThreadClass.getDeclaredField(&quot;sCurrentActivityThread&quot;);</span><br><span class="line">        sCurrentActivityThread.setAccessible(true);</span><br><span class="line">        Object activityThreadObj = sCurrentActivityThread.get(null);</span><br><span class="line"></span><br><span class="line">        //获取ActivityThread的成员变量 mH</span><br><span class="line">        Field mHField = activityThreadClass.getDeclaredField(&quot;mH&quot;);</span><br><span class="line">        mHField.setAccessible(true);</span><br><span class="line">        Handler mHObj = (Handler) mHField.get(activityThreadObj);</span><br><span class="line"></span><br><span class="line">        Field mCallbackField = Handler.class.getDeclaredField(&quot;mCallback&quot;);</span><br><span class="line">        mCallbackField.setAccessible(true);</span><br><span class="line">        mCallbackField.set(mHObj, new ActivityCallback(mHObj));</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class ActivityCallback implements Handler.Callback &#123;</span><br><span class="line">    private Handler mH;</span><br><span class="line">    public ActivityCallback(Handler mH) &#123;</span><br><span class="line">        this.mH = mH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean handleMessage(Message msg) &#123;</span><br><span class="line">        if (msg.what == LAUNCH_ACTIVITY) &#123;</span><br><span class="line">            handleLaunchActivity(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleLaunchActivity(Message msg) &#123;</span><br><span class="line">        //替换我们真正想要的intent</span><br><span class="line">        try &#123;</span><br><span class="line">            Object activityClientRecord = msg.obj;</span><br><span class="line">            Field intentField = activityClientRecord.getClass().getDeclaredField(&quot;intent&quot;);</span><br><span class="line">            intentField.setAccessible(true);</span><br><span class="line">            //这个是代理ProxyActivity</span><br><span class="line">            Intent interceptedIntent = (Intent) intentField.get(activityClientRecord);</span><br><span class="line"></span><br><span class="line">            //真正想要跳转的 SecondActivity</span><br><span class="line">            Intent realWanted = interceptedIntent.getParcelableExtra(EXTRA_REAL_WANTED_INTENT);</span><br><span class="line">            if (realWanted != null) &#123;</span><br><span class="line">                //如果不需要登录</span><br><span class="line">                Class&lt;?&gt; real = Class.forName(realWanted.getComponent().getClassName());</span><br><span class="line">                NeedLogin annotation = real.getAnnotation(NeedLogin.class);</span><br><span class="line"></span><br><span class="line">                if (annotation != null &amp;&amp; !SPHelper.getBoolean(&quot;login&quot;, false)) &#123;</span><br><span class="line">                    //如果需要登录并且没有登录，跳转登录页面</span><br><span class="line">                    Intent loginIntent = new Intent(context, LoginActivity.class);</span><br><span class="line">                    loginIntent.putExtra(EXTRA_REAL_WANTED_INTENT, realWanted);</span><br><span class="line">                    interceptedIntent.setComponent(loginIntent.getComponent());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptedIntent.setComponent(realWanted.getComponent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，就可以通过Hook的方式来启动一个未在AndroidManifest.xml声明的Activity了，并且可以根据是否需要登录来跳转到不同的页面。</p><h1 id="继承AppCompatActivity会遇到的问题"><a href="#继承AppCompatActivity会遇到的问题" class="headerlink" title="继承AppCompatActivity会遇到的问题"></a>继承AppCompatActivity会遇到的问题</h1><p>如果你所有的Activity均继承的是Activity，上面的代码逻辑已经是没有问题了。但是，如果你的Activity类继承的是AppCompatActivity，是会报一个异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.content.pm.PackageManager$NameNotFoundException</span><br></pre></td></tr></table></figure></p><p>报这个异常的原因是在AppCompatActivity的onCreate方法中经过层层调用，会调用到NavUtils的getParentActivityName方法。在这个方法中会调用到PackageManager的getActivityInfo方法，返回的ActivityInfo对象是Activity在AndroidManifest.xml中注册信息对应的一个JavaBean对象，调用这个方法实际上会再检查一次Activity的合法性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># android.support.v4.app.NavUtils</span><br><span class="line">public static String getParentActivityName(Context context, ComponentName componentName)</span><br><span class="line">        throws NameNotFoundException &#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    ActivityInfo info = pm.getActivityInfo(componentName, PackageManager.GET_META_DATA);</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 16) &#123;</span><br><span class="line">        String result = info.parentActivityName;</span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.metaData == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String parentActivity = info.metaData.getString(PARENT_ACTIVITY);</span><br><span class="line">    if (parentActivity == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (parentActivity.charAt(0) == &apos;.&apos;) &#123;</span><br><span class="line">        parentActivity = context.getPackageName() + parentActivity;</span><br><span class="line">    &#125;</span><br><span class="line">    return parentActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面方法中，context.getPackageManager()实际上会调用ContextImpl的getPackageManager方法，而这个实际上返回的是ApplicationPackageManager对象，这个类是把IPackageManager进行了包装，实际上的功能还是由PackageManagerService调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ContextImpl</span><br><span class="line">public PackageManager getPackageManager() &#123;</span><br><span class="line">    if (mPackageManager != null) &#123;</span><br><span class="line">        return mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    if (pm != null) &#123;</span><br><span class="line">        // Doesn&apos;t matter if we make more than one instance.</span><br><span class="line">        return (mPackageManager = new ApplicationPackageManager(this, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而ApplicationPackageManager 调用getActivityInfo实际上调用的IPackageManagerd的getActivityInfo方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ApplicationPackageManager</span><br><span class="line">@Override</span><br><span class="line">public ActivityInfo getActivityInfo(ComponentName className, int flags)</span><br><span class="line">        throws NameNotFoundException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityInfo ai = mPM.getActivityInfo(className, flags, mContext.getUserId());</span><br><span class="line">        if (ai != null) &#123;</span><br><span class="line">            return ai;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new NameNotFoundException(className.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程就是经过一个IPC过程调用PackageManagerService的getActivityInfo方法。</p><p>为了不报NameNotFoundException异常，我们需要Hook这个IPackageManager，当调用PackageManager的getActivityInfo的时候，不让它进行IPC调用，而是直接返回一个不为null的ActivityInfo对象，这样就可以解决问题了。</p><h1 id="Hook-PMS"><a href="#Hook-PMS" class="headerlink" title="Hook PMS"></a>Hook PMS</h1><p>我们要去Hook PMS，还是遵循之前讲的3个步骤，那么就先来找这个Hook点，上面我们在贴出的代码中也看到了，ContextImpl的getPackageManager方法中首先会获取调用ActivityThread的静态方法getPackageManager来获取一个IPackageManager对象。我们来看一下这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">public static IPackageManager getPackageManager() &#123;</span><br><span class="line">    if (sPackageManager != null) &#123;</span><br><span class="line">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</span><br><span class="line">        return sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(&quot;package&quot;);</span><br><span class="line">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</span><br><span class="line">    return sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个静态变量sPackageManager，如果不为空的话直接就返回了，这个静态变量的类型是接口类型，那么这个Hook点就很好，静态的很好获取对象，而接口类型更容易使用代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static volatile IPackageManager sPackageManager;</span><br></pre></td></tr></table></figure><p>前面讲了那么多，怎么去Hook应该也知道 了，我们目前只Hook IPackageManager的getActivityInfo方法，废话也不多说了，直接贴代码，更直观。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void HookPackageManager() &#123;</span><br><span class="line">    //需要hook ActivityThread</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取ActivityThread的成员变量 sCurrentActivityThread</span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">        Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);</span><br><span class="line">        sPackageManagerField.setAccessible(true);</span><br><span class="line">        Object iPackageManagerObj = sPackageManagerField.get(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; iPackageManagerClass = Class.forName(&quot;android.content.pm.IPackageManager&quot;);</span><br><span class="line">        InterceptPackageManagerHandler interceptInvocationHandler = new InterceptPackageManagerHandler(iPackageManagerObj);</span><br><span class="line">        Object iPackageManagerObjProxy = Proxy.newProxyInstance(context.getClassLoader(), new Class[]&#123;iPackageManagerClass&#125;, interceptInvocationHandler);</span><br><span class="line"></span><br><span class="line">        sPackageManagerField.set(null, iPackageManagerObjProxy);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class InterceptPackageManagerHandler implements InvocationHandler &#123;</span><br><span class="line">    Object originalObject;</span><br><span class="line"></span><br><span class="line">    public InterceptPackageManagerHandler(Object originalObject) &#123;</span><br><span class="line">        this.originalObject = originalObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        LogUtils.d(&quot;method:&quot; + method.getName() + &quot; called with args:&quot; + Arrays.toString(args));</span><br><span class="line">        if (METHOD_GET_ACTIVITY_INFO.equals(method.getName())) &#123;</span><br><span class="line">            return new ActivityInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(originalObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AMS与ActivityThread通过token进行通信"><a href="#AMS与ActivityThread通过token进行通信" class="headerlink" title="AMS与ActivityThread通过token进行通信"></a>AMS与ActivityThread通过token进行通信</h1><p>虽然我们启动了Activity A或者B，但是AMS实际上还是以为我们启动的是ProxyActivity。不信的话，可以使用命令行查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure><p>结果如下，可以看到，在AMS端记录的Activity实际上是ProxyActivity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mFocusedActivity: ActivityRecord&#123;4ff4194 u0 com.sososeen09.binder.hook/.ProxyActivity t5057&#125;</span><br></pre></td></tr></table></figure></p><p>那么通过这种Hook方式启动的Activity ，还具有完整的生命周期吗？</p><p>答案是肯定的。</p><p>我们知道Activity是不具有跨进程通讯的能力的，那么AMS是如何管理Activity，控制Activity的声明周期的呢？答案就是一个通过一个Ibinder类型的token变量来控制。ASM通过这个token来与ApplicationThread进行通讯，进行控制Activity的声明周期。在AMS那边，它以为token表示的是ProxyActivity，但是在客户端这边，token实际上指的是Activity A或者B。</p><p>这个token是在AMS在回到IApplicationThread的scheduleLaunchActivity方法中传递过来的第二个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                         ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                                         CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                                         int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                                         List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                                         boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br></pre></td></tr></table></figure><p>这个会存在ActivityClientRecord中。这个token和对应的ActivityClientRecord会以键值对的形式存储在ActivityThread的变量mActivities中。后面再对Activity进行生命周期方法调用的时候，均可以通过AMS端传过来的token来获取正确的Activity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2083810-5ab48799a2bf09ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS与ActivityThread中相同token对应不同的Activity.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前面讲了一大堆，我们现在来总结概括一下这个过程和原理。<br>再来看一下需求：</p><ol><li><p>我们想启动一个Activity A页面，但是想要进入这个A页面必须是已经登录过的，如果没有登录的话就启动登录页面B，并且在B页面登录成功之后需要跳转到页面A</p></li><li><p>Activity页面A、B均没有在清单文件中注册，但是要完成正常的跳转</p></li></ol><p>为什么我们可以跳转到一个未在AndroidManifest.xml中声明的Activity中，而且可以根据不同的逻辑跳转到不同的页面呢？</p><p>调用startActivity方法启动一个目标Activity的时候，实际上会通过Instrumentation进行启动，再通过ActivityManagerService的本地代理对象调用ActivityManagerService的方法来启动一个Activity，这是一个IPC过程，在ActivityManagerService中会校验被启动的Activity的合法性，如果合法，会通过IPC过程调用ApplicationThread的方法，ApplicationThread是一个Binder对象，它的方法运行是在Binder线程池中的，所以需要采用一个Handler把方法调用切换到主线程，ApplicationThread通过发送消息，进而调用ActivityThread的handleLaunchActivity方法创建Activity，并执行Activity的生命周期方法。</p><p>传递到ActivityManagerService的被启动的Activity信息必须是声明过的，而如果我们想要启动一个没有在AndroidManifest.xml中声明的Activity，可以通过欺上瞒下的方法，hook ActivityManagerService在本地的代理对象，如果调用的是ActivityManagerProxy的startActivity方法，那么就更改这个Intent，替换成启动一个声明过的ProxyActivity，当ActivityManagerService校验完启动的合法性之后，会通过ApplicationThread调用到ActivityThread的一个叫做mH的Handler中来。当Handler收到消息的时候，会有一个消息分发的过程，如果给Handler设置了一个Callback，这个Callback的handleMessage方法就会先于Handler本身的handleMessage方法调用。所以可以想办法给这个叫做mH的Handler对象设置Callback，并且在Callback的handleMessage方法中从Message上面拿到相关的Intent信息，此时的Intent还是跳转到代理页面，可以根据当前是否登录，是否需要重定向到登录页面等对这个Intent进行相应的处理，比如设置为跳转到登录页或者真正想要跳转的页面，并由后续的mH的handleMessage来调用。</p><blockquote><p>更多细节，请查看项目 <strong><a href="https://github.com/sososeen09/apk-plugin-technology" target="_blank" rel="noopener">apk-plugin-technology</a></strong></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank" rel="noopener">Hook机制之AMS&amp;PMS</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/79278864" target="_blank" rel="noopener">从一道面试题开始说起 枚举、动态代理的原理</a></li><li><a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">understand-plugin-framework</a>（推荐）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动过程分析</title>
      <link href="/2018/04/01/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2018/04/01/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>通常我们在Activity中启动一个另一个Activity，就是调用Activity的startActivity方法，这个最终会调用到Activity的startActivityForResult方法。那你有没有想过Activity的启动到底经历了哪些过程，我们今天就来分析一下。</p><p>在具体分析之前，要先说明一下，Activity的启动流程在细节挺繁琐的，比如启动另一个App的Activity或者启动不同的launchMode的Activity，在细节上都会有不同。我们这次的源码分析着重分析一下流程，为了简单起见，就以分析一个Activity启动app内部另一个standard模式的Activity为主。</p><p>Activity启动另一个Activity之前，当前的Activity先要执行onPause，被启动的Activity才会执行到onResume方法。这中间实际上是会执行4次IPC过程的：</p><ul><li>当前Activity发起启动另一个Activity的请求——&gt;ActivityManagerService</li><li>ActivityManagerService——&gt; 通知App暂停当前Activity</li><li>当前App告知已经暂停了当前的Activity——&gt; ActivityManagerService</li><li>ActivityManagerService ——&gt; 通知App启动新的Activity</li></ul><blockquote><p>注：本次源码分析采用Android7.0，不同版本的源码在细节上会有不同，比如，在Android8.0上ActivityManagerService就改成了以AIDL的方式来写，请不要太纠结API的不同。</p><p>注：本文Activity启动过程源码分析过程比较长，代码较繁琐，请做好心理准备。</p></blockquote><h3 id="Activity启动涉及到的类"><a href="#Activity启动涉及到的类" class="headerlink" title="Activity启动涉及到的类"></a>Activity启动涉及到的类</h3><p>首先要简单介绍一下Activity启动过程涉及到的类，以便于更好的理解这个启动过程。</p><ul><li>ActivityThread：App启动的入口</li><li>ApplicationThread：ActivityThread的内部类，继承Binder，可以进程跨进程通信。</li><li>ApplicationThreadProxy：ApplicationThread的一个本地代理，其它的client端通过这个对象调用server端ApplicationThread中方法。</li><li>Instrumentation：负责发起Activity的启动、并具体负责Activity的创建以及Activity生命周期的回调。一个应用进程只会有一个Instrumentation对象，App内的所有Activity都持有该对象的引用。</li><li>ActivityManagerService：简称AMS，是service端对象，负责管理系统中所有的Activity</li><li>ActivityManagerProxy：是ActivityManagerService的本地代理</li><li>ActivityStack：Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li><li>ActivityRecord：ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li><li>TaskRecord：AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。</li></ul><p>介绍完这些，我们开始进入正题</p><h3 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h3><p>Activity启动最终会调用到startActivityForResult方法，我们只需要关注mParent == null中的逻辑即可。mParent代表的是ActivityGroup，其最开始是为了在一个界面中嵌入多个子Activity，在API13的时候就已经废弃了，可以使用Fragment表示一个界面的多个区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Activity</span><br><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">                                   @Nullable Bundle options) &#123;</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                        this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                        intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了Instrumentation的execStartActivity方法，在这里通过<code>ActivityManagerNative.getDefault()</code>方法获取ActivityManagerService的一个本地代理对象ActivityManagerProxy，然后调用了其startActivity方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># android.app.Instrumentation</span><br><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">       ... </span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下ActivityManagerNative，继承了Binder并实现了IActivityManager接口，ActivityManagerService就是继承了ActivityManagerNative。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager</span><br></pre></td></tr></table></figure><p>ActivityManagerNative实际上获取的就是其内部类ActivityManagerProxy对象。ActivityManagerProxy只是ActivityManagerService的本地代理对象，其startActivity方法会调用到AMS的startActivity方法。而且要注意，这个startActivity方法会把ApplicationThread对象传递到AMS所在进程，当然了AMS拿到的实际上是ApplicationThread的代理对象ApplicationThreadProxy，AMS就要通过这个代理对象与我们的App进程进行通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityManagerNative</span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">        &#125;</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in != null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">    return gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在Android8.0，由于使用AIDL的方式来写ActivityManagerService，ActivityManagerNative已经过期。</p><p>我们接着看一下AMS的startActivity方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">                               Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">                               int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startActivity方法紧接着调用了其startActivityAsUser方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">                                     Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">                                     int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, null, null, bOptions, false, userId, null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着调用了ActivityStarter的startActivityMayWait方法，由于方法很长，我们只保留关键的流程部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">        String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span><br><span class="line">        Bundle bOptions, boolean ignoreTargetSecurity, int userId,</span><br><span class="line">        IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">   </span><br><span class="line">        ...</span><br><span class="line">        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">                inTask);</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityStarter调用了自身的startActivityLocked方法，这又是一个很长的方法，保留关键的流程如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line"></span><br><span class="line">final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">        TaskRecord inTask) &#123;</span><br><span class="line">    int err = ActivityManager.START_SUCCESS;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true, options, inTask);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityStarter又调用了自身的startActivityUnchecked方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStarter</span><br><span class="line"></span><br><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mDoResume) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!mTargetStack.isFocusable()</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityStarter中调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line"></span><br><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityStackSupervisor的resumeFocusedStackTopActivityLocked中又调用了ActivityStack的resumeTopActivityUncheckedLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line"></span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">   ...</span><br><span class="line">    boolean result = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Protect against recursion.</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">        ...</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityStack在resumeTopActivityUncheckedLocked又调用了其自身的resumeTopActivityInnerLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">     ..</span><br><span class="line">    // We need to start pausing the current activity so the top one can be resumed...</span><br><span class="line">    ...</span><br><span class="line">    if (mResumedActivity != null) &#123;</span><br><span class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于当前的Activity执行了onResume，所以mResumedActivity != null 条件满足，就会调用startPausingLocked方法先暂停当前的Activity。注意：这个过程必然是一个IPC过程。我们看一下startPausingLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,</span><br><span class="line">        ActivityRecord resuming, boolean dontWait) &#123;</span><br><span class="line"></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (prev.app != null &amp;&amp; prev.app.thread != null) &#123;</span><br><span class="line">        if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line">            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                    userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> prev.app.thread表示的是IApplicationThread对象，在这里就是指的发起启动的Activity所在进程的ApplicationThread的本地代理ApplicationThreadProxy。调用它的schedulePauseActivity方法，很明显是一次IPC过程，最终调用到server端，也就是发起启动的Activity所在进程ApplicationThread的schedulePauseActivity方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$$ApplicationThread</span><br><span class="line"></span><br><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">    int seq = getLifecycleSeq();</span><br><span class="line">    if (DEBUG_ORDER) Slog.d(TAG, &quot;pauseActivity &quot; + ActivityThread.this</span><br><span class="line">            + &quot; operation received seq: &quot; + seq);</span><br><span class="line">    sendMessage(</span><br><span class="line">            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">            token,</span><br><span class="line">            (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0),</span><br><span class="line">            configChanges,</span><br><span class="line">            seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Hander的转发，接着会调用到ActivityThread的handlePauseActivity方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line"></span><br><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ...</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">        performPauseActivity(token, finished, r.isPreHoneycomb(), &quot;handlePauseActivity&quot;);</span><br><span class="line">    ...</span><br><span class="line">        // Tell the activity manager we have paused.</span><br><span class="line">        if (!dontReport) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityThread的handlePauseActivity中，首先会调用performPauseActivity来暂停当前的Activity，经过层层调用，会调用到Intrumentation的callActivityOnPause方法，最终调用Activity的onPause方法，这一块的流程比较简单，在这里就不再详细分析了，感兴趣的可以自己研究下。</p><p>暂停之后，会调动<code>ActivityManagerNative.getDefault().activityPaused(token)</code>，这个很明显又是一次IPC过程，就是告诉AMS，已经暂停当前的Activity，可以启动新的Activity 了。</p><p>我们来看一下AMS的的activityPaused方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityManagerService</span><br><span class="line">@Override</span><br><span class="line">public final void activityPaused(IBinder token) &#123;</span><br><span class="line">    final long origId = Binder.clearCallingIdentity();</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        if (stack != null) &#123;</span><br><span class="line">            stack.activityPausedLocked(token, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS中的activityPaused又调用了ActivityStack的activityPausedLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line"></span><br><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final ActivityRecord r = isInStackLocked(token);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);</span><br><span class="line">        if (mPausingActivity == r) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r</span><br><span class="line">                    + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));</span><br><span class="line">            completePauseLocked(true, null);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中又调用了ActivityStack自身的completePauseLocked方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line">    if (resumeNext) &#123;</span><br><span class="line">        final ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        if (!mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法，这视乎又重新调用了一遍，真复杂啊。</p><p>这个流程我们上面讲过了，ActivityStackSupervisor会继续调用ActivityStack的resumeTopActivityUncheckedLocked方法，然后ActivityStack又调用其resumeTopActivityInnerLocked方法，调来调去，又到这个方法里面了，上次在这里是执行了前一个Activity的onPause方法。这次会调用到ActivityStackSupersivor的startSpecificActivityLocked方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStack</span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    </span><br><span class="line">    // We need to start pausing the current activity so the top one can be resumed...</span><br><span class="line">    final boolean dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0;</span><br><span class="line">    boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause);</span><br><span class="line">    if (mResumedActivity != null) &#123;</span><br><span class="line">        if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">    if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里，好像我们的就要开始启动我们的目标Activity了，好激动有木有！</p><p>在ActivityStackSupersivor的startSpecificActivityLocked方法中会判断Activity所在进程是否存在，如果不存在的话就要创建一个新的进程。在这里，我们是Activity启动其App内部的另一个Activity，所以进程肯定是存在的，会走到realStartActivityLocked方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    ... </span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">    ...</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下ActivityStackSupersivor的realStartActivityLocked方法，这次似乎真的要启动一个Activity了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># com.android.server.am.ActivityStackSupervisor</span><br><span class="line"></span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</span><br><span class="line">                new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了代码，果然，调用了app.thread.scheduleLaunchActivity方法，app.thread我们前面讲过，就是IApplicationThread对象，实际上就是ApplicationThreadProxy对象，经过IPC过程会调用到ApplicationThread的scheduleLaunchActivity方法，我们来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread$$ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Hander的转发，接着会调用到ActivityThread的handlePauseActivity方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePauseActivity内部调用performLaunchActivity方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># android.app.ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            ...</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在performLaunchActivity内部，创建了Activity对象，并调用了activity的attach方法，在这个方法中绑定一些属性，并且创建了Activity所属的Window对象。接着Instrumentation会调用callActivityOnCreate、callActivityOnRestoreInstanceState、callActivityOnPostCreate等来完成Activity生命周期的回调。不过有一点很有意思，在这个方法中Activity自己调用了其performStart方法，但这个方法内部又调用了Instrumentation的callActivityOnStart方法，进而又调用了Activity的onStart方法。绕过来绕过去，总之，Activity生命周期方法的调用均是通过Instrumentation来控制的。</p><p>至此，Activity的启动过程算是分析完了，太费脑筋了，需要来一瓶营养快线补补身体。流程太多，不好记，但是有句话说的好 “一图胜千言”，下面我们来看一下Activity启动的一个时序图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-ca51f7c43a1cc209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity启动过程.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>源码分析过程是比较绕，比较烧脑的过程，不要太纠结去API的调用，尽量侧重流程。分析源码，最好带着问题去分析，不要为了分析而分析，尽量在分析过程中寻找自己想要的答案。比如：</p><ul><li>Activity对象是怎么创建的？</li><li>Window对象是什么时候创建的？</li><li>LayoutInflater什么时候创建的？</li><li>为什么在Activity中的布局中或者Fragment的中View获取的Context都是其所在的Activity对象？</li><li>为什么自定义View一定要有两个参数的构造函数？</li><li>Activity的生命周期方法是被谁回调的？</li><li>Application是什么时候创建的？</li><li>ClassLoader对象是什么时候创建的？</li><li>子线程可以启动Activity、Service吗？</li><li>下拉通知栏，会影响Activity生命周期吗？</li></ul><p>笔者初入Android开发没多久的时候，有次面试，面试官问我在子线程中启动Activity可以吗？我回答可以，因为我试过，但是问我为什么我却不知道。如果那时候看了Activity启动过程的源码，看了Binder机制的话，应该很容易的就回答出来了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.csdn.net/qian520ao/article/details/78156214#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">Android Launcher 启动 Activity 的工作过程</a></li><li><a href="https://www.jianshu.com/p/6037f6fda285" target="_blank" rel="noopener">【凯子哥带你学Framework】Activity启动过程全解析</a></li><li><a href="https://blog.csdn.net/qq_30379689/article/details/79611217" target="_blank" rel="noopener">Android进阶——Android四大组件启动机制之Activity启动过程</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binder学习概要</title>
      <link href="/2018/03/18/Binder%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A6%81/"/>
      <url>/2018/03/18/Binder%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>很早就想写一篇Binder的文章了，但是迟迟没写出来，因为Binder机制牵涉到的知识点太多了，有Java层的Binder，也有底层的binder驱动。通常我们在Java层面做应用开发牵涉到Binder的，有AIDL、Messenger等。如何写AIDL、Messenger相关的代码并不难，难点在于理解Binder的原理。如果想要系统地学习Binder，推荐看《Android开发艺术探索》的相关章节以及老罗《Android进程间通信（IPC）机制Binder简要介绍和学习计划》系列，分别对应的是Java层的Binder机制和底层的Binder机制。还有一些其它的优秀的文章，文后会有推荐。</p><p>本文不打算深入地介绍Binder 机制的原理，毕竟这不是一两篇文章能介绍的清楚的，而且现在网上也有很多优秀的文章。本文想介绍的是我个人通过对Binder地学习，对Binder机制和Android系统的一些理解。</p><p>限于水平，难免有误，还请指正。</p><h1 id="Binder基本介绍"><a href="#Binder基本介绍" class="headerlink" title="Binder基本介绍"></a>Binder基本介绍</h1><p>Binder是Android系统运行的一个重要基石，做Android开发的应该没有没听说过Binder的吧，那么Binder到底是个什么东西呢？</p><p>Binder，最简单来说就是一个Java类，全路径名是 <code>android.os.Binder</code> ，一般我们看到包名是 <code>android.os</code> 的，就应该想到它是系统运行相关的类。这个Binder类实现了IBinder接口，代表这个类的对象具有跨进程通讯的能力。从IPC角度上讲，Binder是Android中一种跨进程通讯方式。Binder还可以理解为一个虚拟的物理设备，这是因为它是有驱动的，但是又不像一般的硬件那样有物理实体，它的设备驱动是/dev/binder，这个驱动是Android特有的，Linux中没有。从Framework层讲，是ServiceManager与各种manager，比如ActivityManagerService、WindowManagerService和各种ManagerService进行通讯的桥梁；从应用层来说，Binder是客户端和服务端进行通讯的媒介。</p><p>我觉得不管从什么角度来看Binder，Binder的作用就是用来进行跨进程通讯 (IPC) 的。这里，我们需要简单介绍下IPC，以便于更好的理解Binder的作用。</p><h1 id="IPC方式"><a href="#IPC方式" class="headerlink" title="IPC方式"></a>IPC方式</h1><p>任何一个系统都需要有相应的IPC机制，Linux上面可以通过管道、System V IPC，即消息队列/共享内存/信号量，或者Socket的方式来进行跨进程通讯，Android是基于Linux的，也就是说Android也可以使用这些IPC方式，那么Android系统为什么还要再引入Binder这种IPC方式呢？这个问题，我觉得可以从三个方面来回答：使用方便、传输性能、安全。</p><ul><li>使用方便： Binder是基于C/S架构的，利用了面向对象的思想，对于开发者使用来说，很方便。从这个角度来说，共享内存这种方式就不适合，因为它使用太复杂。</li><li>传输性能：Android毕竟是移动设备，移动设备就要考虑内存占用和耗电量的问题，Binder只需要拷贝内存1次，而管道、消息队列、Socket都需要对数据拷贝2次。</li><li>安全：传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</li></ul><table><thead><tr><th>IPC</th><th>数据拷贝次数</th></tr></thead><tbody><tr><td>共享内存</td><td>0</td></tr><tr><td>Binder</td><td>1</td></tr><tr><td>Socket/管道/消息队列</td><td>2</td></tr></tbody></table><p>基于以上这些原因，Android引入了Binder这种IPC方式，基于C/S架构，传输过程只需要1次拷贝，为发送方添加UID/PID身份验证，既支持实名Binder也支持匿名Binder，安全性高。</p><h1 id="Binder中的4种角色"><a href="#Binder中的4种角色" class="headerlink" title="Binder中的4种角色"></a>Binder中的4种角色</h1><ul><li>Client：客户端，使用服务的一端</li><li>Server：服务端，提供服务的一端</li><li>ServerManager：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。其实ServiceManager端也是一个Server端，也有自己的Binder实体，对于ServerManager端来说，其它端都是client端。它是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力。</li><li>Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2083810-fb7acce231ab846f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片摘自老罗的Binder简要介绍和学习计划.png"></p><p>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中。 Client和Server之间的进程间通信通过Binder驱动程序间接实现。Binder驱动程序和Service Manager在Android平台中已经实现，对于我们应用开发者来说，只需要实现自己的Client和Server就行，常见的就是使用AIDL的方式来实现IPC。</p><h1 id="应用开发中的Binder使用"><a href="#应用开发中的Binder使用" class="headerlink" title="应用开发中的Binder使用"></a>应用开发中的Binder使用</h1><p>Binder的那些概念介绍是挺枯燥乏味的，在Android开发中我们无时不刻不在使用Binder，那么我们就结合平时的开发来了解一些使用的Binder机制的地方。</p><p>1 Activity启动</p><p>Activity的启动需要用到ActivityManagerService，但是我们的App进程和ActivityManagerService所在的进程不是同一个进程，所以就需要用到进程间通讯了。在App进程中我们拿到的是ActivityManagerService的一个分身，也就是ActivityManagerProxy，这个ActivityManagerProxy与ActivityManagerService都实现了IActivityManager接口，因此它们具有相同的功能，但是ActivityManagerProxy只是做了一个中转，创建两个Parcel对象，一个用于携带请求的参数，一个用于拿到请求结果，然后调用transact方法，通过Binder驱动，ActivityManagerService的onTransact方法会被调用，然后根据相应的code，调用相应的方法，并把处理结果返回。</p><p><strong>在这个过程中，我们的App进程就是Client，ActivityManagerService所在的进程是Service。</strong></p><p>但是Activity的启动过程还没有完，ActivityManagerService还会调用我们App所在进程的ApplicationThread来最终完成Activity的启动，其实ActivityManagerService拿到的也是ApplicationThread的一个分身ApplicationThreadProxy，通过这个分身，ApplicationThread相应的方法会被调用。</p><p><strong>在这个过程中，我们的App端是Server，ActivityManagerService所在的进程是Client。</strong></p><p>还有一个问题我们要注意，ActivityThread有一个内部类H（一个Hander），ApplicationThread方法内部都会通过这个Handler来发送消息，最终调用到ActivityThread的方法。为什么要这么做呢？</p><p>在分析源码的过程中，很长一段时间，这个问题都困扰着我，直到有一天对Binder的理解加深了，我才明白：<strong>Binder服务端的方法都是运行在Binder线程池的一个线程中的，所以要通过Hander，把方法的调用切换到主线程中来</strong>。</p><p>2 Intent携带数据</p><p>我们都知道Intent可以传递的数据包含：基本类型、String、实现了Serializable接口或者Parcelable接口的类以及对应的数组或者集合类。其实Intent中的数据都是通过Bundle来携带的，那么我们就要有个疑问了，为什么限定只能是这些类型的数据，而不是任意的数据类型呢？</p><p>归根结底，限制这些类型的是Parcel这个类。如果我们查看源码的话就会看到，Bundle其实也是用到了Parcel这个类。</p><p>Parcel ，“包裹的意思”，它的作用就是为了在IPC过程中存放数据。我们要知道一点，进程间传递数据，实际上就是二进制数据，所以对于非基本类型，必然存在着序列化和反序列过程，这也是为什么要求Intent传递的非基本类型数据必须实现Serializable或者Parcelable接口的原因。</p><p>至于Parcel在IPC过程中使用到的地方，我们可以看一段代码，这个是我仿造着AIDL生成的文件，自己手写的一个Binder服务端。看一下Proxy类的add方法，实际上就是先创建两个Parcel对象，一个通过调用 writexxx 方法用于存放请求数据，一个是通过调用 readxxx 方法获取结果。Proxy真正干的就是这些，真正计算的还是服务端Stub的实现类。当Proxy调用 <code>mRemote.transact(TRANSACTION_add, _data, _reply, 0);</code> 方法后，Stub的onTransact方法会被调用，进而调用真正的add方法。</p><p>在这里，我们就可以看到Parcel的一系列 writexxx、readxxx方法的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public interface ICalculateInterface extends IInterface &#123;</span><br><span class="line"></span><br><span class="line">    public abstract class Stub extends Binder implements ICalculateInterface &#123;</span><br><span class="line">        private static final String DESCRIPTOR = &quot;com.sososeen09.knowledge.ipc.handipc.ICalculateInterface&quot;;</span><br><span class="line"></span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static ICalculateInterface asInterface(IBinder obj) &#123;</span><br><span class="line">            if (obj == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IInterface iInterface = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">            if (iInterface != null &amp;&amp; iInterface instanceof ICalculateInterface) &#123;</span><br><span class="line">                return (ICalculateInterface) iInterface;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new Proxy(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    int _arg0, _arg1, _result;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    _result = this.add(_arg0, _arg1);</span><br><span class="line"></span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements ICalculateInterface &#123;</span><br><span class="line"></span><br><span class="line">            private IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            public Proxy(IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int add(int a, int b) throws RemoteException &#123;</span><br><span class="line">                Parcel _data = Parcel.obtain();</span><br><span class="line">                Parcel _reply = Parcel.obtain();</span><br><span class="line">                int result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line"></span><br><span class="line">                    mRemote.transact(TRANSACTION_add, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line"></span><br><span class="line">                    result = _reply.readInt();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final int TRANSACTION_add = (IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    int add(int a, int b) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Binder的介绍和Java层的使用，先介绍到这里，这些内容会持续更新。</p><h1 id="Binder使用的一些注意事项"><a href="#Binder使用的一些注意事项" class="headerlink" title="Binder使用的一些注意事项"></a>Binder使用的一些注意事项</h1><ul><li>Binder方法是在Binder线程池中被调用的，所以不需要再次new一个线程了，Client调用Server端方法，当前线程会被调起，太耗时的话记得用一个线程来调用。</li><li>Intent携带的数据大小是限制了，不要超过1M，否则就会报一个TransactionTooLargeException的异常。这是因为Binder数据的缓存大小就是1M。有的时候，即使一次携带的数据不到1M，还是可能会报异常，因为存在并发的情况。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></li><li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a></li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">田维术-Binder学习指南</a></li><li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">小米系统工程师gityuan——Binder系列</a></li><li><a href="http://www.jianshu.com/p/c7bcb4c96b38" target="_blank" rel="noopener">Android面试一天一题（Day 35：神秘的Binder机制</a></li><li><a href="https://www.qcloud.com/community/article/546217" target="_blank" rel="noopener">Binder 总体架构及相关代码浅析</a></li><li><a href="http://blog.csdn.net/qian520ao/article/details/78089877" target="_blank" rel="noopener">Android Binder之应用层总结与分析</a></li><li><a href="https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78433798" target="_blank" rel="noopener">Android Binder之应用层精彩解析</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/01/29/hello-world/"/>
      <url>/2018/01/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Hexo-配置参考"><a href="#Hexo-配置参考" class="headerlink" title="Hexo 配置参考"></a>Hexo 配置参考</h3><ul><li><a href="http://blog.shenyuanluo.com/HexoConfig1.html" target="_blank" rel="noopener">Hexo的Next主题个性化设置（一）——基础设置</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制系列3——MultiDex原理解析</title>
      <link href="/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94MultiDex%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94MultiDex%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="MultiDex的由来"><a href="#MultiDex的由来" class="headerlink" title="MultiDex的由来"></a>MultiDex的由来</h1><p>Android中由于一个dex文件最多存储65536个方法，也就是一个short类型的范围，所以随着应用的类不断增加，当一个dex文件突破这个方法数的时候就会报出异常。虽然可以通过混淆等方式来减少无用的方法，但是随着APP功能的增多，突破方法数限制还是不可避免的。因此在Android5.0时，Android推出了官方的解决方案：MultiDex。打包的时候，把一个应用分成多个dex，例如：classes.dex、classes2.dex、classes3.dex…，加载的时候把这些dex都追加到DexPathList对应的数组中，这样就解决了方法数的限制。</p><p>5.0后的系统都内置了加载多个dex文件的功能，而在5.0之前，系统只可以加载一个主dex，其它的dex就需要采用一定的手段来加载。这也就是我们今天要讲的MultiDex。</p><p>MultiDex存放在<code>android.support.multidex包下</code>。</p><h1 id="MultiDex的使用"><a href="#MultiDex的使用" class="headerlink" title="MultiDex的使用"></a>MultiDex的使用</h1><p>Gradle构建环境下，在主应用的build.gradle文件夹添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    multiDexEnabled true</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support:multidex:1.0.1&apos;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在最新的multidex版本是1.0.2。</p><p>在AndroidManifest.xml中的app节点下，使用<code>MultiDexApplication</code>作为应用入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package android.support.multidex;</span><br><span class="line">...</span><br><span class="line">public class MultiDexApplication extends Application &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然了，大部分情况下，我们都会自定义一个自己的Application对应用做一些初始化。这种情况下，可以在我们自定义的Application中的attachBaseContext()方法中调用MultiDex.install()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自定义的Applicaiton中</span><br><span class="line">  @Override</span><br><span class="line">  protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：MultiDex.install()方法的调用时机要尽可能的早，防止加载后面的dex文件中的类时报ClassNotFoundException。</p><h1 id="MultiDex源码分析"><a href="#MultiDex源码分析" class="headerlink" title="MultiDex源码分析"></a>MultiDex源码分析</h1><p>分析MultiDex的的入口就是它的静态方法install()。<br>这个方法的作用就是把从应用的APK文件中的dex添加到应用的类加载器PathClassLoader中的DexPathList的Emlement数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public static void install(Context context) &#123;</span><br><span class="line">    Log.i(TAG, &quot;install&quot;);</span><br><span class="line">    //判断Android系统是否已经支持了MultiDex，如果支持了就不需要再去安装了，直接返回</span><br><span class="line">    if (IS_VM_MULTIDEX_CAPABLE) &#123;</span><br><span class="line">        Log.i(TAG, &quot;VM has multidex support, MultiDex support library is disabled.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果Android系统低于MultiDex最低支持的版本就抛出异常</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Multi dex installation failed. SDK &quot; + Build.VERSION.SDK_INT</span><br><span class="line">                + &quot; is unsupported. Min SDK version is &quot; + MIN_SDK_VERSION + &quot;.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取应用信息</span><br><span class="line">        ApplicationInfo applicationInfo = getApplicationInfo(context);</span><br><span class="line">        // 如果应用信息为空就返回，比如说运行在一个测试的Context下。</span><br><span class="line">        if (applicationInfo == null) &#123;</span><br><span class="line">            // Looks like running on a test Context, so just return without patching.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同步方法</span><br><span class="line">        synchronized (installedApk) &#123;</span><br><span class="line">            // 获取已经安装的APK的全路径</span><br><span class="line">            String apkPath = applicationInfo.sourceDir;</span><br><span class="line">            if (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 把路径添加到已经安装的APK路径中</span><br><span class="line">            installedApk.add(apkPath);</span><br><span class="line">            // 如果编译版本大于最大支持版本，报一个警告</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</span><br><span class="line">                Log.w(TAG, &quot;MultiDex is not guaranteed to work in SDK version &quot;</span><br><span class="line">                        + Build.VERSION.SDK_INT + &quot;: SDK version higher than &quot;</span><br><span class="line">                        + MAX_SUPPORTED_SDK_VERSION + &quot; should be backed by &quot;</span><br><span class="line">                        + &quot;runtime with built-in multidex capabilty but it&apos;s not the &quot;</span><br><span class="line">                        + &quot;case here: java.vm.version=\&quot;&quot;</span><br><span class="line">                        + System.getProperty(&quot;java.vm.version&quot;) + &quot;\&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /* The patched class loader is expected to be a descendant of</span><br><span class="line">             * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">             * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">             * file entries.</span><br><span class="line">             */</span><br><span class="line">            ClassLoader loader;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 获取ClassLoader，实际上是PathClassLoader</span><br><span class="line">                loader = context.getClassLoader();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                /* Ignore those exceptions so that we don&apos;t break tests relying on Context like</span><br><span class="line">                 * a android.test.mock.MockContext or a android.content.ContextWrapper with a</span><br><span class="line">                 * null base Context.</span><br><span class="line">                 */</span><br><span class="line">                Log.w(TAG, &quot;Failure while trying to obtain Context class loader. &quot; +</span><br><span class="line">                        &quot;Must be running in test mode. Skip patching.&quot;, e);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 在某些测试环境下ClassLoader为null</span><br><span class="line">            if (loader == null) &#123;</span><br><span class="line">                // Note, the context class loader is null when running Robolectric tests.</span><br><span class="line">                Log.e(TAG,</span><br><span class="line">                        &quot;Context class loader is null. Must be running in test mode. &quot;</span><br><span class="line">                                + &quot;Skip patching.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 清除老的缓存的Dex目录，来源的缓存目录是&quot;/data/user/0/$&#123;packageName&#125;/files/secondary-dexes&quot;</span><br><span class="line">                clearOldDexDir(context);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Something went wrong when trying to clear old MultiDex extraction, &quot;</span><br><span class="line">                        + &quot;continuing without cleaning.&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            // 新建一个存放dex的目录，路径是&quot;/data/user/0/$&#123;packageName&#125;/code_cache/secondary-dexes&quot;，用来存放优化后的dex文件</span><br><span class="line">            File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">            // 使用MultiDexExtractor这个工具类把APK中的dex抽取到dexDir目录中，返回的files集合有可能为空，表示没有secondaryDex</span><br><span class="line">            // 不强制重新加载，也就是说如果已经抽取过了，可以直接从缓存目录中拿来使用，这么做速度比较快</span><br><span class="line">            List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);</span><br><span class="line">            if (checkValidZipFiles(files)) &#123;</span><br><span class="line">                // 如果抽取的文件是有效的，就安装secondaryDex</span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.w(TAG, &quot;Files were not valid zip files. Forcing a reload.&quot;);</span><br><span class="line">                // Try again, but this time force a reload of the zip file.</span><br><span class="line">                // 如果抽取出的文件是无效的，那么就强制重新加载，这么做的话速度就慢了一点，有一些IO开销</span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);</span><br><span class="line">                if (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    // 强制加载后，如果文件有效就安装，否则就抛出异常</span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Second time didn&apos;t work, give up</span><br><span class="line">                    throw new RuntimeException(&quot;Zip files were not valid.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Multidex installation failure&quot;, e);</span><br><span class="line">        throw new RuntimeException(&quot;Multi dex installation failed (&quot; + e.getMessage() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, &quot;install done&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于dex文件抽取逻辑和校验逻辑我们先不管，我们看一下MultiDex是如何安装secondaryDex文件的。<br>由于不同版本的Android系统，类加载机制有一些不同，所以分为了V19、V14和V4等三种情况下的安装。V19、V14和V4都是MultiDex的private的静态内部类。V19支持Andorid19版本(20是只支持可穿戴设备的)，V14支持14,、15、16、17 和 18版本，V4支持从4到13的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDex</span><br><span class="line">private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span><br><span class="line">        throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span><br><span class="line">        InvocationTargetException, NoSuchMethodException, IOException &#123;</span><br><span class="line">    if (!files.isEmpty()) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下V19的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Installer for platform versions 19.</span><br><span class="line"> */</span><br><span class="line">private static final class V19 &#123;</span><br><span class="line">    private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">            File optimizedDirectory)</span><br><span class="line">                    throws IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                    NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        /* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span><br><span class="line">        // 传递的loader是PathClassLoader，findFidld()方法是遍历loader及其父类找到pathList字段</span><br><span class="line">        // 实际上就是找到BaseClassLoader中的DexPathList</span><br><span class="line">        Field pathListField = findField(loader, &quot;pathList&quot;);</span><br><span class="line">        // 获取PathClassLoader绑定的DexPathList对象</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">        // 扩展DexPathList对象的Element数组，数组名是dexElements</span><br><span class="line">        // makeDexElements()方法的作用就是调用DexPathList的makeDexElements()方法来创建dex元素</span><br><span class="line">        expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList,</span><br><span class="line">                new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        // 后面就是添加一些IO异常信息，因为调用DexPathList的makeDexElements会有一些IO操作，相应的可能就会有一些异常情况</span><br><span class="line">        if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">            for (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Exception in makeDexElement&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Field suppressedExceptionsField =</span><br><span class="line">                    findField(loader, &quot;dexElementsSuppressedExceptions&quot;);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</span><br><span class="line">            if (dexElementsSuppressedExceptions == null) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions =</span><br><span class="line">                        suppressedExceptions.toArray(</span><br><span class="line">                                new IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                IOException[] combined =</span><br><span class="line">                        new IOException[suppressedExceptions.size() +</span><br><span class="line">                                        dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, 0, combined,</span><br><span class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * A wrapper around</span><br><span class="line">     * &#123;@code private static final dalvik.system.DexPathList#makeDexElements&#125;.</span><br><span class="line">     */</span><br><span class="line">    // 通过反射的方式调用DexPathList#makeDexElements()方法</span><br><span class="line">    // dexPathList 就是一个DexPathList对象</span><br><span class="line">    private static Object[] makeDexElements(</span><br><span class="line">            Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">                    throws IllegalAccessException, InvocationTargetException,</span><br><span class="line">                    NoSuchMethodException &#123;</span><br><span class="line">        // 获取DexPathList的makeDexElements()方法</span><br><span class="line">        Method makeDexElements =</span><br><span class="line">                findMethod(dexPathList, &quot;makeDexElements&quot;, ArrayList.class, File.class,</span><br><span class="line">                        ArrayList.class);</span><br><span class="line">        // 调用makeDexElements()方法，根据外界传递的包含dex文件的源文件和优化后的缓存目录返回一个Element[]数组</span><br><span class="line">        return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory,</span><br><span class="line">                suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultiDex的expandFieldArray()方法作用是扩展一个对象中的数组中的元素。实际上就是一个工具方法。简单看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDex</span><br><span class="line">private static void expandFieldArray(Object instance, String fieldName,</span><br><span class="line">        Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException,</span><br><span class="line">        IllegalAccessException &#123;</span><br><span class="line">    Field jlrField = findField(instance, fieldName);</span><br><span class="line">    Object[] original = (Object[]) jlrField.get(instance);</span><br><span class="line">    Object[] combined = (Object[]) Array.newInstance(</span><br><span class="line">            original.getClass().getComponentType(), original.length + extraElements.length);</span><br><span class="line">    System.arraycopy(original, 0, combined, 0, original.length);</span><br><span class="line">    System.arraycopy(extraElements, 0, combined, original.length, extraElements.length);</span><br><span class="line">    jlrField.set(instance, combined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>V19的install()方法调用完毕之后，就把APK文件中的主dex文件之外的dex文件追加到PathClassLoader（也就是BaseClassLoader）中DexPathListde Element[]数组中。这样在加载一个类的时候就会遍历所有的dex文件，保证了打包的类都能够正常加载。</p><p>至于V14和V4中的install()方法，主要的思想都是一致的，在细节上有一些不同，有兴趣的可以自行查看相关源码。</p><p>小结一下：<br>MultiDex的install()方法实际上是先抽取出APK文件中的.dex文件，然后利用反射把这个.dex文件生成对应的数组，最后把这些dex路径追加到PathClassLoader加载dex的路径中，从而保证了APK中所有.dex文件中类都能够被正确的加载。</p><p>分析完了，MultiDex加载secondartDex的逻辑，我们再来看一下从APK文件中抽取出.dex文件的逻辑。<br>看一下MultiDexExtractor的load()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">static List&lt;File&gt; load(Context context, ApplicationInfo applicationInfo, File dexDir,</span><br><span class="line">        boolean forceReload) throws IOException &#123;</span><br><span class="line">    Log.i(TAG, &quot;MultiDexExtractor.load(&quot; + applicationInfo.sourceDir + &quot;, &quot; + forceReload + &quot;)&quot;);</span><br><span class="line">    // sourceDir 路径为&quot;/data/app/&#125;$&#123;packageName&#125;-1/base.apk&quot;</span><br><span class="line">    final File sourceApk = new File(applicationInfo.sourceDir);</span><br><span class="line">    // 获取APK文件的CRC（循环冗余校验）</span><br><span class="line">    long currentCrc = getZipCrc(sourceApk);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files;</span><br><span class="line">    // 如果不需要重新加载并且文件没有被修改过</span><br><span class="line">    // isModified()方法是根据SharedPreference中存放的APK文件上一次修改的时间戳和currentCrc来判断是否修改过文件</span><br><span class="line">    if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 从缓存目录中加载已经抽取过的文件</span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Failed to reload existing extracted secondary dex files,&quot;</span><br><span class="line">                    + &quot; falling back to fresh extraction&quot;, ioe);</span><br><span class="line">            // 如果从缓存中加载失败就需要冲APK文件中去加载，这个过程时间会长一点</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            // 把抽取信息保存到SharedPreferences中，方便下次使用</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果强制加载或者APK文件已经修改过就重新抽取dex文件</span><br><span class="line">        Log.i(TAG, &quot;Detected that extraction must be performed.&quot;);</span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, &quot;load found &quot; + files.size() + &quot; secondary dex files&quot;);</span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前后顺序的话，App第一次运行的时候需要从APK冲抽取dex文件，我们先来看一下MultiDexExtractor的performExtractions()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">private static List&lt;File&gt; performExtractions(File sourceApk, File dexDir)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    // 抽取出的dex文件名前缀是&quot;$&#123;apkName&#125;.classes&quot;</span><br><span class="line">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line"></span><br><span class="line">    // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that</span><br><span class="line">    // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,</span><br><span class="line">    // multi-process race conditions can cause a crash loop where one process deletes the zip</span><br><span class="line">    // while another had created it.</span><br><span class="line">    // 由于这个dexDir缓存目录可能不止一个APK在使用，在抽取一个APK之前如果有缓存过的与APK相关的dex文件就需要先删除掉，如果dexDir目录不存在就需要创建</span><br><span class="line">    prepareDexDir(dexDir, extractedFilePrefix);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">    final ZipFile apk = new ZipFile(sourceApk);</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        int secondaryNumber = 2;</span><br><span class="line">        // 获取&quot;classes$&#123;secondaryNumber&#125;.dex&quot;格式的文件</span><br><span class="line">        ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</span><br><span class="line">        // 如果dexFile不为null就一直遍历</span><br><span class="line">        while (dexFile != null) &#123;</span><br><span class="line">            // 抽取后的文件名是&quot;$&#123;apkName&#125;.classes$&#123;secondaryNumber&#125;.zip&quot;</span><br><span class="line">            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">            // 创建文件</span><br><span class="line">            File extractedFile = new File(dexDir, fileName);</span><br><span class="line">            // 添加到集合中</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, &quot;Extraction is needed for file &quot; + extractedFile);</span><br><span class="line">            // 抽取过程中存在失败的可能，可以多次尝试，使用isExtractionSuccessful作为是否成功的标志</span><br><span class="line">            int numAttempts = 0;</span><br><span class="line">            boolean isExtractionSuccessful = false;</span><br><span class="line">            while (numAttempts &lt; MAX_EXTRACT_ATTEMPTS &amp;&amp; !isExtractionSuccessful) &#123;</span><br><span class="line">                numAttempts++;</span><br><span class="line"></span><br><span class="line">                // Create a zip file (extractedFile) containing only the secondary dex file</span><br><span class="line">                // (dexFile) from the apk.</span><br><span class="line">                // 抽出去apk中对应序号的dex文件，存放到extractedFile这个zip文件中，只包含它一个</span><br><span class="line">                // extract方法就是一个IO操作</span><br><span class="line">                extract(apk, dexFile, extractedFile, extractedFilePrefix);</span><br><span class="line"></span><br><span class="line">                // Verify that the extracted file is indeed a zip file.   </span><br><span class="line">                // 判断是够抽取成功</span><br><span class="line">                isExtractionSuccessful = verifyZipFile(extractedFile);</span><br><span class="line"></span><br><span class="line">                // Log the sha1 of the extracted zip file</span><br><span class="line">                Log.i(TAG, &quot;Extraction &quot; + (isExtractionSuccessful ? &quot;success&quot; : &quot;failed&quot;) +</span><br><span class="line">                        &quot; - length &quot; + extractedFile.getAbsolutePath() + &quot;: &quot; +</span><br><span class="line">                        extractedFile.length());</span><br><span class="line">                if (!isExtractionSuccessful) &#123;</span><br><span class="line">                    // Delete the extracted file</span><br><span class="line">                    extractedFile.delete();</span><br><span class="line">                    if (extractedFile.exists()) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;Failed to delete corrupted secondary dex &apos;&quot; +</span><br><span class="line">                                extractedFile.getPath() + &quot;&apos;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isExtractionSuccessful) &#123;</span><br><span class="line">                throw new IOException(&quot;Could not create zip file &quot; +</span><br><span class="line">                        extractedFile.getAbsolutePath() + &quot; for secondary dex (&quot; +</span><br><span class="line">                        secondaryNumber + &quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 继续下一个dex的抽取</span><br><span class="line">            secondaryNumber++;</span><br><span class="line">            dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            apk.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Failed to close resource&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当MultiDexExtractor的performExtractions()方法调用完毕的时候就把APK中所有的dex文件抽取出来，并以一定文件名格式的zip文件保存在缓存目录中。然后再把一些关键的信息通过调用<code>putStoredApkInfo(Context context, long timeStamp, long crc,            int totalDexNumber)</code>方法保存到SP中。</p><p>当APK之后再启动的时候就会从缓存目录中去加载已经抽取过的dex文件。我们接着来看一下MultiDexExtractor的loadExistingExtractions()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># android.support.multidex.MultiDexExtractor</span><br><span class="line">private static List&lt;File&gt; loadExistingExtractions(Context context, File sourceApk, File dexDir)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    Log.i(TAG, &quot;loading existing secondary dex files&quot;);</span><br><span class="line">    // 抽取出的dex文件名前缀是&quot;$&#123;apkName&#125;.classes&quot;</span><br><span class="line">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line">    // 从SharedPreferences中获取.dex文件的总数量，调用这个方法的前提是已经抽取过dex文件，所以SP中是有值的</span><br><span class="line">    int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);</span><br><span class="line">    final List&lt;File&gt; files = new ArrayList&lt;File&gt;(totalDexNumber);</span><br><span class="line"></span><br><span class="line">    // 从第2个dex开始遍历，这是因为主dex由Android系统自动加载的，从第2个开始即可</span><br><span class="line">    for (int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">        // 文件名，格式是&quot;$&#123;apkName&#125;.classes$&#123;secondaryNumber&#125;.zip&quot;</span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">        // 根据缓存目录和文件名得到抽取后的文件</span><br><span class="line">        File extractedFile = new File(dexDir, fileName);</span><br><span class="line">        // 如果是一个文件就保存到抽取出的文件列表中</span><br><span class="line">        if (extractedFile.isFile()) &#123;</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            if (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">                Log.i(TAG, &quot;Invalid zip file: &quot; + extractedFile);</span><br><span class="line">                throw new IOException(&quot;Invalid ZIP file.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Missing extracted secondary dex file &apos;&quot; +</span><br><span class="line">                    extractedFile.getPath() + &quot;&apos;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这，MultiDex安装多个dex的原理应该介绍清楚了，无非就是通过一定的方式把dex文件抽取出来，然后把这些dex文件追加到DexPathList的Element[]数组的后面，这个过程要尽可能的早，所以一般是在Application的attachBaseContext()方法中。<br>一些热修复技术，就是通过一定的方式把修复后的dex插入到DexPathList的Element[]数组<strong>前面</strong>，实现了修复后的class抢先加载。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="noopener">美团Android DEX自动拆包及动态加载简介</a></li><li><a href="https://neyoufan.github.io/2017/01/20/android/Multidex%E5%8A%A0%E9%80%9F/" title="谈谈MultiDex启动优化" target="_blank" rel="noopener">谈谈MultiDex启动优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/24305296" target="_blank" rel="noopener">MultiDex工作原理分析和优化方案</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制系列2——深入理解Android中的类加载器</title>
      <link href="/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Android中的ClassLoader"><a href="#Android中的ClassLoader" class="headerlink" title="Android中的ClassLoader"></a>Android中的ClassLoader</h1><p>Java中的ClassLoader是加载class文件，而Android中的虚拟机无论是dvm还是art都只能识别dex文件。因此Java中的ClassLoader在Android中不适用。Android中的<code>java.lang.ClassLoader</code>这个类也不同于Java中的<code>java.lang.ClassLoader</code>。<br>Android中的ClassLoader类型也可分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括3种分别是：</p><ul><li>BootClassLoader，Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的Bootstrap ClassLoader不同的是，它并不是由C/C++代码实现，而是由Java实现的。BootClassLoader是ClassLoader的一个内部类。</li><li>PathClassLoader，全名是<code>dalvik/system.PathClassLoader</code>，可以加载已经安装的Apk，也就是<code>/data/app/package</code> 下的apk文件，也可以加载<code>/vendor/lib, /system/lib</code>下的nativeLibrary。</li><li>DexClassLoader，全名是<code>dalvik/system.DexClassLoader</code>，可以加载一个未安装的apk文件。</li></ul><p><code>PathClassLoader</code>和<code>DexClasLoader</code>都是继承自 <code>dalviksystem.BaseDexClassLoader</code>，它们的类加载逻辑全部写在<code>BaseDexClassLoader</code>中。<br>下图展示了Android中的ClassLoader中的继承体系，其中SecureClassLoader和UrlClassLoader是在Java中的类加载器，在Android中是没法办使用的。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-64e93a71d99c1459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android中的ClassLoader.png"></p><p>在MainActivity中打印当前的ClassLoader，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ClassLoader classLoader = getClassLoader();</span><br><span class="line">        while (classLoader != null) &#123;</span><br><span class="line">            System.out.println(&quot;classLoader: &quot; + classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.sososeen09.classloadtest-1/base.apk&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">java.lang.BootClassLoader@aced87d</span><br></pre></td></tr></table></figure><p>从打印的结果也可以证实：App系统类加载器是PathClassLoader，而BootClassLoader是其parent类加载器。</p><h1 id="ClassLoader源码分析"><a href="#ClassLoader源码分析" class="headerlink" title="ClassLoader源码分析"></a>ClassLoader源码分析</h1><p>在Android中我们主要关心的是PathClassLoader和DexClassLoader。<br>PathClassLoader用来操作本地文件系统中的文件和目录的集合。并不会加载来源于网络中的类。Android采用这个类加载器一般是用于加载系统类和它自己的应用类。这个应用类放置在data/data/包名下。<br>看一下PathClassLoader的源码，只有2个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, String libraryPath,</span><br><span class="line">            ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexClassLoader可以加载一个未安装的APK，也可以加载其它包含dex文件的JAR/ZIP类型的文件。DexClassLoader需要一个对应用私有且可读写的文件夹来缓存优化后的class文件。而且一定要注意不要把优化后的文件存放到外部存储上，避免使自己的应用遭受代码注入攻击。看一下它的源码，只有1个构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line">import java.io.File;</span><br><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, new File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，PathClassLoader和DexClassLoader除了构造方法传参不同，其它的逻辑都是一样的。要注意的是DexClassLoader构造方法第2个参数指的是dex优化缓存路径，这个值是不能为空的。而PathClassLoader对应的dex优化缓存路径为null是因为Android系统自己决定了缓存路径。</p><p>先提前漏一嘴，Android中具体负责类加载的并不是哪个ClassLoader，而是通过DexFile的defineClassNative()方法来加载的。</p><p><strong>接下来我们看一下BaseDexClassLoader这个类：</strong></p><p>BaseDexClassLoader的构造方法有四个参数：</p><ul><li>dexPath，指的是在Androdi包含类和资源的jar/apk类型的文件集合，指的是包含dex文件。多个文件用“：”分隔开，用代码就是<code>File.pathSeparator</code>。</li><li>optimizedDirectory，指的是odex优化文件存放的路径，可以为null，那么就采用默认的系统路径。</li><li>libraryPath，指的是native库文件存放目录，也是以“：”分隔。</li><li>parent，parent类加载器</li></ul><p>可以看到，在BaseDexClassLoader类中初始化了DexPathList这个类的对象。这个类的作用是存放指明包含dex文件、native库和优化目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.BaseDexClassLoader</span><br><span class="line">    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>dalvik.system.DexPathList</code>封装了dex路径，是一个final类，而且访问权限是包权限，也就是说外界不可继承，也不可访问这个类。<br>BaseDexClassLoader在其构造方法中初始化了DexPathList对象，我们来看一下DexPathList的源码，我们需要重点关注一下它的成员变量dexElements，它是一个Element[]数组，是包含dex的文件集合。Element是DexPathList的一个静态内部类。DexPathList的构造方法有4个参数。从其构造方法中也可以看到传递过来的classLoade对象和dexPath不能为null，否则就抛出空指针异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line"></span><br><span class="line">private final Element[] dexElements;</span><br><span class="line"></span><br><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">        String libraryPath, File optimizedDirectory) &#123;</span><br><span class="line">    if (definingContext == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;definingContext == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexPath == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;dexPath == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (optimizedDirectory != null) &#123;</span><br><span class="line">        if (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory doesn&apos;t exist: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果文件不是可读可写的也会抛出异常</span><br><span class="line">        if (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory not readable/writable: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.definingContext = definingContext;</span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">    // 通过makeDexElements方法来获取Element数组</span><br><span class="line">    // splitDexPath(dexPath)方法是用来把我们之前按照“：”分隔的路径转为File集合。</span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions);</span><br><span class="line">    if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">        this.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeDexElements方法的作用是获取一个包含dex文件的元素集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    // 遍历打开所有的文件并且加载直接或者间接包含dex的文件。</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        File zip = null;</span><br><span class="line">        DexFile dex = null;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            // We support directories for looking up resources.</span><br><span class="line">            // This is only useful for running libcore tests.</span><br><span class="line">            // 可以发现它是支持传递目录的，但是说只测试libCore的时候有用</span><br><span class="line">            elements.add(new Element(file, true, null, null));</span><br><span class="line">        &#125; else if (file.isFile())&#123;</span><br><span class="line">            // 如果文件名后缀是.dex，说明是原始dex文件</span><br><span class="line">            if (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                // Raw dex file (not inside a zip/jar).</span><br><span class="line">                try &#123;</span><br><span class="line">                    //调用loadDexFile()方法，加载dex文件，获得DexFile对象</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    System.logE(&quot;Unable to load dex file: &quot; + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // dex文件包含在其它文件中</span><br><span class="line">                zip = file;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 同样调用loadDexFile()方法</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; catch (IOException suppressed) &#123;</span><br><span class="line">                    // 和加载纯dex文件不同的是，会把异常添加到异常集合中</span><br><span class="line">                    /*</span><br><span class="line">                     * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if</span><br><span class="line">                     * the zip file turns out to be resource-only (that is, no classes.dex file</span><br><span class="line">                     * in it).</span><br><span class="line">                     * Let dex == null and hang on to the exception to add to the tea-leaves for</span><br><span class="line">                     * when findClass returns null.</span><br><span class="line">                     */</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果zip或者dex二者一直不为null，就把元素添加进来</span><br><span class="line">        // 注意，现在添加进来的zip存在不为null也不包含dex文件的可能。</span><br><span class="line">        if ((zip != null) || (dex != null)) &#123;</span><br><span class="line">            elements.add(new Element(file, false, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return elements.toArray(new Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码也可以看到，加载一个dex文件调用的是loadDexFile()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    // 如果缓存存放目录为null就直接创建一个DexFile对象返回</span><br><span class="line">    if (optimizedDirectory == null) &#123;</span><br><span class="line">        return new DexFile(file);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 根据缓存存放目录和文件名得到一个优化后的缓存文件路径</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        // 调用DexFile的loadDex()方法来获取DexFile对象。</span><br><span class="line">        return DexFile.loadDex(file.getPath(), optimizedPath, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexFile的loadDex()方法如下，内部也做了一些调用。抛开这些细节来讲，它的作用就是加载DexFile文件，而且会把优化后的dex文件缓存到对应目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexFile </span><br><span class="line">static public DexFile loadDex(String sourcePathName, String outputPathName,</span><br><span class="line">    int flags) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * TODO: we may want to cache previously-opened DexFile objects.</span><br><span class="line">     * The cache would be synchronized with close().  This would help</span><br><span class="line">     * us avoid mapping the same DEX more than once when an app</span><br><span class="line">     * decided to open it multiple times.  In practice this may not</span><br><span class="line">     * be a real issue.</span><br><span class="line">     */</span><br><span class="line">    //loadDex方法内部就是调用了DexFile的一个构造方法</span><br><span class="line">    return new DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private DexFile(String sourceName, String outputName, int flags) throws IOException &#123;</span><br><span class="line">    if (outputName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String parent = new File(outputName).getParent();</span><br><span class="line">            if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent</span><br><span class="line">                        + &quot; is not owned by the current user. Shared storage cannot protect&quot;</span><br><span class="line">                        + &quot; your application from code injection attacks.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ErrnoException ignored) &#123;</span><br><span class="line">            // assume we&apos;ll fail with a more contextual error later</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">    mFileName = sourceName;</span><br><span class="line">    guard.open(&quot;close&quot;);</span><br><span class="line">    //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static long openDexFile(String sourceName, String outputName, int flags) throws IOException &#123;</span><br><span class="line">    // Use absolute paths to enable the use of relative paths when testing on host.</span><br><span class="line">    return openDexFileNative(new File(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == null) ? null : new File(outputName).getAbsolutePath(),</span><br><span class="line">                             flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native long openDexFileNative(String sourceName, String outputName, int flags);</span><br></pre></td></tr></table></figure><p>分析到这，我们可以小结一下：在BaseDexClassLoader对象构造方法内，创建了PathDexList对象。而在PathDexList构造方法内部，通过调用一系列方法，把直接包含或者间接包含dex的文件解压缩并缓存优化后的dex文件，通过PathDexList的成员变量 <code>Element[] dexElements</code>来指向这个文件。</p><p>到此我们就分析完了BaseDexClassLoader的构造方法。</p><p>我们在之前讲Java类加载器的时候已经说了，类加载是按需加载，也就是说当明确需要使用class文件的时候才会加载。我们来看一下在Android中ClassLoader的loadeClass()方法。<br>与在Java中的loadClass()方法主要流程是类似的，不过因为Android中BootClassLoader是用Java代码写的，所以可以直接当作系统类加载器的parent类加载器。在Android中如果parent类加载器找不到类，最终还是会调用ClassLoader对象自己的findClass()方法。这个与在Java中逻辑是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    if (clazz == null) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = parent.loadClass(className, false);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clazz == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以去看一下BaseDexClassLoader类的findClass()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.BaseDexClassLoader</span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();</span><br><span class="line">    // 调用DexPathList对象的findClass()方法</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    if (c == null) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</span><br><span class="line">        for (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上BaseDexClassLoader调用的是其成员变量<code>DexPathList pathList</code>的findClass()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    // 遍历Element</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        // 获取DexFile，然后调用DexFile对象的loadClassBinaryName()方法来加载Class文件。</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">       </span><br><span class="line">        if (dex != null) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dexElementsSuppressedExceptions != null) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们也可以看到，实际上DexPathList最终还是遍历其自身的Element[]数组，获取DexFile对象来加载Class文件。我们之前讲DexPathList构造方法内是调用其makeDexElements()方法来创建Element[]数组的，而且也提到了如果zip文件或者dex文件二者之一不为null，就把元素添加进来，而添加进来的zip存在不为null也不包含dex文件的可能。从上面的代码中也可以看到，获取Class的时候跟这个zip文件没什么关系，调用的是dex文件对应的DexFile的方法来获取Class。</p><p>数组的遍历是有序的，假设有两个dex文件存放了二进制名称相同的Class，类加载器肯定就会加载在放在数组前面的dex文件中的Class。现在很多热修复技术就是把修复的dex文件放在DexPathList中Element[]数组的前面，这样就实现了修复后的Class抢先加载了，达到了修改bug的目的。</p><p>Android加载一个Class是调用DexFile的defineClass()方法。而不是调用ClassLoader的defineClass()方法。这一点与Java不同，毕竟Android虚拟机加载的dex文件，而不是class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># dalvik.system.DexFile</span><br><span class="line">public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    return defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class defineClass(String name, ClassLoader loader, long cookie,</span><br><span class="line">                                 List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    Class result = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = defineClassNative(name, loader, cookie);</span><br><span class="line">    &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">        if (suppressed != null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        if (suppressed != null) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android中ClassLoader的defineClass()方法已经不能用了。可以看到它的方法体里直接抛出异常了，而且在BaseDexClassLoader中也没有重写这个方法，毕竟BaseDexClassLoader加载类的逻辑已经变了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># java.lang.ClassLoader</span><br><span class="line">protected final Class&lt;?&gt; defineClass(String className, byte[] classRep, int offset, int length,</span><br><span class="line">        ProtectionDomain protectionDomain) throws java.lang.ClassFormatError &#123;</span><br><span class="line">    throw new UnsupportedOperationException(&quot;can&apos;t load this type of class file&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，分析到此我们可以小结一下：<br>Android中加载一个类是遍历PathDexList的Element[]数组，这个Element包含了DexFile，调用DexFile的方法来获取Class文件，如果获取到了Class，就跳出循环。否则就在下一个Element中寻找Class。</p><h1 id="使用DexClassLoader加载类"><a href="#使用DexClassLoader加载类" class="headerlink" title="使用DexClassLoader加载类"></a>使用DexClassLoader加载类</h1><p>写一个Test类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;this is Test Class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>javac</code>命令生成class文件，然后通过Android中的<code>dex</code>工具生成dex文件。<br>为了方便测试，我把生成的dex文件放在了assets文件中。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-9a448c7910a74af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex文件.png"></p><p>测试的时候，先把assets中的classes.dex文件复制到本地一个目录。<br>主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 1. 先把assets中的classes.dex文件复制到一个本地目录中</span><br><span class="line">File originDex = null;</span><br><span class="line">try &#123;</span><br><span class="line">    InputStream open = getAssets().open(&quot;classes.dex&quot;);</span><br><span class="line">    File dexOutputDir = getCacheDir();</span><br><span class="line">    originDex = new File(dexOutputDir, &quot;classes.dex&quot;);</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(originDex);</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len = open.read(bytes)) != -1) &#123;</span><br><span class="line">        fileOutputStream.write(bytes, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    open.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 创建DexClassLoader加载dex文件中的类</span><br><span class="line">if (originDex != null) &#123;</span><br><span class="line">    File dexOptimizeDir = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);</span><br><span class="line">    String dexOutputPath = dexOptimizeDir.getAbsolutePath();</span><br><span class="line">    DexClassLoader dexClassLoader = new DexClassLoader(originDex.getAbsolutePath(), dexOutputPath, null, getClassLoader());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = dexClassLoader.loadClass(&quot;com.sososeen09.Test&quot;);</span><br><span class="line">        System.out.println(&quot;loaded class: &quot; + clazz);</span><br><span class="line">        System.out.println(&quot;class loader: &quot; + clazz.getClassLoader());</span><br><span class="line">        System.out.println(&quot;class loader parent: &quot; + clazz.getClassLoader().getParent());</span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Object o = constructor.newInstance();</span><br><span class="line">        Method print = clazz.getDeclaredMethod(&quot;print&quot;);</span><br><span class="line">        print.setAccessible(true);</span><br><span class="line">        print.invoke(o);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/System.out: loaded class: class com.sososeen09.Test</span><br><span class="line">I/System.out: class loader: dalvik.system.DexClassLoader[DexPathList[[dex file &quot;/data/data/com.sososeen09.android_basic_knowledge/cache/classes.dex&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">I/System.out: class loader parent: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/base.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_dependencies_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_0_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_1_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_2_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_3_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_4_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_5_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_6_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_7_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_8_apk.apk&quot;, zip file &quot;/data/app/com.sososeen09.android_basic_knowledge-2/split_lib_slice_9_apk.apk&quot;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]</span><br><span class="line">I/System.out: this is Test Class</span><br></pre></td></tr></table></figure><p>可以看到我们通过DexClassLoader对象正确的加载到了我们自己的dex文件中的类。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android中的类加载器是BootClassLoader、PathClassLoader、DexClassLoader，其中BootClassLoader是虚拟机加载系统类需要用到的，PathClassLoader是App加载自身dex文件中的类用到的，DexClassLoader可以加载直接或间接包含dex文件的文件，如APK等。</p><p>PathClassLoader和DexClassLoader都继承自BaseDexClassLoader，它的一个DexPathList类型的成员变量pathList很重要。DexPathList中有一个Element类型的数组dexElements，这个数组中存放了包含dex文件（对应的是DexFile）的元素。BaseDexClassLoader加载一个类，最后调用的是DexFile的方法进行加载的。</p><p>无论是热修复还是插件化技术中都利用了类加载机制，所以深入理解Android中的类加载机制对于理解这些技术的原理很有帮助。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://liuwangshu.cn/application/classloader/2-android-classloader.html" target="_blank" rel="noopener">Android解析ClassLoader（二）Android中的ClassLoader</a></li><li><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></li><li><a href="http://www.jianshu.com/p/a620e368389a" target="_blank" rel="noopener">Android动态加载之ClassLoader详解</a></li><li><a href="https://segmentfault.com/a/1190000004062952" target="_blank" rel="noopener">Android动态加载入门 简单加载模式</a></li><li><a href="http://blog.csdn.net/yulong0809/article/details/78426280" target="_blank" rel="noopener">唯一插件化Replugin源码及原理深度剖析–唯一Hook点原理</a></li><li><a href="http://www.jianshu.com/p/57fc356b9093" target="_blank" rel="noopener">Android插件化框架系列之类加载器</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制系列1——深入理解Java中的类加载器</title>
      <link href="/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2017/12/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h1><p>Java类加载器是Java运行时环境（Java Runtime Environment）的一部分，它负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。</p><p>Java中的类加载器是<code>java.lang.ClassLoader</code>，它是一个抽象类。给定一个类名，ClassLoader就负责把这个类从特定的文件系统中加载到虚拟机中。</p><p>Class类有一个方法<code>getClassLoader()</code>，每一个类的Class对象都可以调用这个方法来获取把这个类加载到虚拟机中的ClassLoader。</p><p>对于数组来说，它们不是由ClassLoader来创建，而是由Java运行时创建，数组的ClassLoader就是加载该数组元素类的ClassLoader。如果元素类型是基本类型，那么数组就没有ClassLoader。</p><p>ClassLoader采用的是代理模式来加载类，每一个ClassLoader实例都有一个父ClassLoader（并不是继承关系），当一个类加载器需要加载一个类的时候，它会首先传递这个类的信息到parent 类加载器，请求parent来加载，然后依次传递，直到该类被成功加载或者失败。如果失败了，那么就由最开始的那个类加载器来进行加载。在Java虚拟机中有一个内置的类加载器是<code>bootstrap class loader</code>，它是没有parent的，但是可以作为所有ClassLoader实例的parent。这种加载方式也叫作双亲委派机制或者父委托机制。</p><p>通常来讲，类加载器都是加载本地的Class文件，但是它也可以加载其它来源的文件，比如从网络下载下来的。可以通过继承<code>java.lang.ClassLoader</code>类的方式实现自己的类加载器，以满足一些特殊的需求而不需要完全了解Java虚拟机的类加载的细节。ClassLoader的一个方法<code>defineClass</code>可以把一个字节数组转为Class实例。然后可以根据<code>Class.newInstance()</code>方法来创建一个对象。被ClassLoader创建的类的方法或者构造方法可能还会引用其它的类，为了确定引用的类，虚拟机会调用最开始加载引用类的ClassLoader的<code>loadClass</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br></pre></td></tr></table></figure><p>例如，想要自定义一个NetworkClassLoader，来加载从网络传来的Class类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = new NetworkClassLoader(host, port);</span><br><span class="line">Object main = loader.loadClass(&quot;Main&quot;, true).newInstance();</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><p>NetworkClassLoader必须重写<code>findClass</code>方法，，然后定义一个方法来返回Class类的字节数组。当下载完毕，需要调用defineClass方法，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">    String host;</span><br><span class="line">    int port;</span><br><span class="line"></span><br><span class="line">    public Class findClass(String name) &#123;</span><br><span class="line">        byte[] b = loadClassData(name);</span><br><span class="line">        return defineClass(name, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        // load the class data from the connection</span><br><span class="line">          . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JVM中的ClassLoader"><a href="#JVM中的ClassLoader" class="headerlink" title="JVM中的ClassLoader"></a>JVM中的ClassLoader</h1><p>JVM中有3个默认的类加载器：</p><ul><li>引导（Bootstrap）类加载器。用C/C++写的，在Java代码中无法获取到。主要是加载存储在<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录下的核心Java库，对应的加载路径是<code>sun.boot.class.path</code>。</li><li>扩展（Extensions）类加载器.用来加载<code>&lt;JAVA_HOME&gt;/jre/lib/e。t</code>目录下或者对应的加载路径<code>java.ext.dirs</code>中指明的Java扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。该类由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li><li>Apps类加载器（也称系统类加载器）。根据 Java应用程序的类路径（java.class.path或CLASSPATH环境变量）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。该类由<code>sun.misc.Launcher$AppClassLoader</code>实现，它的parent类加载器是ExtClassLoader。</li></ul><p>下面通过一个示例来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package classLoader;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">ClassLoaderTest clt=new ClassLoaderTest();</span><br><span class="line">ClassLoader cl=clt.getClass().getClassLoader();</span><br><span class="line">System.out.println(cl);</span><br><span class="line">System.out.println(cl.getParent());</span><br><span class="line">System.out.println(cl.getParent().getParent());</span><br><span class="line">System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@7852e922</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/resources.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/sunrsasign.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jsse.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jce.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/charsets.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/jfr.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/classes</span><br><span class="line"></span><br><span class="line">/Users/jason/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/ext:</span><br><span class="line">/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line">/works/EclipseWorkSpace/classLoader/bin</span><br></pre></td></tr></table></figure><p><code>java.lang.ClassLoader</code>继承关系如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-7adfb842ce5f4ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java中ClassLoader继承关系.png"></p><p>其中AppClassLoader和ExtClassLoader都是在Laucher中的内部类。而这个Laucher是JVM的入口。</p><p><strong>注意: 并不是说子加载器继承自父加载器</strong></p><h1 id="ClassLoader源码分析"><a href="#ClassLoader源码分析" class="headerlink" title="ClassLoader源码分析"></a>ClassLoader源码分析</h1><p>前面已经讲了，类的加载使用的是双亲委派机制。那我们启动一个Java应用程序，它的类加载顺序是从AppClassLoader委托ExtClassLoader，如果ExtClassLoader也找不到就会去委托Bootstrap类加载器加载。如果父加载器没有找到的话，再从子加载器中加载，加载到的类会被缓存起来，如果最终都没有找到这个类，就会报一个异常<code>ClassNotFoundException</code>。</p><p>我们先看一下ClassLoader的构造方法，它有3个构造方法，但是其中有一个私有的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//最终调用的还是这个私有的方法</span><br><span class="line">private ClassLoader(Void unused, ClassLoader parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//有参构造，传递parent类加载器</span><br><span class="line">protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">   this(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 无参构造，默认采用getSystemClassLoader()方法获取的ClassLoader作为parent类加载器</span><br><span class="line">protected ClassLoader() &#123;</span><br><span class="line">    this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来看getSystemClassLoader()这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    // 初始化系统类加载器</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    if (scl == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 做一些安全方面的校验</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    if (sm != null) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initSystemClassLoader()方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl != null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        //获取Launcher对象</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l != null) &#123;</span><br><span class="line">            Throwable oops = null;</span><br><span class="line">            //调用Launcher对象的getClassLoader()方法，这个获取的就是AppClassLoader，详细内容可以看下面对Launcher的分析</span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops != null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就ClassLoader加载一个类的过程来进行一下分析。ClassLoader加载一个类，调用的方法是<code>loadClass()方法</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//通常外界是调用ClassLoader的这个loadClass方法</span><br><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ClassLoader的默认加载方式，如果需要自定义ClassLoader最好不要重写这个方法。</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    // 同步代码块</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // findLoadedClass是一个native方法，如果已经加载过的类是会被缓存起来的，直接从缓存获取即可</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">        // c为null，说明没有缓存，就需要初次加载</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    // 如果parent不为null就委托parent去加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 如果parent为null就委托bootstrap class loader去加载</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // 如果非空的父加载器找不到类会抛出异常，在这里try-catch住了</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // 如果父加载器和bootstrap加载器都没有找到，就会调用ClassLoader实例自身的findClass()方法。</span><br><span class="line">                // 其方法体是抛出一个ClassNotFoundException异常，</span><br><span class="line">                // 所以继承ClassLoader的子类加载器需要重写这个findClass()方法</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            // 使Classloader链接指定的类，如果这个类已经被链接过了，那么这个方法只做一个简单的返回。</span><br><span class="line">            // 否则，这个类将被按照 Java™规范中的Execution描述进行链接</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是第一个参数，name表示的是二进制名称(Binary name)，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.lang.String&quot;</span><br><span class="line">&quot;javax.swing.JSpinner$DefaultEditor&quot;</span><br><span class="line">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;</span><br><span class="line">&quot;java.net.URLClassLoader$3$1&quot;</span><br></pre></td></tr></table></figure><p><strong>需要指出：类加载过程是同步的</strong></p><p>简单总结一下类加载器的工作过程：</p><ol><li>如果当前加载的类已经加载过，直接从缓存获取。</li><li>之前没有加载过，如果该ClassLoader对象的parent不为null就委托父加载器加载，父加载器会重新开始走第1步。如果parent为null，那么就采用根加载器bootstrap class loader进行加载。</li><li>如果之前还是没有成功加载类，那么就会调用当前ClassLoader的findClass()方法去加载。</li></ol><p><strong>类加载器采用双亲委派机制的好处：</strong></p><ol><li>加载的类会被缓存起来，下次加载就快了。</li><li>安全，比如我们自定义一个与系统String包名类型一致的类，然后想要把这个String类加载进来干点坏事的话实际上是做不到的，由于父委托机制，真正的String类会被bootstrap class loader 加载（String类是存放在bootstrap class loader 负责加载的区域），就不会再调用我们这个假的String类。实际上，如果你自定义了一个类加载器并且重写了loadClass的逻辑，最终还是不能加载假的String类，因为ClassLoader有一个preDefineClass方法，该方法会检测类的包名，如果是’java’开头就会抛出一个SecurityException异常。</li></ol><p>那么AppClassLoader和ExtClassLoader是什么时候初始化的呢？下面我们再去看一下Launcher的部分源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># sun.misc.Launcher</span><br><span class="line">//构造方法</span><br><span class="line">public Launcher() &#123;</span><br><span class="line">    ClassLoader extcl;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建ExtClassLoader对象</span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create extension class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建AppClassLoader对象loader，这个loader就是上面讲到的，Launcher的getClassLoader()方法返回的对象。 </span><br><span class="line">    //AppClassLoader.getAppClassLoader()方法的参数为extcl，实际上就是把ExtClassLoader对象当作其父加载器</span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create application class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置上下文的类加载器，也就是AppClassLoader对象。</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    // Finally, install a security manager if requested</span><br><span class="line">    String s = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        SecurityManager sm = null;</span><br><span class="line">        if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;</span><br><span class="line">            sm = new java.lang.SecurityManager();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(</span><br><span class="line">                &quot;Could not create SecurityManager: &quot; + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ExtClassLoader和AppClassLoader的源码我们这里就不做多余的介绍了，感兴趣的可以去看一下<a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java?av=f" target="_blank" rel="noopener">Launcher</a>这个类，ExtClassLoader和AppClassLoader都是其静态内部类。</p><h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>我们完全可以通过自定义类加载器来加载我们想要加载的类，这个类可能来源于网络，也可能来源于文件系统。<br>从前面的分析我们知道，加载一个类的过程调用的是ClassLoader的loadClass()方法。自定义类加载器通常不要重写loadClass()方法的逻辑。在这个方法内部，如果所有的父加载器都没有成功加载，就会调用ClassLoader对象自身的findClass()方法，自定义类加载器可以实现这个findClass()方法即可。</p><p>还有一个关键的方法就是调用ClassLoader对象的defineClass()方法，这样就可以创建一个Class对象了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String dirPath;</span><br><span class="line"></span><br><span class="line">    public CustomClassLoader(String dirPath) &#123;</span><br><span class="line">        this.dirPath = dirPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        //注意这个name一定要是二进制名称，如&apos;java.lang.String&apos;</span><br><span class="line">        //根据类的二进制名称,获得该class文件的字节码数组</span><br><span class="line">        byte[] classData = getClassDataBytes(name);</span><br><span class="line">        if (classData == null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用define()方法将class的字节码数组转换成Class类的实例</span><br><span class="line">        clazz = defineClass(name, classData, 0, classData.length);</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassDataBytes(String name) &#123;</span><br><span class="line">        FileInputStream is = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = classNameToPath(name);</span><br><span class="line">            is = new FileInputStream(path);</span><br><span class="line">            byte[] buff = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            while ((len = is.read(buff)) != -1) &#123;</span><br><span class="line">                baos.write(buff, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String classNameToPath(String name) &#123;</span><br><span class="line">        return dirPath + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类加载器已经写好了，下面我们来演示一下如何加载一个类，首先我们编写一个java类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen09;</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    public Test() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;this is Test Class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>javac</code>命令把java文件编译为对应的class文件。这个Test.class文件的二进制名称就是<code>com.sososeen09.Test</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String srcPath = &quot;/test/bin&quot;;</span><br><span class="line">        CustomClassLoader customClassLoader = new CustomClassLoader(srcPath);</span><br><span class="line">        String classname = &quot;com.sososeen09.Test&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = customClassLoader.loadClass(classname);</span><br><span class="line">            System.out.println(&quot;loaded class: &quot; + clazz);</span><br><span class="line">            System.out.println(&quot;class loader: &quot; + clazz.getClassLoader());</span><br><span class="line">            System.out.println(&quot;class loader parent: &quot; + clazz.getClassLoader().getParent());</span><br><span class="line">            Constructor constructor = clazz.getConstructor();</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">            Object o = constructor.newInstance();</span><br><span class="line">            Method print = clazz.getDeclaredMethod(&quot;print&quot;);</span><br><span class="line">            print.setAccessible(true);</span><br><span class="line">            print.invoke(o);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行一下可以查看打印结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loaded class: class com.sososeen09.Test</span><br><span class="line">class loader: com.sososeen09.javamodule.classloaders.CustomClassLoader@14ae5a5</span><br><span class="line">class loader parent: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">this is Test Class</span><br></pre></td></tr></table></figure><p>可以看到我们自定义的类加载器已经成功的把一个文件系统中的class加载了。</p><p><strong>需要注意：我们是把二进制文件前面的包名转为路径了，所以我们传递的srcPath是<code>&quot;/test/bin&quot;</code>，那么实际上class文件存放路径应该是<code>&quot;/test/bin/com/sososeen09/&quot;</code></strong>。</p><h1 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h1><p>在Java中，类的加载时按需加载，也就是需要的时候才会把class文件加载到内存中。可以分为隐式加载和显示加载。</p><ul><li>隐式加载：由当new一个Java对象，或者调用类的静态方法或者使用静态成员变量的时候，会加载当前的Class。</li><li>显示加载，显示的调用Class.forName()方法，或者调用ClassLoader的loadClass()方法。</li></ul><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="http://liuwangshu.cn/application/classloader/1-java-classloader-.html" target="_blank" rel="noopener">Android解析ClassLoader（一）Java中的ClassLoader</a></li><li><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></li><li><a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">深入分析Java ClassLoader原理</a></li><li><a href="http://www.hollischuang.com/archives/199" target="_blank" rel="noopener">深度分析Java的ClassLoader机制（源码级别）</a></li><li><a href="http://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">深入理解Java类加载器(ClassLoader)</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习10——自定义Gradle插件</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A010%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89Gradle%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A010%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89Gradle%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>Gradle插件分为两类：</p><ul><li>脚本插件，是一个普通的Gradle构建脚本，它可以被导入到其它的构建脚本中。</li><li>对象插件，需要实现<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Plugin.html" target="_blank" rel="noopener">org.gradle.api.Plugin</a>接口。</li></ul><h1 id="使用脚本插件"><a href="#使用脚本插件" class="headerlink" title="使用脚本插件"></a>使用脚本插件</h1><p>假设我们有一个脚本名为 sayhello.gradle ，它里面有一个task：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task sayHello &lt;&lt; &#123;</span><br><span class="line">println &apos;hello world&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在build.gradle 中依赖这个外部脚本，调用<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a>的apply方法，apply方法调用时传入from属性，它的值可以是任何类型的URL，比如HTTP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &apos;sayhello.gradle&apos;</span><br></pre></td></tr></table></figure><p>此时我们运行<code>gradle sayHello</code> 命令，可以看到sayHello 这个task执行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sayHello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>通过apply from的方式引入脚本插件，就好像那个脚本插件中的内容是写在当前的build.gradle中一样。它是使用比较简单，这里就不多做介绍了。</p><h1 id="对象插件"><a href="#对象插件" class="headerlink" title="对象插件"></a>对象插件</h1><p>我们之前讲了自定义的task，它的实现逻辑是一种可维护、可测试的解决方案。通过打包成jar文件，task可以在独立的项目中被重用。然而，该方式仍有一些限制。<br>优点：</p><ul><li>定制逻辑在类中是自包含的，并且可以通过增强型task配置</li><li>通过将task属性用注解标志可以支持声明式增量构建</li><li>自定义的task可以测试</li></ul><p>缺点：</p><ul><li>自定义的task仅仅暴露独立的工作单元。所提供的额外的公式化代码、约定和生命周期的整合并不是很直接</li><li>自定义的task仅仅能通过增强型task来配置。通过自定义的DSL，缺乏有表达性的扩展机制</li><li>其他插件的功能不容易使用或扩展</li></ul><p>而使用对象插件的方式，可以给你最大的灵活性去封装高复杂度的逻辑，并且提供一种强大的扩展机制可以在构建脚本中定制它的行为。比如编译Java代码，我们会通过一句话来引入Java插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin :&apos;java&apos;</span><br></pre></td></tr></table></figure><p>然后我们还可以配置很多属性来控制编译逻辑。这个Java插件就是一个对象插件。</p><h1 id="对象插件的实现方式"><a href="#对象插件的实现方式" class="headerlink" title="对象插件的实现方式"></a>对象插件的实现方式</h1><p>对于实现一个对象插件，有4个基本元素是非常重要的。</p><ol><li><p>在放置插件实现的位置方面Gradle给你完全的灵活性。代码可以放在构建脚本中或者buildSrc目录下，也可以作为一个独立的工程被开发并且以jar文件方式发布。</p></li><li><p>每个插件都需要提供一个实现类，它代表着插件的入口点。插件可以用任何JVM语言编写并编译成字节码。</p></li><li><p>应用到项目中的插件可以通过暴露出来的扩展对象进行定制。如果用户想要在构建脚本中覆盖插件的默认配置时，这一点特别有用。</p></li><li><p>插件描述符是一个属性文件，它包含了关于插件的元信息。通常，它包含有插件的简短名字和插件实现类的映射。</p></li></ol><h1 id="编写对象插件"><a href="#编写对象插件" class="headerlink" title="编写对象插件"></a>编写对象插件</h1><p>编写一个插件最低的要求是提供<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Plugin.html" target="_blank" rel="noopener">org.gradle.api.Plugin<t></t></a>接口的一个实现类。该接口仅仅定义了一个简单的方法：apply(T target)。</p><p>现在我们来演示自定义一个插件，这个插件的作用是提供一个task来打印用户凭证。<br>我们前面已经提到，自定义对象插件和自定义task方式类似，代码可以放在构建脚本中或者buildSrc目录下，也可以作为一个独立的工程被开发并且以JAR文件方式发布，下面我们根据这三种方式来分别演示如何自定义和使用插件。</p><h2 id="放在构建脚本中"><a href="#放在构建脚本中" class="headerlink" title="放在构建脚本中"></a>放在构建脚本中</h2><p>在build.gradle中，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:CredentialPlugin</span><br><span class="line"></span><br><span class="line">userCredential&#123;</span><br><span class="line">username=&apos;admin&apos;</span><br><span class="line">password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CredentialPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">void apply(Project project)&#123;</span><br><span class="line">project.extensions.create(&apos;userCredential&apos;,CredentialExtension)</span><br><span class="line">project.tasks.create(&apos;printUserCredential&apos;) &lt;&lt; &#123;</span><br><span class="line"> println &quot;username is: &quot; + project.userCredential.username</span><br><span class="line"> println &quot;password is: &quot; + project.userCredential.password</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展模型</span><br><span class="line">class CredentialExtension &#123;</span><br><span class="line">String username</span><br><span class="line">String password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle将语言结构化模型作为扩展，扩展可以被添加到许多Gradle对象中，如果一个类实现了<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/plugins/ExtensionAware.html" target="_blank" rel="noopener">org.gradle.api.plugins.ExtensionAware</a>接口，比如Project或者Task，就认为它是扩展可知的。每个扩展都是一个数据模型，它是扩展的基础。这个模型可以是一个POJO或者Groovy Bean。<br>在上面的代码中，userCredential闭包中的内容，可以从构建脚本中给task提供所需要的属性值，这个userCredential就是我们暴露的一个DSL。<br>ExtensionAware对象有一个方法getExtensions()，该方法返回一个<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/plugins/ExtensionContainer.html" target="_blank" rel="noopener">ExtensionContainer</a>对象，ExtensionContainer对象可以通过create()方法来注册我们的扩展，也就是把我们配置的DSL和具体的类关联起来。在本例中就是把userCredential这个闭包和CredentialExtension这个类关联起来，这就是插件的扩展机制。</p><blockquote><p>扩展对象vs额外属性  被用来扩展一个对象的DSL的扩展是扩展可知的，一个已注册的扩展模型会暴露一些属性和方法，用来给构建脚本建立新的构建语言结构，这些属性名和方法在创建的时候已经定好。扩展模型的典型用例是插件。额外属性，是一些通过ext命名空间创建的简单变量，它们一般提供给用户空间也就是构建脚本使用，额外属性的属性名是可以任意指定的。请尽量避免在插件实现中使用额外属性。</p></blockquote><h2 id="放在buildSrc目录下"><a href="#放在buildSrc目录下" class="headerlink" title="放在buildSrc目录下"></a>放在buildSrc目录下</h2><p>与自定义task一样，Groovy代码放在buildSrc/src/main/groovy 目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen.credential</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">class CredentialPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">void apply(Project project)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.sososeen.credential</span><br><span class="line">class CredentialExtension &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在与buildSrc同级的目录下，创建build.gradle脚本，引入这个plugin：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:com.sososeen.credential.CredentialPlugin</span><br><span class="line">userCredential&#123;</span><br><span class="line">username=&apos;admin&apos;</span><br><span class="line">password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>gradle printUserCredential</code> 命令，可以看到打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:printUserCredential</span><br><span class="line">username is: admin</span><br><span class="line">password is: 000000</span><br></pre></td></tr></table></figure><p>可以看到，我们引入这个插件的时候是把它的包名带类名写上了，这显得太长了，不好写。我们可以给这个插件一个有意义且精简的名字。在src/main/resources/META-INF/gradle-plugins目录下，我们可以创建一个属性文件来配置。比如创建一个credentials.properties，它就是一个插件描述符，暴露了插件名字是credentials。在这个文件中，将该插件类的全局类名赋值给键implemention-class，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class = com.sososeen.credential.CredentialPlugin</span><br></pre></td></tr></table></figure><p>然后应用插件就可以这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin : &apos;credentials&apos;</span><br></pre></td></tr></table></figure><p>执行  <code>gradle printUserCredential</code> 命令，可以看到打印结果与之前一样。</p><p>目录结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-0a93dc30b128b3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buildSrc目录结构"></p><blockquote><p>有一点需要说明，Gradle可以用驼峰式的缩写在命令行上运行任务。但要保证缩写是唯一的。比如我们执行<code>gradle printUserCredential</code>，实际上可以缩写为<code>gradle pUC</code>，这对于任务名称比较长的时候特别有用，感兴趣的可以试一下。</p></blockquote><h2 id="以jar文件形式提供插件"><a href="#以jar文件形式提供插件" class="headerlink" title="以jar文件形式提供插件"></a>以jar文件形式提供插件</h2><p>这个步骤与自定义task打包为jar文件一样，新建一个项目，把buildSrc目录下的文件复制过来，同时，在该项目下创建一个build.gradle文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos; //应用这个插件来编译Groovy代码</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line">version = &apos;1.0&apos;</span><br><span class="line">group = &apos;com.sososeen09&apos;</span><br><span class="line">archivesBaseName = &apos;credential&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // 使用Gradle中的API需要这个</span><br><span class="line">    compile gradleApi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: &quot;file:../lib&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行gradle uploadArchives命令后就可以看到，在与当前项目同级的lib文件目录中生成了我们期望的jar文件。</p><p>我们再新建一个工程，这个工程中有一个脚本文件build.gradle:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply plugin : &apos;credentials&apos;</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;file:../lib&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.sososeen09:credential:1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userCredential&#123;</span><br><span class="line">    username=&apos;admin&apos;</span><br><span class="line">    password=&apos;000000&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行  <code>gradle printUserCredential</code> 命令，可以看到打印结果与之前一样。</p><p>目录结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2083810-e7b763635d2f8fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以jar包形式提供依赖"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Gradle提供了一个丰富的插件生态系统来重用哪些开箱即用的标准插件和由社区提供的第三方插件。有两种类型的插件：脚本插件和对象插件。</p><p>脚本插件是一种普通的Gradle构建脚本，它可以完全访问Gradle的API。编写一个脚本插件是非常简单的，降低了分享代码的难度。可以通过URL被另一个项目使用。</p><p>对象插件通常包含更为复杂的逻辑，需要适当的包和类。每个对象插件的入口点都是Pulgin接口，它提供了一种直接的方式来访问Gradle的Project模型。通过将对象插件添加到构建脚本的classpath下，许多对象插件都可以在多个独立的项目中使用，可以被打包成jar文件，发布到仓库中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习9——多项目构建</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A09%E2%80%94%E2%80%94%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A09%E2%80%94%E2%80%94%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>为了提高可维护性和防止紧密耦合，可以基于特定的功能和逻辑将代码写在不同的模块中。模块通常具有层次结构而且可以定义为相互依赖。Gradle对构建多模块项目提供了强大的支持，Gradle中的每一模块都是一个项目，我们称之为多项目构建。</p><blockquote><p>注意：在Android Studio中，一个模块和一个项目是有区别的。一个项目包含多个模块module。而Android Studio中的每一个module对应的是Gradle多项目构建中的一个项目</p></blockquote><p>在多项目构建中，settings文件声明了所需的配置来实例化项目的层次结构。在默认情况下，这个文件被命名为settings.gradle，并且和根项目的build.gradle 文件放在一起。settings.gradle脚本的执行是在构建生命周期的初始化阶段。Gradle组装构建之前会创建一个<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/initialization/Settings.html" target="_blank" rel="noopener">Settings</a>类型的实例。Settings接口是settings文件的直接表示。若想使每个子项目都称为构建的一部分，则可以调用Settings接口中带有项目路径参数的include方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootProject</span><br><span class="line">      |———— settings.gradle</span><br><span class="line">      |———— build.gradle</span><br><span class="line">      |———— sub_project1</span><br><span class="line">      |            |———— build.gradle</span><br><span class="line">      |———— sub_project2</span><br><span class="line">      |            |———— build.gradle</span><br></pre></td></tr></table></figure><p>在settings.gradle中要声明当前项目包含的子项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:sub_project1&apos;, &apos;sub_project2&apos;</span><br></pre></td></tr></table></figure><p>注意：传给include方法的参数是项目路径，不是文件路径。该项目路径是相对于根目录的项目目录。也可以构建更深层次的项目结构。使用冒号(:)字符来分隔每一个子项目的层次结构。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:subs:sub_project1&apos;</span><br></pre></td></tr></table></figure><p>有时候，想要为所有的项目或只有子项目定义一些公共的行为。为实现这些用力，<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a> API提供了两个专门的方法：allprojects和subprojects。<br>在根目录中的build.gradle中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">task allTaskHello &lt;&lt;&#123;</span><br><span class="line">println &quot;hello from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置在allprojects 这个闭包下的所有内容对根项目和子项目都有效。<br>在根目录下执行<code>gradle  allTaskHello</code> 命令，可以看到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:allTaskHello</span><br><span class="line">hello from rootProject</span><br><span class="line"></span><br><span class="line">:sub_project1:allTaskHello</span><br><span class="line">hello from sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project2:allTaskHello</span><br><span class="line">hello from sub_project2</span><br></pre></td></tr></table></figure><p>在根目录中的build.gradle中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects&#123;</span><br><span class="line">task subTaskHello &lt;&lt;&#123;</span><br><span class="line">println &quot;hello from sub project $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置在subprojects 这个闭包下的所有内容只对子项目都有效，对根项目无效。<br>在根目录下执行<code>gradle subTaskHello</code> 命令，可以看到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:subTaskHello</span><br><span class="line">hello from sub project sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project2:subTaskHello</span><br><span class="line">hello from sub project sub_project2</span><br></pre></td></tr></table></figure><p>如果进入到子项目目录下执行gradle命令，只会对当前的这个子项目有效。比如进入sub_project1这个子项目中，执行<code>gradle  subTaskHello</code>命令，结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:subTaskHello</span><br><span class="line">hello from sub project sub_project1</span><br></pre></td></tr></table></figure><p><strong>默认的task执行顺序</strong></p><p>如果task没有声明依赖另一个task，在多项目构建中位于根目录的task总是先执行。对于子项目来说，执行顺序完全取决于项目名称的字母顺序。例如，sub_project1在sub_project2之前。记住，在settings文件中子项目的声明顺序完全不影响其执行顺序。</p><p><strong>单独定义特定的行为</strong></p><p>前面我们讲的，都是在allprojects和subprojects中进行的定义，实际上我们在根目录下的build.gradle中也可以对每一个项目进行单独的定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project(&apos;:sub_project1&apos;)&#123;</span><br><span class="line">task forSub1 &lt;&lt;&#123;</span><br><span class="line">println &apos;this is only for sub_project1 task&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>gradle forSub1</code>命令，可以看到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sub_project1:forSub1</span><br><span class="line">this is only for sub_project1 task</span><br></pre></td></tr></table></figure><blockquote><p>记住：在根目录下的build.gradle中执行task，Gradle会在所有拥有该task的project上执行该task。</p></blockquote><p><strong>属性继承</strong></p><p>属性继承，在一个根项目中定义的属性会自动的被其子项目继承，也就是说子项目中也可以用到这些属性，例如我们在根项目中声明一个扩展属性projectInfo，对于根项目和子项目都是可用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext.projectInfo=[&apos;group&apos;:&apos;com.sososeen09&apos;,&apos;version&apos;:&apos;0.1&apos;]</span><br><span class="line"></span><br><span class="line">group = projectInfo.group</span><br><span class="line">version = projectInfo.version</span><br><span class="line">project(&apos;:sub_project1&apos;)&#123;</span><br><span class="line">group = projectInfo.group</span><br><span class="line">    version = projectInfo.version</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project(&apos;:sub_project2&apos;)&#123;</span><br><span class="line">group = projectInfo.group</span><br><span class="line">    version = projectInfo.version</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>项目之间的依赖</strong></p><p>多项目之间一般不会是毫无关联的，可能会存在依赖关系。比如sub-project1中有taskA和taskB，taskA依赖于taskB，而taskB依赖于sub_project2中的taskC。到目前为止，我们把子项目中的属性和任务都放在根目录下的build.gradle中声明，现在是时候在它们各自的build.gradle中是声明自己的任务了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//sub_project1 中</span><br><span class="line">task taskA &lt;&lt; &#123;</span><br><span class="line">println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task taskB &lt;&lt; &#123;</span><br><span class="line">println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskA.dependsOn taskB</span><br><span class="line">taskB.dependsOn &apos;:sub_project2:taskC&apos;</span><br><span class="line"></span><br><span class="line">//sub_project2 中</span><br><span class="line">task taskC &lt;&lt; &#123;</span><br><span class="line">println &quot;this is $&#123;name&#125; from $&#123;project.name&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析一下，taskA 依赖taskB ，所以taskA执行之前，taskB必须先执行；而taskB又依赖于sub_project2中的taskC，所以taskB执行前，taskC必须先执行。<br>现在执行 <code>gradle taskA</code>命令，可以看到结果跟我们的分析一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:sub_project2:taskC</span><br><span class="line">this is taskC from sub_project2</span><br><span class="line"></span><br><span class="line">:sub_project1:taskB</span><br><span class="line">this is taskB from sub_project1</span><br><span class="line"></span><br><span class="line">:sub_project1:taskA</span><br><span class="line">this is taskA from sub_project1</span><br></pre></td></tr></table></figure><p><a href="http://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">下一篇</a>，我们开始学习自定义Gradle插件，这是本系列的最后一篇，也是一个非常重要的部分。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习8——依赖管理</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A08%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A08%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>依赖管理是Gradle非常棒的一个功能，很多情况下，你只需要在构建文件中添加一行代码，Gradle就会从远程仓库中下载依赖，在项目中就可以使用依赖中的类。如果你所依赖的这个库本身也有它自己的依赖，Gradle会处理并解决这些问题，这些依赖中的依赖，被称作传递性依赖。</p><p>Gradle使用 dependencies 这个DSL来定义构建所依赖的类库，使用repositories 来告诉构建从哪里获取依赖，当你配置好后，Gradle会自动下载依赖，并存储在本地缓存中，在构建中使用它们，一个特定版本的依赖只会在你的机器上下载一次。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.jsoup:jsoup:1.9.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle支持三种不同的依赖仓库：Maven、Ivy和静态文件或文件夹。一个依赖通常由三种元素定义的，可以称呼它们为依赖属性。</p><ul><li>group：通常标识一个组织、公司或者项目。如org.jsoup</li><li>name:一个工件的名称唯一的描述了依赖。如：:jsoup</li><li>version：一个类库的版本号。如1.9.2</li></ul><p>上面的dependencies，也可以使用map形式包含group、name、version属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group:&apos;org.jsoup&apos;, name:&apos;jsoup&apos;, version:&apos;1.9.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于依赖来说，唯一需要的字段是name。group和version都是可选的元素。尽管如此，为了表述清楚，建议添加group，而version可确保依赖库不会自动更新。</p></blockquote><h1 id="使用和配置仓库"><a href="#使用和配置仓库" class="headerlink" title="使用和配置仓库"></a>使用和配置仓库</h1><p>为了方便，Gradle预定义了三个Maven仓库：</p><ul><li>Jcenter</li><li>Maven Central</li><li>本地Maven仓库</li></ul><p>Gradle使用Maven Central仓库就是调用mavenCentral()方法，其它两个仓库的使用也类似。为了在构建脚本中包含它们，你需要这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    mavenCentral()</span><br><span class="line">    mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maven Central 和JCenter是两个有名的远程仓库，一般不同时使用它们，通常推荐使用JCenter，它是Maven Central的超集，其也是Android Studio创建Android项目时的默认依赖仓库，而且JCenter还支持HTTPS。</p><p>本地Maven仓库是你已经使用了的所有依赖的本地缓存，你也可以自己添加依赖。默认情况下，依赖仓库可以在一个名为.m2目录文件夹的主目录中找到。在Linux或Mac OS X上，该路径是~/.m2，在Windows上路径是%UserProfile%/.m2。<br>除了这些预定义的依赖仓库，你也可以添加其它的公有或私有仓库，可以指定一个任意的Maven或者Ivy仓库的URL并且配置来使用身份验证，或者可以使用简单的文件系统仓库来解决依赖关系。</p><p>在项目中定义仓库的关键是<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/dsl/RepositoryHandler.html" target="_blank" rel="noopener">RepositoryHandler</a>接口，它提供了添加各种类型仓库的方法。从项目上看，这些方法在repositories配置块中被调用。</p><p>可以声明多个仓库，下载依赖的时候按照声明的顺序来检查仓库，仓库提供了依赖优先原则，对于特定的依赖后续的仓库声明不会被进一步检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs &apos;libs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle API 支持两种方式来配置一个自定义仓库：maven()和mavenRepo()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        name &apos;Custom Maven Repository&apos;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用Ivy仓库，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些Maven仓库的访问需要凭证，那么可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;http://repo.acmp.com/release/&apos;</span><br><span class="line">        credentials&#123;</span><br><span class="line">            username &apos;user&apos;</span><br><span class="line">            password &apos;secretPassword&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不建议在构建配置文件中存储凭证，最好是在本地一个单独的未纳入版本控制系统的属性文件存储凭证</p></blockquote><p><strong>扁平的目录仓库</strong></p><p>flat目录是最简单和最基本的仓库形式。在文件系统中它是一个单独的目录，只包含jar文件或者Android 库中的aar类型的文件，没有maven元数据。<br>当声明依赖时，你只能使用name和versin属性，不能使用group属性，因为它会导致产生不明确的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile name: &apos;jsoup&apos;, version: &apos;1.9.2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir&#123;</span><br><span class="line">        dirs &apos;flatlibs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h1><p>某些情况下，你可能仍然需要使用手动下载的jar文件或原生库。<br>你可以使用Gradle提供的files方法来添加jar文件作为一个依赖，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">compile files(&apos;libs/jsoup.jar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果jar文件很多，我们一个一个的这样依赖太繁琐，就可以一次添加一个完成的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">compile fileTree(&apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android Studio中创建Android项目的时候，新建的Android项目会有一个libs文件夹，其会被声明为依赖的文件夹，并且通过过滤只依赖jar文件，而不是所有的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原生依赖</strong></p><p>如果想要使用C或C++编译的原生依赖库.so文件，需要指明jniLibs的目录。假设.so文件也都放置在libs目录下，如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-685e209dd721faf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在脚本文件中就需要这么配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>依赖项目</strong></p><p>如果在项目中创建了一个模块作为依赖项目，那么需要在settings.gradle中添加该模块，然后在应用模块中使用它作为依赖。比如，在Android项目中，app模块是我们的主模块，library模块是依赖模块，也称作依赖库。<br>settings.gradle 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos; ,&apos; : library&apos;</span><br></pre></td></tr></table></figure><p>app模块下的build.gradle中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">compile project(&apos;:library&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用.aar文件</strong></p><p>当你已经把aar文件放置在libs目录下或者其他的扁平文件目录下，添加aar文件作为依赖可以这么操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(name: &apos;libraryname&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure><p>这样就告知Gradle查找具有特定名称切扩展名为.aar的依赖库</p><h1 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h1><p>前面我们讲了添加依赖库的时候，前面都要有一个compile。其实这个compile就是一个配置Configuration。<br>Gradle根据配置对依赖进行分组，比如编译Java时使用的是这组依赖，运行Java时又可以使用另一组依赖。每一组依赖称为一个Configuration，在声明依赖时，我们实际上是在设置不同的Configuration。<br>Java插件提供了6个现成的配置：compile、runtime、testCompile、testRuntime、archives、default。<br>而在Android中的插件也提供了几个标准配置：compile、apk、provided、testCompile、androidTestCompile。<br>compile 是默认的配置，在编译主应用时包含所有的依赖，不禁会将依赖添加至类路径，还会生成对应的apk。<br>如果依赖使用apk配置，则该依赖只会被打包到apk，而不会被添加到编译类路径。<br>provided配置与apk配置相反，只在编译的时候用到，其依赖不会被打包进apk。<br>testCompile、androidTestCompile配置会添加用于测试的额外依赖库，在运行测试相关的任务时会被用到。比如添加JUnit或者Espresso测试框架。</p><p>要自定义一个配置Configuration，我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    myConfiguration &#123;</span><br><span class="line">        description = &apos;this is  my configuration&apos;</span><br><span class="line">        visible = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在自定义配置的时候，同时定义了该配置的一些属性，description表示的是该配置的描述信息，visiable表示该配置是否可以在该Project之外可见，默认是true。还可以定义其它的属性，具体可参考<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/Configuration.html" target="_blank" rel="noopener">Configuration</a>这个类。当然，你也可以什么都不写。configurations对应的Gradle的Api中<a href="https://docs.gradle.org/4.2.1/javadoc/org/gradle/api/artifacts/ConfigurationContainer.html" target="_blank" rel="noopener">ConfigurationContainer</a>这个类。</p><p>以上只是定义了一个名为myConfiguration的配置，我们并未向其中加入依赖。可以通过dependencies()方法向myConfiguration中加入实际的依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   myConfiguration &apos;org.jsoup:jsoup:1.9.2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>gradle dependencies</code> 这个帮助task，会显示当前的依赖树。此时可以看到我们在myConfiguration这个配置中依赖的库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myConfiguration - this is  my configuration</span><br><span class="line">\--- org.jsoup:jsoup:1.9.2</span><br></pre></td></tr></table></figure><p>由于我们只依赖了一个库，所以依赖树看着很简洁。如果依赖很多库，而这些依赖库又都有传递性依赖，就有可能发生依赖冲突。如果存在依赖冲突，在默认情况下，Gradle会选择最新版本，这和Maven是不同的，Maven会选择离依赖树最近的版本。如果你需要更改默认的冲突解决策略，可以自行搜索相关内容，本文就不多做介绍了。</p><p>使用Gradle API可以找到Gradle依赖的缓存文件放置的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printDependencies &lt;&lt; &#123;</span><br><span class="line">    configurations.getByName(&apos;myConfiguration&apos;).each &#123; dependency -&gt;</span><br><span class="line">        println dependency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>gradle printDependencies</code> 命令，可以看到打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :printDependencies</span><br><span class="line">/Users/jason/.gradle/caches/modules-2/files-2.1/org.jsoup/jsoup/1.9.2/5e3bda828a80c7a21dfbe2308d1755759c2fd7b4/jsoup-1.9.2.jar</span><br></pre></td></tr></table></figure><h1 id="动态版本声明"><a href="#动态版本声明" class="headerlink" title="动态版本声明"></a>动态版本声明</h1><p>如果想使用最新版本的依赖，可以使用占位符 latest.integration 。例如 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jsoup:jsoup:latest-integration</span><br></pre></td></tr></table></figure><p>或者，声明版本属性，通过使用一个加号(+) 标定它来动态改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jsoup:jsoup:1.+</span><br></pre></td></tr></table></figure><p>当然了，我们最好是少用或者不用动态版本声明。</p><p><a href="http://www.jianshu.com/p/62c1f3ca380c" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中的多项目构建。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习7——编写和使用自定义Task</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A07%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E5%92%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Task/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A07%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E5%92%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Task/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>自定义task包含两个组件：</p><ul><li>自定义的task类，封装了逻辑行为，也被称作任务类型</li><li>真实的task，提供了用于配置行为的task类所暴露的属性值。Gradle把这些task称为增强的task。</li></ul><p>可维护性是编写自定义task类的优势之一。增强的task的另一个优势是可重用性。自定义task所暴露的属性可以在构建脚本中进行单独设置。</p><p>我们还是按照之前的例子，修改配置文件中的release 参数。</p><h1 id="自定义task类"><a href="#自定义task类" class="headerlink" title="自定义task类"></a>自定义task类</h1><p>前面已经提到，Gradle为构建脚本中每个简单的task都创建了一个DefaultTask类型的实例。我们现在创建一个ReleaseVersionTask，它的作用是把目标文件中的release变为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ReleaseVersionTask extends DefaultTask&#123;</span><br><span class="line">  @Input Boolean release</span><br><span class="line">  @OutputFile File destFile</span><br><span class="line"></span><br><span class="line">  ReleaseVersionTask()&#123;</span><br><span class="line">    group=&apos;versioning&apos;</span><br><span class="line">    description=&apos;Makes project a release version.&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @TaskAction</span><br><span class="line">  void start()&#123;</span><br><span class="line">    project.version.release=true;</span><br><span class="line">    ant.propertyfile(file:destFile)&#123;</span><br><span class="line">       entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过org.gradle.api.tasks包下的注解可以用来声明输入输出属性。</p><blockquote><p>task输入验证 @Input注解会在配置期间验证属性值。如果值为null，Gradle会抛出TaskValidationException异常。为了允许输入为null值，可以给它添加@Optional注解。</p></blockquote><h1 id="使用自定义task"><a href="#使用自定义task" class="headerlink" title="使用自定义task"></a>使用自定义task</h1><p>我们自定义的task类是没有办法自己执行的，要使用和配置自定义task类定义的行为和属性，需要创建一个增强型的task。该task定义了它要使用的task类型，在本例中我们定义一个增强型taskmakeReleaseVersion，它使用的task类型是ReleaseVersionTask，通过为它的属性赋值来设置输入和输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(type:ReleaseVersionTask)&#123;</span><br><span class="line">// 设置自定义task属性</span><br><span class="line">    release = version.release</span><br><span class="line">    destFile = versionFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>gradle makeReleaseVersion</code> 命令 ，会发现增强型的makeReleaseVersion task与之前的<a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">文章</a>中简单的task的运行结果表现完全一致。<br>与简单的task实现相比，增强型task的一个巨大优势在于所暴露的属性可以被单独赋值。</p><p>比如，ProjectVersion 中的release字段名改为了prodReady，属性文件改名为 project-version.properties。<br>那么makeReleaseVersion task可以这样设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(type:ReleaseVersionTask)&#123;</span><br><span class="line">    release = version.prodReady</span><br><span class="line">    destFile =file(&apos;project-version.properties&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在buildSrc目录下构建代码"><a href="#在buildSrc目录下构建代码" class="headerlink" title="在buildSrc目录下构建代码"></a>在buildSrc目录下构建代码</h1><p>我们可以把ReleaseVersionTask这个类单独放在一个Groovy文件中，这样就可以在其它地方通过导包的方式来重用这个类。<br>在一个项目工程当中，创建的Groovy类适合被移动到项目的buildSrc目录下。Gradle在buildSrc目录下使源文件结构标准化。Groovy代码放在src/main/groovy目录下，对于Java文件则是放置在src/main/java目录下面。位于这些目录下的文件会被自动编译，并且都加入到Gradle构建脚本的classpath中。</p><p><strong>注意：提取一个类到Groovy文件中需要设置package，在build.gradle中或者其它地方使用这个类的时候需要导包，这一点与Java类的使用是一样的。当然了，如果这个类本身就放在build.gradle中则不需要这个过程，就像之前的例子那样。</strong></p><p>例如 ReleaseVersionTask </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.sososeen09.gia</span><br><span class="line"></span><br><span class="line">import org.gradle.api.DefaultTask</span><br><span class="line">import org.gradle.api.tasks.Input</span><br><span class="line">import org.gradle.api.tasks.OutputFile</span><br><span class="line">import org.gradle.api.tasks.TaskAction</span><br><span class="line">class ReleaseVersionTask extends DefaultTask&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Groovy文件实际放置的位置是 buildSrc/src/main/groovy/com/sososeen09/gia/ReleaseVersionTask</p><p>根据同样的方式，我们也可以把ProjectVersion这个类抽取出来。</p><p>使用的时候，在build.gradle中顶部记得导包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import com.sososeen09.gia.ReleaseVersionTask</span><br><span class="line">import com.sososeen09.gia.ProjectVersion</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，执行<figure class="highlight gradle"><figcaption><span>makeReleaseVersion``` 命令，我们就可以看到编译过程：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>:buildSrc:compileJava UP-TO-DATE<br>:buildSrc:compileGroovy UP-TO-DATE<br>:buildSrc:processResources UP-TO-DATE<br>:buildSrc:classes UP-TO-DATE<br>:buildSrc:jar UP-TO-DATE<br>:buildSrc:assemble UP-TO-DATE<br>:buildSrc:compileTestJava UP-TO-DATE<br>:buildSrc:compileTestGroovy UP-TO-DATE<br>:buildSrc:processTestResources UP-TO-DATE<br>:buildSrc:testClasses UP-TO-DATE<br>:buildSrc:test UP-TO-DATE<br>:buildSrc:check UP-TO-DATE<br>:buildSrc:build UP-TO-DATE<br>Reading the version file<br>:makeReleaseVersion</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**记住：buildSrc 目录被视为Gradle项目的指定路径。**</span><br><span class="line"></span><br><span class="line"># 把Task编写的类编译成jar包提供给其它项目使用</span><br><span class="line"></span><br><span class="line">我们把Groovy类放在了buildSrc目录下，虽然自定义的Task类与build.gradle分离开了，但是这些类依然只能应用到当前的项目中。如果我们想要在其它的项目中也可以使用这些Task，就需要在单独的项目中来定义，然后其它项目通过声明依赖的方式来使用。</span><br><span class="line"></span><br><span class="line">创建一个新项目，把之前我们讲的buildSrc目录下的内容复制到这个项目中。这个时候，我们就要自己使用Groovy插件来编译这些Groovy源代码了，就像我们编译Java代码需要Java插件一样。Groovy插件是基于Java插件的。在这个项目目录下新建一个build.gradle文件，并在文件中引入Groovy Plugin。</span><br><span class="line">还有一点，我们期望把这些Groovy编写的Task和其它类打包成jar文件供其它地方使用。这个时候我们就可以使用maven插件，把jar文件上传到repository中。关于如何使用maven插件上传，可以查阅相关文档，也可以看这篇 [Gradle User Guide Maven Plugin](https://docs.gradle.org/4.2.1/userguide/maven_plugin.html)。为了简单演示，打包的jar文件上传到了本地的文件系统中。最终的build.gradle文件如下：</span><br></pre></td></tr></table></figure><p>apply plugin: ‘groovy’<br>apply plugin: ‘maven’</p><p>version = ‘1.0’<br>group = ‘com.sososeen09.gia’<br>archivesBaseName = ‘releaseVersionTask’</p><p>repositories {<br>    mavenCentral()<br>}</p><p>dependencies {<br>    // 编译的时候我们需要使用Gradle中的API<br>    compile gradleApi()<br>}</p><p>uploadArchives {<br>    repositories {<br>        mavenDeployer {<br>            repository(url: “file:../lib”)<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行`gradle uploadArchives`命令后就可以看到，在与当前项目同级的lib文件目录中生成了我们期望的jar文件。</span><br><span class="line"></span><br><span class="line">下面来演示如何使用这个jar文件。我们再新建一个工程，这个工程中有一个脚本文件build.gradle和一个配置文件version.properties。</span><br><span class="line">其中，build.gradle中的代码如下：</span><br></pre></td></tr></table></figure></p><p>import com.sososeen09.gia.ReleaseVersionTask<br>import com.sososeen09.gia.ProjectVersion<br>buildscript {<br>    repositories {<br>        maven {<br>            url ‘file:../lib’<br>        }</p><pre><code>}dependencies {    classpath &apos;com.sososeen09.gia:releaseVersionTask:1.0&apos;}</code></pre><p>}</p><p>version=new ProjectVersion(0,1)</p><p>task printVersion {<br>  doLast{<br>    logger.quiet “Version: $version”<br>  }<br>}</p><p>// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例<br>ext.versionFile=file(‘version.properties’)</p><p>task loadVersion{<br>    project.version=readVersion()<br>}</p><p>//readVersion方法，与task是不同的<br>ProjectVersion readVersion(){<br>    logger.quiet ‘Reading the version file’<br>    if(!versionFile.exists()){<br>        throw new GradleException (“Required version file dose not exist:$versionFile.canonicalPath “ )<br>    }</p><pre><code>//Groovy的文件实现通过添加新的方法来读取InputStreamProperties versionProps=new Properties()versionFile.withInputStream{stream-&gt;    versionProps.load(stream)}// 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())</code></pre><p>}</p><p>task makeReleaseVersion(type:ReleaseVersionTask){<br>    release = version.release<br>    destFile = versionFile<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">version.properties中的内容如下：</span><br></pre></td></tr></table></figure><p>major=0<br>minor=1<br>release=fasle<br>```</p><p>执行 <code>gradle makeReleaseVersion</code> 命令之后可以看到配置文件中release变为true。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的介绍，我们了解了自定义Task的方式。 自定义的Task可以放置在build.gradle脚本中，也可以在当前的项目的buildSrc目录下。当然了，如果你期望你写的自定义Task可以被其它的项目中使用，那么你可以用一个单独的工程来放置自定的Task。</p><p>关于自定义Task的学习，我们也可以查看Gradle的官方Guide来查看如何<a href="https://guides.gradle.org/writing-gradle-tasks/" target="_blank" rel="noopener">自定义task</a></p><p><a href="http://www.jianshu.com/p/e01d647b1c75" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中的依赖管理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.gradle.org/4.2.1/userguide/maven_plugin.html" target="_blank" rel="noopener">Gradle User Guide Maven Plugin</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习6——挂接到构建生命周期</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A06%E2%80%94%E2%80%94%E6%8C%82%E6%8E%A5%E5%88%B0%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A06%E2%80%94%E2%80%94%E6%8C%82%E6%8E%A5%E5%88%B0%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>之前已经讲了Gradle的构建生命周期阶段，当我们在编写构建脚本的时候，可能不仅限于编写不同构建阶段执行的task工作或者配置逻辑。有的时候当一个特定的生命周期事件或者task执行的时候，你想要执行一些代码。这个时候我们就可以根据回调生命周期事件来处理我们需要的逻辑。</p><p>有两种方式编写回调生命周期事件：在闭包中或者通过Gradle API所提供的监听器接口实现。<br>选择哪种方式都可以，这个就看个人选择了。<br>采用监听器实现最大的优势在于你处理的类通过编写单元测试是完全可测试的。<br>下面展示了一个hook 构建生命周期的示意图。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-a0bb14f5a52d292e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hook生命周期.png"></p><p>许多生命周期回调方法被定义在Project和Gradle接口中。</p><h1 id="挂接到task执行图"><a href="#挂接到task执行图" class="headerlink" title="挂接到task执行图"></a>挂接到task执行图</h1><p>我们之前讲的例子是通过一个task来将配置文件中的release变为true，现在，我们编写一个生命周期钩子可以实现同样的目标。因为构建确切的知道task在得到执行之前哪些将参与构建，假设当我们的脚本文件build.gradle中如果有releaseProject 这个task的话，我们就把release 变为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task releaseProject &lt;&lt; &#123;</span><br><span class="line">    logger.quiet &apos;Releasing the project...&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.whenReady&#123;TaskExecutionGraph taskGraph -&gt;</span><br><span class="line">  //注册的生命周期钩子在task图生成后被调用</span><br><span class="line">  //查看执行图中是否包含task releaseProject</span><br><span class="line">  if(taskGraph.hasTask(releaseProject))&#123;</span><br><span class="line">     if(!version.release)&#123;</span><br><span class="line">       version.release=true</span><br><span class="line">       ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">         entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行任何一个能够触发releaseProject任务的命令，比如<code>gradle releaseProject</code>，这个时候releaseProject 这个task就被添加到task执行图中了，当task执行图生成完成后，TaskExecutionGraph 这个类提供的 whenReady 方法会被调用。</p><h1 id="实现task执行图监听器"><a href="#实现task执行图监听器" class="headerlink" title="实现task执行图监听器"></a>实现task执行图监听器</h1><p>通过监听器挂接到构建生命周期只需要两个简单的步骤：</p><ul><li>通过在构建脚本中编写一个类实现特定的监听器接口</li><li>注册监听器实现</li></ul><p>用于监听task执行图事件的接口是由TaskExecutionGraphListener接口提供的。<br>监听器可以通过通用的addListener方法或者指定监听器类型实例的方法进行注册。</p><p>有一点要指出，在我们自定义的监听器中，是不可以直接访问构建脚本的Project实例的。我们可以根据Task类的getProject()方法来获得该task所在的Project实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ReleaseVersionListener implements TaskExecutionGraphListener &#123;</span><br><span class="line">    final static String releaseTaskPath = &apos;:releaseProject&apos;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void graphPopulated(TaskExecutionGraph taskGraph) &#123;</span><br><span class="line">      // 确定releaseProject task 是否包含在执行图中</span><br><span class="line">        if (taskGraph.hasTask(releaseTaskPath)) &#123;</span><br><span class="line">            List&lt;Task&gt; allTasks = taskGraph.allTasks</span><br><span class="line">            // 从执行图中的所有task来找到releaseProject 的 task 实例</span><br><span class="line">            Task releaseTask = allTasks.find &#123; it.path == releaseTaskPath &#125;</span><br><span class="line">            // 每个task都知道自己所属的project</span><br><span class="line">            Project project = releaseTask.project</span><br><span class="line"></span><br><span class="line">            if (!project.version.release) &#123;</span><br><span class="line">                project.version.release = true</span><br><span class="line">                project.ant.propertyfile(file: project.versionFile) &#123;</span><br><span class="line">                    entry(key: &apos;release&apos;, type: &apos;string&apos;, operation: &apos;=&apos;, value: &apos;true&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册监听器到task执行图中</span><br><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(new ReleaseVersionListener())</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们上面介绍了挂接到构建生命周期的两种方式，这些都是在构建脚本中进行的。但实际上并不局限于在构建脚本中注册生命周期监听器。在任何task执行之前，都可以应用生命周期逻辑来监听Gradle事件，比如在初始化脚本中也可以来挂接到构建生命周期，这部分内容我们就不介绍了，有兴趣的可以自行搜索。</p><p><a href="http://www.jianshu.com/p/5a413815a7ae" target="_blank" rel="noopener">下一篇</a>，我们开始学习编写和使用自定义Task。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习5——Gradle增量式构建</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A05%E2%80%94%E2%80%94Gradle%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%9E%84%E5%BB%BA/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A05%E2%80%94%E2%80%94Gradle%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>Gradle的增量式构建特性紧紧的与生命周期相结合。Gradle的增量式构建支持自动鉴别不需要被运行的任务。这些任务会被标记为 UP-TO-DATE。特别是在大型的企业级项目，这个特性是节约时间的好帮手。</p><p>Gradle通过比较两次构建task的inputs和outputs来决定task是否是最新的。自从最后一次task执行以来，如果inputs和outputs没有发生变化，则认为task是最新的。</p><p>输入可以是一个目录、一个或多个文件，或者是一个任意属性。<br>一个task的输出是通过一个目录或1~n个文件来定义的。<br>inputs和outputs在DefaultTask类中被定义为属性或者有一个直接类来表示。对应的是TaskInputs和TaskOutputs。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-e7d0ab5ff92f309d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TaskInputs和TaskOutputs.png"></p><p>为了便于表述，我们还是接着<a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">上一篇</a>的那个例子，从配置文件version.properties中读取参数，并打印出版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">version=new ProjectVersion(0,1)</span><br><span class="line"></span><br><span class="line">class ProjectVersion&#123;</span><br><span class="line">    Integer major</span><br><span class="line">    Integer minor</span><br><span class="line">    Boolean release</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=Boolean.FALSE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor, Boolean release)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=release</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String toString()&#123;</span><br><span class="line">      &quot;$major.$minor$&#123;release?&apos;&apos;: &apos;-SNAPSHOT&apos;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例</span><br><span class="line">ext.versionFile=file(&apos;version.properties&apos;)</span><br><span class="line"></span><br><span class="line">task loadVersion&#123;</span><br><span class="line">    project.version=readVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//readVersion方法，与task是不同的</span><br><span class="line">ProjectVersion readVersion()&#123;</span><br><span class="line">    logger.quiet &apos;Reading the version file&apos;</span><br><span class="line">    if(!versionFile.exists())&#123;</span><br><span class="line">        throw new GradleException (&quot;Required version file dose not exist:$versionFile.canonicalPath &quot; )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Groovy的文件实现通过添加新的方法来读取InputStream</span><br><span class="line">    Properties versionProps=new Properties()</span><br><span class="line">    versionFile.withInputStream&#123;stream-&gt;</span><br><span class="line">        versionProps.load(stream)</span><br><span class="line">    &#125;</span><br><span class="line">    // 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略</span><br><span class="line">    new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中的初始参数是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">major=0</span><br><span class="line">minor=1</span><br><span class="line">release=false</span><br></pre></td></tr></table></figure><p>现在，我们要增加一个新的任务：新建一个名为makeReleaseVersion的task来将配置文件中的release属性改为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(group :&apos;versioning&apos;,description :&apos;Makes project a release version.&apos; )&lt;&lt; &#123;</span><br><span class="line">    version.release=true</span><br><span class="line">// Ant task 的propertyfile 提供了一种便利的方式来修改属性文件</span><br><span class="line">    ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">        entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行gradle makeReleaseVersion<br>之后打开配置文件 version.properties 就可以看到文件中的release属性已经变为true了。</p><p>执行 <code>gradle printVersion</code> 命令，可以看到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">Version: 0.1</span><br></pre></td></tr></table></figure><p><strong>注意，虽然我们将配置文件中的release标记为true，但是Gradle并不知道。当我们再次执行makeReleaseVersion这个task的时候，doLast这个闭包中的代码还是会执行，会花多余的时间。为了解决这个问题，需要声明它的inputs和outputs。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVersion(group :&apos;versioning&apos;,description :&apos;Makes project a release version.&apos; )&#123;</span><br><span class="line">    //在配置阶段声明inputs/outputs</span><br><span class="line">    //声明版本的release属性作为输入</span><br><span class="line">    inputs.property(&apos;release&apos;,version.release)</span><br><span class="line">    //由于版本文件被修改了，所以它被声明作为输出文件属性</span><br><span class="line">    outputs.file versionFile</span><br><span class="line">    doLast&#123;</span><br><span class="line">        version.release=true</span><br><span class="line">// Ant task 的propertyfile 提供了一种便利的方式来修改属性文件</span><br><span class="line">        ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">            entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value: &apos;true&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记住：task的inputs和outputs属性是在配置阶段执行的用来连接task的依赖。这就是他们需要在配置块中被定义的原因。为了避免出现所不期望出现的行为，请确保赋给inputs和outputs的值在配置阶段是可访问的。如果需要通过编程获得输出，可以通过TaskOutputs上的upToDateWhen（Closure）方法来实现。与常规的inputs和outputs相比，这个方法是在执行期间执行的。如果闭包返回true，这个task则会被认为是最新的。</p></blockquote><p>如果执行两次makeReleaseVersion任务，会发现Gradle已经知道配置文件中的release 已经变为true，会自动跳过第二次执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:makeReleaseVersion UP-TO-DATE</span><br></pre></td></tr></table></figure><p>实际上，我们在apk打包过程中经常看到的UP-TO-DATE 就是因为输入输出没有发生变化，Gradle跳过了这个task的执行。</p><p><a href="http://www.jianshu.com/p/bb13bfb8d1b0" target="_blank" rel="noopener">下一篇</a>，我们开始学习Gradle中如何挂接到构建生命周期。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习4——深入了解Task和构建生命周期</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A04%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Task%E5%92%8C%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A04%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Task%E5%92%8C%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><h1 id="声明Task"><a href="#声明Task" class="headerlink" title="声明Task"></a>声明Task</h1><p>默认情况下，每个新创建的task都是org.gradle.api.DefaultTask类型的，它是标准的org.gradle.api.Task 实现。DefaultTask的所有属性都是private的，只能通过getter和setter方法来访问。</p><blockquote><p>幸运的是，Groovy提供了一些语法糖，可以直接通过属性名来使用属性。在底层，Groovy会为你调用这些方法。</p></blockquote><p>一个简单的task可以是这样，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task printVersion &#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>gradle printVersion</code> 命令，结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>如果换成doFirst，执行的结果也是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="给现有的Task添加动作"><a href="#给现有的Task添加动作" class="headerlink" title="给现有的Task添加动作"></a>给现有的Task添加动作</h1><p>task在创建后，可以根据需要添加很多动作，在内部，每个task都保持了一个动作列表，在运行时，它们按顺序执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line"></span><br><span class="line">// 声明一个包含doFirst和doLast的task</span><br><span class="line">task printVersion &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">      println &quot;Before reading the project version&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast&#123;</span><br><span class="line">      println &quot;Version: $version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在动作列表的开始添加doFirst闭包</span><br><span class="line">//在动作列表的最后添加doLast闭包，采用别名的方式</span><br><span class="line">printVersion.doFirst &#123;println &quot;First action&quot;&#125;</span><br><span class="line">printVersion&lt;&lt;&#123;println &quot;Last action&quot;&#125;</span><br></pre></td></tr></table></figure><p>执行<code>gradle printVersion</code> 命令，结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:printVersion</span><br><span class="line">First action</span><br><span class="line">Before reading the project version</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br><span class="line">Last action</span><br></pre></td></tr></table></figure><p>如上所示，可以给现有的task添加一些动作，这在你想要为不是自己编写的task执行自定义逻辑时非常有用。比如，为Java插件的compileJava task添加一个doFirst动作来检查项目中至少包含一个Java源文件。</p><h1 id="访问DefaultTask属性"><a href="#访问DefaultTask属性" class="headerlink" title="访问DefaultTask属性"></a>访问DefaultTask属性</h1><p>Gradle提供了一个基于SLF4J日志库的logger实现。除了常规的日志级别如DEBUG、ERROR、INFO、TRACE、WARN，之外Gradle还增加了一些额外的日志级别。通过Task的方法可以直接访问logger实例。例如，打印QUIET日志级别的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task还有两个属性：description和group。description属性用于描述任务的作用，而group属性则用于定义task的逻辑分组。<br>创建task的时候可以为这两个属性设置值作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printVersion(group: &apos;versioning&apos;,description:&apos;Print project version&apos; ) &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过setter方法来设置属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task printVersion&#123;</span><br><span class="line">  group = &apos;versioning&apos;</span><br><span class="line">  description = &apos;Print project version&apos;</span><br><span class="line">  doLast&#123;</span><br><span class="line">    logger.quiet &quot;Version: $version&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>gradle task</code> 命令，可以看到task正确的分组和描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Versioning tasks</span><br><span class="line">----------------</span><br><span class="line">printVersion - Print project version</span><br></pre></td></tr></table></figure><p>尽管设置task的描述和分组和可选的，但是为所有的task指定description和group是一个比较好的实践，这会帮助用户比较容易的去识别task的功能。</p><h1 id="定义task依赖"><a href="#定义task依赖" class="headerlink" title="定义task依赖"></a>定义task依赖</h1><p>dependsOn方法允许声明依赖一个或多个task。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version =&apos;0.1-SNAPSHOT&apos;</span><br><span class="line">task first &lt;&lt; &#123; println &apos;first&apos;&#125;</span><br><span class="line">task second &lt;&lt; &#123; println &apos;second&apos; &#125;</span><br><span class="line"></span><br><span class="line">//指定多个task依赖</span><br><span class="line">task printVersion(dependsOn :[second,first]) &lt;&lt; &#123;</span><br><span class="line">    logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//task third(dependsOn : printVersion) &lt;&lt;&#123;</span><br><span class="line">//    println &apos;third&apos;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//还可以采用这样的方式</span><br><span class="line">task third &lt;&lt;&#123; println &apos;third&apos;&#125;</span><br><span class="line">third.dependsOn(&apos;printVersion&apos;)</span><br></pre></td></tr></table></figure><p>执行gradle -q third 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br><span class="line">third</span><br></pre></td></tr></table></figure><p>看到执行结果会有一点点意外，printVersion任务的依赖是second和first，为什么不是先执行second再执行first呢？在Gradle中，task执行顺序是不确定的。</p><h1 id="Task的执行顺序"><a href="#Task的执行顺序" class="headerlink" title="Task的执行顺序"></a>Task的执行顺序</h1><p>理解Gradle并不能保证task依赖的执行顺序是很重要的。dependsOn方法只是定义了所依赖的task需要先执行。Gradle的思想是声明在一个给定的task执行之前什么该被执行，而没有去定义它该如何执行。在Gradle中，执行顺序是由task的输入/输出规范自动确定的。</p><p><strong>好处</strong>：</p><ol><li>不需要知道整个task依赖链上的关系是否发生改变，这样可以提高代码的可维护性和避免潜在的破坏。</li><li>因为构建没有严格的执行顺序，也就是支持task的并行执行，这样可以极大地节约构建执行时间。</li></ol><h1 id="理解task配置"><a href="#理解task配置" class="headerlink" title="理解task配置"></a>理解task配置</h1><p>在Gradle脚本中可以定义通用的Groovy代码的功能。Groovy中只需要声明属性，不需要添加访问权限修饰符。getter和setter方法本质上是在生成字节码时自动添加的，运行时可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version=new ProjectVersion(0,1)</span><br><span class="line">class ProjectVersion&#123;</span><br><span class="line">    Integer major</span><br><span class="line">    Integer minor</span><br><span class="line">    Boolean release</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=Boolean.FALSE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProjectVersion(Integer major, Integer minor, Boolean release)&#123;</span><br><span class="line">       this.major=major</span><br><span class="line">       this.minor=minor</span><br><span class="line">       this.release=release</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String toString()&#123;</span><br><span class="line">      &quot;$major.$minor$&#123;release?&apos;&apos;: &apos;-SNAPSHOT&apos;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">  logger.quiet &quot;Version: $version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>gradle printVersion</code> ，得到的结果与之前相同。</p><p>我们也可以使用配置文件来设置属性。<br>例如新建一个version.properties文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">major = 0</span><br><span class="line">minor = 1</span><br><span class="line">release = false</span><br></pre></td></tr></table></figure><p>对应的version就是0.1-SANPSHOT</p><p>然后可以添加task的配置块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例</span><br><span class="line">// versionFile是一个扩展属性</span><br><span class="line">ext.versionFile=file(&apos;version.properties&apos;)</span><br><span class="line"></span><br><span class="line">//没有使用左移操作符定义task配置</span><br><span class="line">task loadVersion&#123;</span><br><span class="line">    project.version=readVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//readVersion方法，注意：这个是方法，而不是task</span><br><span class="line">ProjectVersion readVersion()&#123;</span><br><span class="line">    logger.quiet &apos;Reading the version file&apos;</span><br><span class="line">    if(!versionFile.exists())&#123;</span><br><span class="line">        throw new GradleException (&quot;Required version file dose not exist:$versionFile.canonicalPath &quot; )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Groovy的文件实现通过添加新的方法来读取InputStream</span><br><span class="line">    Properties versionProps=new Properties()</span><br><span class="line">    versionFile.withInputStream&#123;stream-&gt;</span><br><span class="line">        versionProps.load(stream)</span><br><span class="line">    &#125;</span><br><span class="line">    // 在Groovy中，如果return是方法中的最后一条语句的话，则可以将它省略</span><br><span class="line">    new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>gradle printVersion</code>，会看到 loadVersion 中的代码执行了。尽管 loadVersion 这个task的名字没有打印出来，但是可以看到打印日志了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reading the version file</span><br><span class="line">:printVersion</span><br><span class="line">Version: 0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>我们不禁疑问，为什么我们没有执行 loadVersion 这个task，也没有声明依赖关系，但是它内部的代码依然被执行了呢？<br>原因就是我们在loadVersion这个task闭包中的<code>project.version=readVersion()</code>属于task配置块，而task配置块永远在task动作执行之前被执行，只要触发构建，脚本文件中的所有task配置块都会执行，这牵涉到了Gradle的构建生命周期问题。</p><blockquote><p>注意区分 配置块和action是不同的，task的action一般就是doFirst和doLast。</p></blockquote><h1 id="构建生命周期阶段"><a href="#构建生命周期阶段" class="headerlink" title="构建生命周期阶段"></a>构建生命周期阶段</h1><p>无论什么时候执行Gradle构建，都会运行三个不同的生命周期阶段：初始化、配置和执行。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-8da49286d17b50b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle生命周期示意图.png"></p><p>初始化阶段，Gradle为项目创建了一个Project实例。给定的构建脚本只定义了一个项目，在多项目构建中，这个构建阶段变得更加重要。根据正在执行的项目，Gradle找出哪些项目依赖需要参与到构建中。</p><blockquote><p>注意：在这个构建阶段当前已有的构建脚本代码都不会被执行。</p></blockquote><p>配置阶段，Gradle构造了一个模型来表示任务，并参与到构建中来。增量式构建特性决定了模型中的task是否需要被运行。这个阶段非常适合与为项目或执行task设置所需的配置。</p><blockquote><p>注意：项目每一次构建的任何配置代码都可以被执行——即使你只执行gradle tasks</p></blockquote><p>执行阶段，所有的task都应该以正确的顺序被执行。执行顺序是由它们的依赖决定的。如果任务被认为没有修改过，将被跳过，这个牵涉到增量式构建，我们<a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">下一篇</a>再讲。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习3——自定义属性</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A03%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A03%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><p>读取和设置Project和Task的属性是很重要的一块内容，每个Project和Task实例都提供了可以通过getter和setter方法访问的属性。一个属性可能是一个任务的描述或者项目的版本。你也可以定义自己的属性。Gradle允许用户通过扩展属性自定义一些变量。还有，很多Plugin都会加入扩展属性，可以通过设置属性来控制使用Pulgin。</p><h1 id="Project自带的属性"><a href="#Project自带的属性" class="headerlink" title="Project自带的属性"></a>Project自带的属性</h1><p>Gradle在默认情况下已经为Project定义了很多属性，其中比较常用的有：</p><ul><li>project：Project本身对象</li><li>name：Project的名字</li><li>path：Project的绝对路径</li><li>description：Project的描述信息</li><li>buildDir：Project构建结果存放目录</li><li>version：Project的版本号<br>属性都可以通过getter和setter方法来访问，也可以直接使用点好的形式来访问，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setDescription(&apos;myProject&apos;)</span><br><span class="line">println &quot;Description of project $name: &quot;+project.description</span><br></pre></td></tr></table></figure><p>当在build.gradle中访问属性和方法的时候，不需要使用project变量，它会假设你使用的是project实例。但是有一些情况需要注意，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = &apos;this is the project version&apos;</span><br><span class="line">description = &apos;this is the project description&apos;</span><br><span class="line"></span><br><span class="line">task showProjectProperties &lt;&lt; &#123;</span><br><span class="line">   println version</span><br><span class="line">   println project.description</span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Task本身也有description属性，所以当在Task中，如果不显式的指定project，就会打印的是Task的description。这是因为定义Task的闭包将delegate设置成了当前的Task。有关delegate的介绍，我们可以看前一篇文章。<br> Gradle还为我们提供了多种方法来自定义Project的Property。</p><h1 id="额外属性"><a href="#额外属性" class="headerlink" title="额外属性"></a>额外属性</h1><p>Gradle的很多领域模型类提供了特别的属性支持。在内部，这些属性以简直对的形式存储。为了添加属性，你需要使用ext命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 只在初始声明额外属性时需要使用ext命名空间</span><br><span class="line">project.ext.myProp=&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">ext&#123;</span><br><span class="line">        someOtherProp=123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用ext命名空间访问属性是可选的</span><br><span class="line">assert myProp==&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">println project.someOtherProp</span><br><span class="line"></span><br><span class="line">ext.someOtherProp=567</span><br></pre></td></tr></table></figure><p>类似的，额外的属性也可以通过属性文件来提供。</p><h1 id="Gradle属性"><a href="#Gradle属性" class="headerlink" title="Gradle属性"></a>Gradle属性</h1><p>Gradle属性可以通过在gradle.properties文件中声明直接添加到项目中，这个文件位于<user_home>/.gradle目录或者项目的根目录下。这些属性可以通过项目实例访问。即使有多个项目，每个用户也只有能一个Gradle属性文件在xx/.gradle目录下，这是目前Gradle对它的限制。</user_home></p><p>在这个属性文件中声明的属性对所有的项目可用。<br>我们假设在gradle.properties文件中声明的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exampleProp=myValue</span><br><span class="line">someOtherProp=455</span><br></pre></td></tr></table></figure><p>可以按照如下方式访问项目中的这两个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assert project.exampleProp==&apos;myValue&apos;</span><br><span class="line"></span><br><span class="line">task printGradleProperties &lt;&lt;&#123;</span><br><span class="line">    println &quot;Second property :$someOtherProp&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="声明属性的其他方式"><a href="#声明属性的其他方式" class="headerlink" title="声明属性的其他方式"></a>声明属性的其他方式</h1><p>前面两种方式，我们大多用来声明自定义变量及其值。Gradle也提供了很多其他方式为构建提供属性。</p><h2 id="项目属性通过-P命令行选项提供"><a href="#项目属性通过-P命令行选项提供" class="headerlink" title="项目属性通过 -P命令行选项提供"></a>项目属性通过 -P命令行选项提供</h2><p>对于下面的例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printMyProperties &lt;&lt;&#123;</span><br><span class="line">println myProperties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接执行 <code>gradle -q printMyProperties</code> 命令，会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:printMyProperties&apos;.</span><br><span class="line">&gt; Could not get unknown property &apos;myProperties&apos; for task &apos;:printMyProperties&apos; of type org.gradle.api.DefaultTask.</span><br></pre></td></tr></table></figure><p>这是因为myProperties属性没有定义，所以我们在调用gradle命令的时候可以通过 -P 命令来传参数，就可以把这个属性打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -P myProperties=&apos;this is -P params&apos;  printMyProperties</span><br></pre></td></tr></table></figure><h2 id="系统属性通过-D命令行选项提供"><a href="#系统属性通过-D命令行选项提供" class="headerlink" title="系统属性通过 -D命令行选项提供"></a>系统属性通过 -D命令行选项提供</h2><p>与在Java中类似的，我们在Gradle中也可以通过-D来定义JVM的系统参数，只是需要增加一些约定，每个通过-D 方式声明的属性前面都要以“org.gradle.project”为前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -D org.gradle.project.myProperties=&apos;this is -D params&apos;  printMyProperties</span><br></pre></td></tr></table></figure><h2 id="环境属性模式提供"><a href="#环境属性模式提供" class="headerlink" title="环境属性模式提供"></a>环境属性模式提供</h2><p>我们可以通过设置环境变量的形式来设置Project的属性。但是也要增加一些约定，例如每个属性前面都要加上一个<code>ORG_GRADLE_PROJECT_</code>的前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORG_GRADLE_PROJECT_propertyName=someValue</span><br></pre></td></tr></table></figure><p>当你再去执行printMyProperties这个task的时候就不用传参数了。</p><p><a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">下一篇</a>，我们会开始探索task的依赖，构建的生命周期等内容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习2——开始使用Gradle</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A02%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Gradle/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A02%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Gradle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果把Gradle当做脚本来学习，对于那么多的DSL配置，我们似乎难以下手。在这一点上，我认为邓凡平的<a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Android之Gradle</a>这篇文章讲的很好，把Gradle当做一个编程框架来学习，这篇文章可以让我们从一个不同的视角来学习和理解Gradle。</p><h1 id="Gradle-之hello-world"><a href="#Gradle-之hello-world" class="headerlink" title="Gradle 之hello world"></a>Gradle 之hello world</h1><p>新建一个build.gradle文件，然后输入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//task是一个任务，doLast 是一个action</span><br><span class="line">task helloWorld &#123;</span><br><span class="line">    println &apos;hello world!&apos;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;hello World! do last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入命令 <code>gradle helloWorld</code>，执行helloWorld这个task。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld //这个代表的是helloWold任务</span><br><span class="line">hello World! do last</span><br></pre></td></tr></table></figure><p>可以看到task中的内容正确的执行了，在task中 doLast是一个action，此外还有一个叫作doFirst的action。doFirst、doLast都是闭包。顾名思义就是再任务开始执行的开始和最后执行该闭包中的内容。</p><p>对于doLast这个action，可以使用一个简单的左移操作符来替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可以使用左移符号 &lt;&lt; 来简单的代表doLast</span><br><span class="line">task name &lt;&lt; &#123;</span><br><span class="line">    println &apos;this is doLast action&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Gradle的命令"><a href="#Gradle的命令" class="headerlink" title="Gradle的命令"></a>Gradle的命令</h1><p>Gradle的执行有很多有用的命令，运行gradle –help就可以查看这些命令。</p><h2 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p>-?, -h, –help 打印所有可用的命令行选项，包含描述信息<br>-b, –build-file gradle构建脚本的默认命名约定为build.gradle ,使用这个命令可以执行一个指定名字的构建脚本（比如，gradle -b test.gradle）。<br>–offline 可以在离线模式下构建，仅在本地缓存中检查依赖是否存在。</p><h2 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h2><p>-D, –system-prop Gradle是以一个JVM进程运行的。和所有的Java进行一样，你可以提供一个系统参数 (例如 -Dmyprop=myvalue)。<br>-P, –project-prop 项目参数是构建脚本中可用的变量，可以使用这个选项直接向构建脚本中传入参数(如 -Pmyprop=myvalue)。</p><h2 id="日志选项"><a href="#日志选项" class="headerlink" title="日志选项"></a>日志选项</h2><p>-i, –info 在默认设置中，Gradle构建不会提供大量的输出信息。通过这个选项可以将Gradle的日志级别改变到INFO以获得更多信息。<br>-s, –stacktrace 如果构建在运行中出现错误，-s选项在有异常抛出时会打印简短的堆栈跟踪信息，帮助你进行调试。<br>-q, –quiet 只在出错的时候打印信息</p><h2 id="帮助任务"><a href="#帮助任务" class="headerlink" title="帮助任务"></a>帮助任务</h2><ul><li>tasks ：显示项目中所有可运行的task，包括它们的描述信息。项目中应用的插件可能会提供一些额外的task。</li><li>properties：显示出项目中的所有可用的属性。某些属性是由Gradle的project对象提供的，project对象是一个构建的本质表现形式。其它的属性都是用户自行一的，要么来自于属性文件或者命令行选项，要么是直接在构建脚本重定义的。</li></ul><p>例如：</p><ol><li>gradle -q helloworld<br>表示静默执行helloworld任务 。-q 的意思是 quiet，也可以不带q</li><li>gradle -q tasks<br>列出gradle中的task</li><li>gradle -q tasks –all<br>列出gradle中更多的task</li></ol><p>当然了这个命令行我们不需要死记硬背，忘记怎么使用的时候，运行一下 <code>gradle --help</code>命令即可查阅相关的命令。</p><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>gradle有一个命令<code>--daemon</code>可以用来开启一个守护进程，这个守护进程以后台方式运行。开启完守护进程之后，下一次运行构建的将会变快，这是因为减少了启动Gradle的开销。</p><p>执行下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task helloWorld &#123;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">       println &apos;hello World! do first&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println &apos;hello world!&apos;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;hello World! do last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，我们使用<code>gradle helloWorld</code>命令，可以看一下执行的时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.787 secs</span><br></pre></td></tr></table></figure><p>然后我们使用命令 <code>gradle --daemon helloWorld</code> 运行构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 4.522 secs</span><br></pre></td></tr></table></figure><p>WTF，不是说开启守护进程，构建时间会减少吗，怎么还变多了？<br>不要急，我们再来运行一次 <code>gradle --daemon helloWorld</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">:helloWorld</span><br><span class="line">hello World! do first</span><br><span class="line">hello World! do last</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1.228 secs</span><br></pre></td></tr></table></figure><p>看到了没，这一次时间减少了很多。第一次构建时间变长是因为后台开启这个守护进程也是需要开销的，但是开启了守护进程之后我们就可以轻快的玩耍了。</p><p>需要注意的是：</p><ol><li>守护进程只会被创建一次</li><li>守护进程会在3小时空闲时间之后自动过期</li><li>想要重用守护进程，构建的时候要加上<code>--daemon</code>选项</li></ol><p><code>--no-daemon</code> 选项可以选择执行构建时不使用守护进程。<br><code>gradle --stop</code> 命令可以手动停止守护进程。</p><h1 id="Gradle-Wrapper-包装器"><a href="#Gradle-Wrapper-包装器" class="headerlink" title="Gradle Wrapper 包装器"></a>Gradle Wrapper 包装器</h1><p>在从Eclipse切换到Android Studio进行Android开发的时候，我在很长一段时间都不明白这个gradle Wrapper有什么作用。直到学习了Gradle的构建才了解到它的重要作用。<br>Gradle包装器是Gradle的核心特性，能够让机器在没有安装Gradle运行时的情况下运行Gradle构建，也可以让构建脚本运行在一个指定的Gradle版本上。<br>使用Wrapper被认为是最佳实践，这样在不同的机器上面，构建的版本就能够保证统一。使用了包装器的Gradle脚本非常适合作为自动化发布的一部分，比如持续集成。</p><h2 id="配置包装器"><a href="#配置包装器" class="headerlink" title="配置包装器"></a>配置包装器</h2><p>为了能够让项目下载压缩过的Gradle运行时文件，定义一个类型为Wrapper的任务，通过gradleVersion属性指定你想要使用的Gradle版本。<br>不要求该任务的名字为wrapper，任何名字都可以。但是这个名字在Gradle的在线文档中使用，是一个默认的约定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(type: Wrapper) &#123;</span><br><span class="line">    gradleVersion = &apos;3.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行任务 `gradle wrapper’ ，就会在构建脚本同级的目录下生成了包装器文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build.gradle*</span><br><span class="line">gradle/</span><br><span class="line">.gradle/</span><br><span class="line">gradlew*</span><br><span class="line">gradlew.bat</span><br></pre></td></tr></table></figure><p>gradle目录中的结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-44921bcf6fd57c9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在gradle-wrapper.properties文件中包含了Wrapper的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-bin.zip</span><br></pre></td></tr></table></figure><p>.gradle 是存放下载下来的gradle的目录。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-15d303a10d9db8cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".gradle中存放文件.png"></p><p>记住：只需在项目中运行一次gradle wrapper命令就可以了。而且通常情况下，我们最好把gradle wrapper文件提交到版本控制系统中去。</p><h2 id="使用包装器"><a href="#使用包装器" class="headerlink" title="使用包装器"></a>使用包装器</h2><p>作为包装器内容的一部分，它提供了一个命令执行脚本。对于 *nix系统，如Linux、Mac Os系统，它是一个叫做gradlew的shell脚本；对于Windows操作系统，它是gradle.bat。使用它们运行构建和使用已安装的Gradle运行时运行构建是一样的。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-a8ecf18fcbad57ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle生成的脚本.png"></p><p>对于android开发，假如我们在android studio中使用命令行工具 ，如clean任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean  //Mac OS</span><br><span class="line">gradlew clean //Windows</span><br></pre></td></tr></table></figure><p>更多信息可以查看官方文档<a href="https://docs.gradle.org/4.1/dsl/org.gradle.api.tasks.wrapper.Wrapper.html#org.gradle.api.tasks.wrapper.Wrapper:gradleVersion" target="_blank" rel="noopener">Wrapper</a>。</p><h1 id="Gradle构建块"><a href="#Gradle构建块" class="headerlink" title="Gradle构建块"></a>Gradle构建块</h1><p>每个Gradle构建都包含三个基本构建块：project、task、property。每个构建至少包含一个project，进而包含一个或者多个task。project和task暴露的属性可以用来控制构建。</p><p>Gradle使用的是领域驱动设计（DDD）的原理为其自己的领域构建软件建模。因此，在<strong>Gradle API中有相应的类来表示project和task</strong>。</p><blockquote><p>Gradle API中有相应的类来表示project和task。这一点是要明确的，Gradle中的脚本实际上是转为代码来执行的。</p></blockquote><h2 id="项目Project"><a href="#项目Project" class="headerlink" title="项目Project"></a>项目Project</h2><p>在Gradle术语中，一个项目（project）代表一个正在构建的组件，比如一个JAR文件，或一个想要完成的目标，如部署应用程序。<br>当构建进程启动后，Gradle基于build.gradle中的配置实例化org.gradle.api.Project接口，并且能够通过project变量使其隐式可用。</p><h2 id="任务Task"><a href="#任务Task" class="headerlink" title="任务Task"></a>任务Task</h2><p>任务动作 task action，定义了一个当任务执行时最小的工作单元。<br>任务依赖 task dependency，很多时候运行一个task之前需要运行另一个task。<br>Gradle task对应的API是org.gradle.api.Task 接口。</p><h2 id="属性-Property"><a href="#属性-Property" class="headerlink" title="属性 Property"></a>属性 Property</h2><p>每个Project和Task实例都提供了可以通过getter和setter方法访问的属性。一个属性可能是一个任务的描述或者项目的版本。<br>你也可以定义自己的属性。Gradle允许用户通过扩展属性自定义一些标量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了Gradle中task的基本使用、命令行的使用、包装器Wrapper的作用以及Gradle构建块的介绍。</p><p><a href="http://www.jianshu.com/p/434eba22561e" target="_blank" rel="noopener">下一篇</a>，我们会开始介绍Project和Task的属性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习1——Groovy基本介绍</title>
      <link href="/2017/10/14/Gradle%E5%AD%A6%E4%B9%A01%E2%80%94%E2%80%94Groovy%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/10/14/Gradle%E5%AD%A6%E4%B9%A01%E2%80%94%E2%80%94Groovy%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>学习Gradle，前前后后总结了一些内容，然后整理出了一个系列，共计10篇文章，与大家分享：</p><ol><li><a href="http://www.jianshu.com/p/0bde7097abaf" target="_blank" rel="noopener">Groovy基本介绍</a></li><li><a href="http://www.jianshu.com/p/158851436e82" target="_blank" rel="noopener">开始使用Gradle</a></li><li><a href="http://www.jianshu.com/p/434eba22561e" target="_blank" rel="noopener">自定义属性</a></li><li><a href="http://www.jianshu.com/p/60bf794cdf91" target="_blank" rel="noopener">深入了解Task和构建生命周期</a></li><li><a href="http://www.jianshu.com/p/e7e3629835a6" target="_blank" rel="noopener">Gradle增量式构建</a></li><li><a href="http://www.jianshu.com/p/bb13bfb8d1b0" target="_blank" rel="noopener">挂接到构建生命周期</a></li><li><a href="http://www.jianshu.com/p/5a413815a7ae" target="_blank" rel="noopener">编写和使用自定义Task</a></li><li><a href="http://www.jianshu.com/p/e01d647b1c75" target="_blank" rel="noopener">依赖管理</a></li><li><a href="http://www.jianshu.com/p/62c1f3ca380c" target="_blank" rel="noopener">多项目构建</a></li><li><a href="http://www.jianshu.com/p/337e8d4f1817" target="_blank" rel="noopener">自定义Gradle插件</a></li></ol><blockquote><p>学习本系列前可以下载相关的github项目<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">gradleLearnDemo</a>。<br>地址：<a href="https://github.com/sososeen09/gradleLearnDemo" target="_blank" rel="noopener">https://github.com/sososeen09/gradleLearnDemo</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gradle脚本使用的是Groovy语言，Groovy也是基于JVM的一种动态语言，基于Java并扩展了Java语言。Groovy会使写Java程序就要写脚本一样简单，写完就可以执行，所以看起来也像是一门脚本语言。Groovy内部会把代码编译为Java class文件然后启动虚拟机来执行，这些过程，我们开发人员是不用管的。</p><p>Gradle是一种DSL，也即是 Domain Specific Language 领域特定语言。说白了DSL就是一种行话，这个语言在Gradle中可以识别，在其它地方就用不了了。</p><p>学习Gradle，我们不必要精通Groovy语言，但还是需要了解一些Groovy的基本知识，比如def关键字、返回语句、字符串、集合、闭包等。下面，我们就来简单介绍一下。</p><h1 id="Groovy代码的执行"><a href="#Groovy代码的执行" class="headerlink" title="Groovy代码的执行"></a>Groovy代码的执行</h1><p>前面我们说了，Groovy很像是一门脚本语言，我们来看一下怎么回事。<br>创建一个HelloGroovy.groovy文件，里面就一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println &apos;hello groovy!&apos;</span><br></pre></td></tr></table></figure><p>然后执行命令<code>groovy HelloGroovy.groovy</code>,得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello groovy!</span><br></pre></td></tr></table></figure><p>是不是很简单，很像脚本语言。</p><h1 id="Groovy中的字符串"><a href="#Groovy中的字符串" class="headerlink" title="Groovy中的字符串"></a>Groovy中的字符串</h1><p>Groovy 对字符串支持相当强大，可以使用多种字符串，包括单引号、双引号、三引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str=&apos;hello groovy!&apos;</span><br><span class="line"></span><br><span class="line">String getStr()&#123;</span><br><span class="line">&apos;hello groovy!&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str1=&apos;hello&apos;</span><br><span class="line">String str2=&apos; groovy!&apos;</span><br><span class="line">println &apos;hello groovy!&apos;</span><br><span class="line">println &quot;hello groovy!&quot;</span><br><span class="line">println &quot;$str&quot;</span><br><span class="line">println getStr()</span><br><span class="line">println &quot;$&#123;str1+str2&#125;&quot;</span><br><span class="line">println &apos;hello $str2&apos;  //单引号，直接打印内容</span><br></pre></td></tr></table></figure><p>使用单引号会直接打印字符串的内容，不会对美元$符号的内容进行转义。使用双引号的功能更加强大，字符串中使用美元符$后面可以跟字符串变量，如<code>&quot;$str&quot;</code>，也可以跟表达式如 <code>&quot;${str1+str2}&quot;</code>，如果跟表达式，记得要用{}括起来。</p><p>三引号用的比较少，可以支持字符串内容换行，我们了解一下就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println &apos;&apos;&apos; aa</span><br><span class="line">bb</span><br><span class="line"></span><br><span class="line">cc</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><p>我们在getStr()方法中并没有使用return语句，这是因为Groovy默认是把最后一行的执行结果进行返回。如果你需要返回的结果正好是最后一行，就可以省略return。</p><p>另外，在Groovy中，语句的最后的<code>“；”</code>号是可以省略的。还有一点就是Groovy中在调用函数的时候可以不加括号，比如，<code>println (&quot;hello&quot;)</code> 与 <code>println &quot;hello&quot;</code> 的意思是一样的</p><h1 id="def关键字"><a href="#def关键字" class="headerlink" title="def关键字"></a>def关键字</h1><p>def关键字很像是Java中的Object，在定义变量或者方法的时候使用def，如果没有指定具体的参数类型。在运行阶段Groovy会自动判断参数类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def a = 1, b = 2</span><br><span class="line">def str = &quot;hello&quot;</span><br><span class="line">println a + b</span><br><span class="line">println str</span><br></pre></td></tr></table></figure><p>实际上我们在定义变量的时候是可以省略def的，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">str = &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>但是，最好还是加上def，这是一种好的实践。<br>你还可以在定义变量的时候，在def后面再加上具体的参数类型，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def int a = 1</span><br><span class="line">def String str = &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>使用def定义方法的返回值类型，可以返回任意类型。如果指定了具体的返回值类型，就要正确的返回，否则会报错。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Groovy的基本类型与Java一样。对于集合类型的数据，List的具体实现是ArrayList。Map集合的具体实现是LinkedHashMap。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>下面我们来简单了解一下如果使用。List使用一个 []中括号来括起来来表示的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义一个List</span><br><span class="line">def lists=[&apos;groovy&apos;,&apos;gradle&apos;,&apos;android&apos;]</span><br><span class="line"></span><br><span class="line">//打印集合size</span><br><span class="line">println lists.size</span><br><span class="line"></span><br><span class="line">//打印集合中的数据</span><br><span class="line">lists.each&#123;</span><br><span class="line">list-&gt;println list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出集合中的数据直接用索引就可以了。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert lists[0]==&apos;groovy&apos;</span><br></pre></td></tr></table></figure><p>对于集合中变量的存储，我们是不需要担心数组越界的，如果索引超过当前长度，List会自动在该索引中添加元素。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists[100]=100</span><br><span class="line">println lists.size</span><br><span class="line">println lists[99]</span><br></pre></td></tr></table></figure><p>打印结果，会发现集合的size变为101。index为99的集合数据为null。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map的表示就是用中括号[]括起来的 key:value形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def map=[&quot;key1&quot;:&quot;hello&quot;,&quot;key2&quot;:&quot;groovy&quot;,&quot;key3&quot;:true]</span><br><span class="line">println map.size()</span><br><span class="line"></span><br><span class="line">map.forEach&#123;</span><br><span class="line">key,value-&gt;</span><br><span class="line">println &quot;$key :$value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">key1 :hello</span><br><span class="line">key2 :groovy</span><br><span class="line">key3 :true</span><br></pre></td></tr></table></figure><p>获取Map的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println map.&apos;key1&apos;</span><br><span class="line">println map[&apos;key1&apos;]</span><br></pre></td></tr></table></figure><p>添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.&apos;key4&apos;=&apos;android&apos;</span><br><span class="line">println map[&apos;key4&apos;]</span><br></pre></td></tr></table></figure><h1 id="Groovy的类"><a href="#Groovy的类" class="headerlink" title="Groovy的类"></a>Groovy的类</h1><p>Groovy中的类与Java中的类的写法类似，但是要更简洁一些。<br>我们在Hello.groovy文件中写一个HelloWorld类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorld&#123;</span><br><span class="line">String msg=&apos;hello world&apos;</span><br><span class="line">    </span><br><span class="line">    HelloWorld()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorld(String msg)&#123;</span><br><span class="line">this.msg=msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sayHello()&#123;</span><br><span class="line">println msg</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def say=&#123;</span><br><span class="line">new HelloWorld(&apos;hello&apos;).sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getMsg=&#123;</span><br><span class="line">new HelloWorld().msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say()</span><br><span class="line">println getMsg()</span><br></pre></td></tr></table></figure><p>调用<code>groovy Hello.groovy</code> 命令执行该脚本，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>当然了，我们也可以写一个单独的HelloWorld类，带上包名，然后在其它地方导包使用，就像Java那样。有关于Groovy类的使用，我们后面还会讲到，这里就不赘述了。<br>总结一下Groovy的类相比Java的一些不同，或者说是优化的一些地方：</p><ul><li>表达式后面的分号是可选的</li><li>每个类、构造方法和方法默认是public的</li><li>在Groovy中，方法体中的最后一个表达式的值会被作为返回值。这意味着return语句是可选的</li><li>Groovy编译器自动加上getter/setter方法，所以不需要自己去书写</li><li>类的属性可以通过点号来获取，看起来好像它们在Java中是public的，在底层Groovy调用的是自动生成的getter/setter方法。</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包<a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html" target="_blank" rel="noopener">Closure</a>，在Groovy中是很重要的一种数据类型。闭包实际上就是一段代码块，需要用{}包括起来。前面我们在讲解一些例子的时候已经用到了闭包，我们再来看一下闭包的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义一个闭包 ，记得要用&#123;&#125;包裹起来</span><br><span class="line">def aClosure=&#123;</span><br><span class="line">int a,int b-&gt; //-&gt; 箭头前面代表的是参数，后面是执行语句</span><br><span class="line">a+b  //返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println aClosure(1,2)</span><br></pre></td></tr></table></figure><p>结果为 3。</p><p>闭包的参数类型也可以不指定，在运行期有Groovy自动推断，比如下面这个例子，执行起来也是没有问题的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def bClosure=&#123;</span><br><span class="line"> a,b-&gt;</span><br><span class="line">a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println bClosure(1,2)</span><br></pre></td></tr></table></figure><p>闭包也可以没有参数,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def aa=&#123;</span><br><span class="line">println &quot;this is a Closure&quot;</span><br><span class="line">&#125;</span><br><span class="line">aa()</span><br></pre></td></tr></table></figure><p>总结一下，闭包的类型有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. def closureNama =&#123;params -&gt; code&#125; </span><br><span class="line">2. def closureName= &#123;code&#125; 没有参数的时候就没有箭头 -&gt;</span><br></pre></td></tr></table></figure><p>闭包的调用有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 闭包对象.call(参数)</span><br><span class="line">2. 闭包对象(参数)</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">aClosure(1,2)</span><br><span class="line">aClosure.call(1,2)</span><br></pre></td></tr></table></figure><p>需要注意一点，闭包如果没有参数的话，其隐含了一个参数是 <code>it</code>。<br>和this的作用类似，代表的是传入闭包的参数。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sayHello=&#123;&quot;hello $&#123;it&#125;&quot;&#125;</span><br><span class="line">println sayHello(&quot;Jim&quot;)</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">def sayHello=&#123;it-&gt;&quot;hello $&#123;it&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然了，如果闭包显示的指明了无参数，则在调用闭包的时候不能传参数，否则会报错。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def noParams=&#123;-&gt;println &quot;noParams&quot;&#125;</span><br><span class="line">noParams();</span><br><span class="line">//下面的代码执行会报错</span><br><span class="line">//noParams(1)</span><br></pre></td></tr></table></figure></p><p><strong>闭包返回值</strong></p><p>闭包总是会返回一个值。返回值是闭包的最后一条语句的值（如果没有显式的return语句），或者是可执行的return 语句的值。如果闭包的最后一条语句没有值就返回null。如之前举得Hello.groovy中的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getMsg=&#123;</span><br><span class="line">new HelloWorld().msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包作为方法参数</strong></p><p>闭包也可以作为方法参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int increment(Closure closure,int count)&#123;</span><br><span class="line">closure()+count</span><br><span class="line">&#125;</span><br><span class="line">//断言，如果为true就正常执行，如果为false，就会报错</span><br><span class="line">assert increment(&#123;1+1&#125;,1)==3</span><br></pre></td></tr></table></figure><p><strong>闭包委托</strong></p><p>闭包代码是在委托的闭包上执行。默认的，这个委托就是闭包的所有者。比如你在Groovy脚本中定义了一个闭包，那么所有者就是一个groovy.lang.Script实例。闭包的隐式变量delegate 允许你重新定义默认的所有者。</p><p>例如：</p><pre><code>class Test {    def x = 30    def y = 40    def run() {        def data = [ x: 10, y: 20 ]        def cl = {              y = x + y         }        cl.delegate = data        cl.resolveStrategy = Closure.DELEGATE_FIRST        cl()        assert x == 30        assert y == 40        assert data == [x:10, y:30]    }}new Test().run()</code></pre><p>上面例子中闭包c1的委托变为data，闭包的resolveStrategy在默认情况下是OWNER_FIRST，即它会先查找闭包的owner（在本例中指的就是Test对象本身），如果owner存在，则在owner上执行闭包中的代码。这里我们将其设置成了DELEGATE_FIRST，即该闭包会首先查找delegate（本例中即data），如果找不到再去找owner。resolveStrategy还有其它的一些情况，具体的可以查看文档中的例子，相信当你看到这些例子后，会对闭包委托有一个清晰的认识。</p><ul><li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#DELEGATE_FIRST" target="_blank" rel="noopener">Closure.DELEGATE_FIRST</a></li><li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#DELEGATE_ONLY" target="_blank" rel="noopener">Closure.DELEGATE_ONLY</a></li><li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#OWNER_FIRST" target="_blank" rel="noopener">Closure.OWNER_FIRST</a></li><li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#OWNER_ONLY" target="_blank" rel="noopener">Closure.OWNER_ONLY</a></li><li><a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html#TO_SELF" target="_blank" rel="noopener">Closure.TO_SELF</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>限于篇幅和本系列的主题，本文简单介绍了Groovy的一些语法和数据结构，这对于学习Gradle会有一些帮助。在后面Gradle的学习过程中，如果对Groovy的一些Api不熟悉可以查看<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="noopener">Groovy的Api文档</a>，我们没必要死记硬背这个Api，掌握学习的方法更加重要，对吗？</p><p><a href="http://www.jianshu.com/p/158851436e82" target="_blank" rel="noopener">下一篇</a>，我们就正式进入Gradle部分的学习了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">Groovy文档</a></li><li><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Android之Gradle</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析Activity中View的生命周期方法回调</title>
      <link href="/2017/07/22/%E6%B5%85%E6%9E%90Activity%E4%B8%ADView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/"/>
      <url>/2017/07/22/%E6%B5%85%E6%9E%90Activity%E4%B8%ADView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity有生命周期，同样的，View从添加到界面到从界面中移除也有一个生命周期，在<a href="https://developer.android.google.cn/reference/android/view/View.html" target="_blank" rel="noopener">官方文档</a>中介绍了自定义View需要重写的一些方法，可以认为这些方法就是View的生命周期方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-82ee9f1ceb9c6b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的生命周期方法.png"></p><p>本文就介绍一下这些方法调用的顺序流程以及与Activity的生命周期结合之后的顺序流程。</p><h1 id="View的生命周期"><a href="#View的生命周期" class="headerlink" title="View的生命周期"></a>View的生命周期</h1><h2 id="从Activity启动到退出，这个View-的过程是这样的。"><a href="#从Activity启动到退出，这个View-的过程是这样的。" class="headerlink" title="从Activity启动到退出，这个View 的过程是这样的。"></a>从Activity启动到退出，这个View 的过程是这样的。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/ViewLifeTestView: ViewLifeTestView: construct </span><br><span class="line">D/ViewLifeTestView: onFinishInflate: </span><br><span class="line">D/ViewLifeTestView: onAttachedToWindow: </span><br><span class="line">D/ViewLifeTestView: onWindowVisibilityChanged: visiable</span><br><span class="line">D/ViewLifeTestView: onMeasure: </span><br><span class="line">D/ViewLifeTestView: onMeasure: </span><br><span class="line">D/ViewLifeTestView: onSizeChanged: </span><br><span class="line">D/ViewLifeTestView: onLayout: </span><br><span class="line">D/ViewLifeTestView: onDraw: </span><br><span class="line">D/ViewLifeTestView: onWindowFocusChanged: true</span><br><span class="line">D/ViewLifeTestView: onWindowVisibilityChanged: gone</span><br><span class="line">D/ViewLifeTestView: onWindowFocusChanged: false</span><br><span class="line">D/ViewLifeTestView: onDetachedFromWindow:</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2083810-e496916704fa4dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><strong>在Activity的onCreate()方法中调用setContentView方法，Activity显示到界面时的View的回调</strong></p><ol><li>构造方法，这是肯定的，View也是一个Java类。</li><li>onFinishInflate，这个一般是通过LayoutInflater进行填充的时候会走这个方法。如果我们是直接在代码中new出来的View进行添加，是不会走这个方法的。</li><li>onAttachedToWindow，这个方法表明现在这个View已经跟它对应的Window已经绑定了</li><li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.VISIBLE，代表View所在的Window已经可见了。</li><li>onMeasure，开始测量。我们发现，这个measure过程是在Window可见的情况下才会去调用了，仔细想想这个也不难理解，如果你都不准备显示，我何必去花精力测量你呢。这个测量过程可能会多次调用。</li><li>onSizeChanged ，测量之后会回调这个方法。onSizeChanged，顾名思义就是当尺寸发生变化的时候会调用。一般是第一次测量之后调用，后面再测量，如果尺寸没变化就不会再去调用了。</li><li>onLayout，测量时候就进行布局，这个时候如果是View的话一般不用去管，因为具体放在哪个位置是由父控件去控制的，如果是ViewGroup，就需要去确定子View的位置。</li><li>onDraw，确定完位置和宽高，就可以进行绘制了。</li><li>onWindowFocusChanged(boolean hasWindowFocus)，为true这个说明View所绑定的Window开始获取焦点</li></ol><p><strong>当按back键退出当前Activity后，走下面几个方法</strong></p><ol><li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.GONE，此时Window已经不可见了</li><li>onWindowFocusChanged(boolean hasWindowFocus)，这个也变为false，说明已经没有焦点了。有一点比较奇怪，为什么是先不可见才是没有焦点的呢？</li><li>onDetachedFromWindow， 当前View与它对应的Window解除绑定。</li></ol><h1 id="Activity和View的生命周期结合"><a href="#Activity和View的生命周期结合" class="headerlink" title="Activity和View的生命周期结合"></a>Activity和View的生命周期结合</h1><p>当Activity和View的生命周期结合，我们会发现一些有意思的东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/ViewLifeTestActivity: onCreate: </span><br><span class="line">D/ViewLifeTestActivity: onWindowAttributesChanged: </span><br><span class="line">...</span><br><span class="line">D/ViewLifeTestView: ViewLifeTestView: construct </span><br><span class="line">D/ViewLifeTestView: onFinishInflate: </span><br><span class="line">D/ViewLifeTestActivity: onStart: </span><br><span class="line">D/ViewLifeTestActivity: onWindowAttributesChanged: </span><br><span class="line">D/ViewLifeTestActivity: onResume: </span><br><span class="line">D/ViewLifeTestActivity: onAttachedToWindow: </span><br><span class="line">D/ViewLifeTestView: onAttachedToWindow: </span><br><span class="line">D/ViewLifeTestView: onWindowVisibilityChanged: visiable</span><br><span class="line">D/ViewLifeTestView: onMeasure: </span><br><span class="line">D/ViewLifeTestView: onMeasure: </span><br><span class="line">D/ViewLifeTestView: onSizeChanged: </span><br><span class="line">D/ViewLifeTestView: onLayout: </span><br><span class="line">D/ViewLifeTestView: onDraw: </span><br><span class="line">D/ViewLifeTestActivity: onWindowFocusChanged hashFocus: true</span><br><span class="line">D/ViewLifeTestView: onWindowFocusChanged: true</span><br><span class="line">D/ViewLifeTestView: onTouchEvent: </span><br><span class="line">D/ViewLifeTestActivity: onPause: </span><br><span class="line">D/ViewLifeTestView: onWindowVisibilityChanged: gone</span><br><span class="line">D/ViewLifeTestActivity: onWindowFocusChanged hashFocus: false</span><br><span class="line">D/ViewLifeTestView: onWindowFocusChanged: false</span><br><span class="line">D/ViewLifeTestActivity: onStop: </span><br><span class="line">D/ViewLifeTestActivity: onDestroy: </span><br><span class="line">D/ViewLifeTestView: onDetachedFromWindow: </span><br><span class="line">D/ViewLifeTestActivity: onDetachedFromWindow:</span><br></pre></td></tr></table></figure><p><strong>结合与Activity的启动过程可以看到</strong></p><ol><li><strong>Activity</strong> 调用onCreate方法，这个时候我们setContentView加载了带View的布局</li><li><strong>Activity</strong> 调用onWindowAttributesChanged 方法，而且这个方法连续调用多次</li><li><figure class="highlight plain"><figcaption><span>``` 调用构造方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">4. ``` View ``` 调用onFinishInflate方法，说明这个时候View已经填充完毕，但是这个时候还没开始触发绘制过程</span><br><span class="line">5. **Activity** 调用onstart方法</span><br><span class="line">6. **Activity** 再次调用 onWindowAttributesChanged 方法，说明这个方法在onResume之前会多次调用</span><br><span class="line">7. **Activity** 调用onResume，我们一般认为当Activity调用onResume的时候，整个Activit已经可以和用户进行交互了，但事实上可能并不是这样，后面解释原因。</span><br><span class="line">8. **Activity** 调用onAttachedToWindow，说明跟Window进行了绑定。发现了吗，Activity在onResume之后才跟Window进行了绑定。</span><br><span class="line">9. ``` View ``` 调用onAttachedToWindow，View开始跟Window进行绑定，这个过程肯定是在Activity绑定之后才进行的。</span><br><span class="line">10. ``` View ``` 调用 onWindowVisibilityChanged(int visibility)，参数变为 `View.VISIABLE`，说明Window已经可见了，这个时候我们发现一个问题就是其实onResume的时候似乎并不代表Activity中的View已经可见了。</span><br><span class="line">11. ``` View ``` 调用onMeasure，开始测量</span><br><span class="line">12. ``` View ``` 调用onSizeChanged，表示测量完成，尺寸发生了变化</span><br><span class="line">13. ``` View ``` 调用onLayout，开始摆放位置</span><br><span class="line">14. ``` View ``` 调用 onDraw，开始绘制</span><br><span class="line">15. **Activity** 调用onWindowFocusChanged(boolean hasFocus)，此时为true，代表窗体已经获取了焦点</span><br><span class="line">16. ``` View ``` 调用 onWindowFocusChanged(boolean hasWindowFocus)，此时为true，代表当前的控件获取了Window焦点，当调用这个方法后说明当前Activity中的View才是真正的可见了。</span><br><span class="line"></span><br><span class="line">**当退出当前的Activity的时候**</span><br><span class="line"></span><br><span class="line">1.  **Activity** 调用 onPause</span><br><span class="line">2. ``` View ``` 调用 onWindowVisibilityChanged(int visibility)，参数变为 `View.GONE`，View中对应的Window隐藏</span><br><span class="line">3.  **Activity** 调用onWindowFocusChanged(boolean hasFocus)，此时为false，说明Actvity所在的Window已经失去焦点</span><br><span class="line">4.  **Activity** 调用 onStop，此时Activity已经切换到后台</span><br><span class="line">5.  **Activity** 调用 onDestory，此时Activity开始准备销毁，实际上调用onDestory并不代表Activity已经销毁了。</span><br><span class="line">6. ``` View ``` 调用 onDetachedFromWindow，此时View 与Window解除绑定</span><br><span class="line">7.  **Activity** 调用 onDetathedFromWindow ，此时Activity 与Window 解除绑定</span><br><span class="line"></span><br><span class="line">当View进行与Window解除绑定之后，View即将被销毁。我们可以在 View 的  `onDetachedFromWindow` 方法中可以做一些资源的释放，防止内存泄漏。</span><br><span class="line"></span><br><span class="line"># Activity的onWindowFocusChanged(boolean hasFocus)</span><br><span class="line"></span><br><span class="line">从上面的分析我们可以知道，一个Activity启动后onCreate、onStart、onResume等过程后，Activity并不是真正可见的，只有当 onWindowFocusChanged 方法最后调用并且参数为true的时候Activity才是真正的可见，这个时候才可以和用户进行交互。</span><br><span class="line"></span><br><span class="line">我们可以这 onWindowFocusChanged 可以做一些事情。比如， 获取布局中的控件的尺寸。</span><br><span class="line"></span><br><span class="line">从 Activity 中的 onWindowFoucusChanged 方法介绍来看，当包含 View的 Window 获得或者失去焦点就会调用这个方法。而且要注意，它和View的焦点是有区别的。为了接收键盘事件，View和Window都必须获得焦点。而当一个显示在你的Window上面的Window获取输入焦点的时候，你自己的Window失去了焦点，但是这个View本身的焦点不会改变。例如，弹出一个PopopWindow。</span><br><span class="line"></span><br><span class="line">下面是 Activity 的 `onWindowFocusChanged` 方法介绍。</span><br></pre></td></tr></table></figure></li></ol><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>/**</p><ul><li>Called when the window containing this view gains or loses focus.  Note</li><li>that this is separate from view focus: to receive key events, both</li><li>your view and its window must have focus.  If a window is displayed</li><li>on top of yours that takes input focus, then your own window will lose</li><li>focus but the view focus will remain unchanged.<br>*</li><li>@param hasWindowFocus True if the window containing this view now has</li><li>focus, false otherwise.<br>*/<br>public void onWindowFocusChanged(boolean hasWindowFocus) {<br>InputMethodManager imm = InputMethodManager.peekInstance();<br>if (!hasWindowFocus) {<br>if (isPressed()) {<br>  setPressed(false);<br>}<br>if (imm != null &amp;&amp; (mPrivateFlags &amp; PFLAG_FOCUSED) != 0) {<br>  imm.focusOut(this);<br>}<br>removeLongPressCallback();<br>removeTapCallback();<br>onFocusLost();<br>} else if (imm != null &amp;&amp; (mPrivateFlags &amp; PFLAG_FOCUSED) != 0) {<br>imm.focusIn(this);<br>}<br>refreshDrawableState();<br>}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 Activity 的 `onResume`  方法中，可以看到有这么一段注释。意思就是提醒大家 这个`onResume` 并不是提醒你这个Activty对用户可见的最佳指示器。例如一个系统Window如键盘可能是处在前面。采用```onWindowFocusChanged```可以确定当前的Activity对用户可见并且是可交互的。</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or</li><li>{@link #onPause}, for your activity to start interacting with the user.</li><li>This is a good place to begin animations, open exclusive-access devices</li><li>(such as the camera), etc.<br>*</li><li><p>Keep in mind that onResume is not the best indicator that your activity</p></li><li>is visible to the user; a system window such as the keyguard may be in</li><li>front.  Use {@link #onWindowFocusChanged} to know for certain that your</li><li>activity is visible to the user (for example, to resume a game).<br>*</li><li><p><em>Derived classes must call through to the super class’s</em></p></li><li>implementation of this method.  If they do not, an exception will be</li><li>thrown.<p></p></li></ul><p>```</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>熟知 View 的生命周期方法，可加深我们对于View的理解，在开发中也可以根据这个生命周期方法的回调时机来写出更加合理高效的自定义View，例如在 View 的 <code>onDetachedFromWindow</code> 方法中释放资源。</li><li>Activity还有其它的生命周期方法，比如 <code>onSaveInstanceState(Bundle outState)</code> ， <code>onRestoreInstanceState(Bundle savedInstanceState)</code> 等，限于篇幅和主题，本文并没有介绍这些方法，但是其实这些方法在 Activity 的生命周期方法中也是很重要的。</li><li>通常认为Activity的 <code>onResume</code> 方法调用之后，就可以与用户交互，通过本文的分析可知，这种说法并不准确。只有在 Activity 的 <code>onWindowFocusChanged(boolean hasFocus)</code> 调用，并且参数为true的时候，才是真正可以和用户交互的时机。</li><li>Activity 和 View 的很多生命周期回调方法都牵涉到 Window，这个Window 是Android 系统中的一个抽象类，它有一个唯一的子类叫作 PhoneWindow，  它具体有什么作用，在以后的文章中会介绍到它。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>采用Gson解析含有多种JsonObject的复杂Json</title>
      <link href="/2017/06/19/%E9%87%87%E7%94%A8Gson%E8%A7%A3%E6%9E%90%E5%90%AB%E6%9C%89%E5%A4%9A%E7%A7%8DJsonObject%E7%9A%84%E5%A4%8D%E6%9D%82Json/"/>
      <url>/2017/06/19/%E9%87%87%E7%94%A8Gson%E8%A7%A3%E6%9E%90%E5%90%AB%E6%9C%89%E5%A4%9A%E7%A7%8DJsonObject%E7%9A%84%E5%A4%8D%E6%9D%82Json/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文对应的项目是<a href="https://github.com/sososeen09/MultiTypeJsonParser" target="_blank" rel="noopener">MultiTypeJsonParser</a> ，项目地址 <a href="https://github.com/sososeen09/MultiTypeJsonParser" target="_blank" rel="noopener">https://github.com/sososeen09/MultiTypeJsonParser</a></p></blockquote><h1 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h1><p>使用 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a> 去解析 json 应该是很常见的，大部分的情况下我们只要创建一个 Gson 对象，然后根据 json 和对应的 Java 类去解析就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new Gson();</span><br><span class="line">Person person = gson.form(json,Person.class);</span><br></pre></td></tr></table></figure><p>但是对于比较复杂的 json，比如下面这种， attributes 对应的 jsonObject 中的字段是完全不一样的，这个时候再简单的用上面的方法就解析不了了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;address&quot;,</span><br><span class="line">            &quot;attributes&quot;: &#123;</span><br><span class="line">                &quot;street&quot;: &quot;NanJing Road&quot;,</span><br><span class="line">                &quot;city&quot;: &quot;ShangHai&quot;,</span><br><span class="line">                &quot;country&quot;: &quot;China&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;name&quot;,</span><br><span class="line">            &quot;attributes&quot;: &#123;</span><br><span class="line">                &quot;first-name&quot;: &quot;Su&quot;,</span><br><span class="line">                &quot;last-name&quot;: &quot;Tu&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，我们说一步到位的方式解决不了，但用一点笨方法还是可以的。比如先手动解析拿到 <strong>attributes</strong> 对应的 jsonObject，根据与它同级 <strong>type</strong> 对应的 <strong>value</strong> 就可以判断这一段 jsonObject 对应的 Java 类是哪个，最后就采用 <figure class="highlight plain"><figcaption><span>方法解析出 **attributes** 对应的 Java 对象。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>ListInfoWithType listInfoWithType = new ListInfoWithType();</p><p>//创建 org.json 包下的 JSONObject 对象<br>JSONObject jsonObject = new JSONObject(TestJson.TEST_JSON_1);<br>int total = jsonObject.getInt(“total”);</p><p>//创建 org.json 包下的 JSONArray 对象<br>JSONArray jsonArray = jsonObject.getJSONArray(“list”);<br>Gson gson = new Gson();<br>List<attributewithtype> list = new ArrayList&lt;&gt;();</attributewithtype></p><p>//遍历<br>for (int i = 0; i &lt; jsonArray.length(); i++) {<br>    JSONObject innerJsonObject = jsonArray.getJSONObject(i);<br>    Class&lt;? extends Attribute&gt; clazz;<br>    String type = innerJsonObject.getString(“type”);<br>    if (TextUtils.equals(type, “address”)) {<br>        clazz = AddressAttribute.class;<br>    } else if (TextUtils.equals(type, “name”)) {<br>        clazz = NameAttribute.class;<br>    } else {<br>        //有未知的类型就跳过<br>        continue;<br>    }<br>    AttributeWithType attributeWithType = new AttributeWithType();</p><p>//采用Gson解析<br>    Attribute attribute = gson.fromJson(innerJsonObject.getString(“attributes”), clazz);<br>    attributeWithType.setType(type);<br>    attributeWithType.setAttributes(attribute);<br>    list.add(attributeWithType);<br>}</p><p>listInfoWithType.setTotal(total);<br>listInfoWithType.setList(list);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然这样能实现整个 json 的反序列化，但是这种方式比较麻烦，而且一点也不优雅，如果项目中存在很多这样的情况，就会做很多重复的体力劳动。</span><br><span class="line">如何更优雅、更通用的解决这类问题，在网上没有找到答案，只好去深入研究一下Gson了。带着这样的目的，翻看了[Gson的文档](https://github.com/google/gson/blob/master/UserGuide.md)，发现了一句话</span><br><span class="line">&gt; Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.</span><br><span class="line"></span><br><span class="line">这句话说 Gson 可以处理任意的 Java 对象。那么对于上面讲的那种反序列化情况来讲， Gson 应该也能做到。通过研究 Gson 的文档，发现可以通过自定义JsonDeserializer的方式来实现解析这种 jsonObject 类型不同的情况。</span><br><span class="line"></span><br><span class="line">我们知道，大部分情况下 Gson 是通过直接 **new** 出来的方式来创建，不过也可以采用 **GsonBuilder** 这个类去生成 Gson。</span><br></pre></td></tr></table></figure></p><p>  Gson gson = new GsonBuilder()<br>   .registerTypeAdapter(Id.class, new IdTypeAdapter())<br>   .enableComplexMapKeySerialization()<br>   .serializeNulls()<br>   .setDateFormat(DateFormat.LONG)<br>   .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)<br>   .setPrettyPrinting()<br>   .setVersion(1.0)<br>   .create();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**GsonBuilder** 通过 **registerTypeAdapter()**方法，对目标类进行注册。当序列化或者反序列化目标类的时候就会调用我们注册的typeAdapter， 这样就实现了人工干预 Gson 的序列化和反序列化过程。</span><br><span class="line"></span><br><span class="line"> GsonBuilder 的 registerTypeAdapte() 方法的第二个参数是 Object 类型，也就意味着我们可以注册多种类型的 typeAdapter，目前支持的类型有 JsonSerializer、JsonDeserializer、InstanceCreator、TypeAdapter。</span><br></pre></td></tr></table></figure><p>  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过一番捣鼓，写了一个工具类，对于上面的那个复杂 json，用了不到10行代码就搞定，而且比较优雅和通用。</span><br></pre></td></tr></table></figure></p><p>MultiTypeJsonParser<attribute> multiTypeJsonParser = new MultiTypeJsonParser.Builder<attribute>()<br>        .registerTypeElementName(“type”)<br>        .registerTargetClass(Attribute.class)<br>        .registerTargetUpperLevelClass(AttributeWithType.class)<br>        .registerTypeElementValueWithClassType(“address”, AddressAttribute.class)<br>        .registerTypeElementValueWithClassType(“name”, NameAttribute.class)<br>        .build();</attribute></attribute></p><p>ListInfoWithType listInfoWithType = multiTypeJsonParser.fromJson(TestJson.TEST_JSON_1, ListInfoWithType.class);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本文就简单分析一下如何通过自定义 JsonDeserializer 来实现一个通用的工具类用于解析复杂类型 json。对于以后碰到相似问题，这种处理方法可以提供一种解决问题的思路。具体的代码和实例，可以查看[项目](https://github.com/sososeen09/MultiTypeJsonParser)。如果对您的思路有一些启发，欢迎交流和Star。</span><br><span class="line"></span><br><span class="line"># JsonDeserializer介绍</span><br><span class="line"></span><br><span class="line"> JsonDeserializer 是一个接口，使用的时候需要实现这个接口并在 GsonBuilder 中对具体的类型去注册。当反序列化到对应的类的时候就会调用这个自定义 JsonDeserializer 的 deserialize() 方法。下面对这个方法的几个参数做一下解释，以便于更好的理解Gson解析的过程。</span><br></pre></td></tr></table></figure></p><p>public interface JsonDeserializer<t> {<br>  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)<br>      throws JsonParseException;<br>}</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JsonElement </span><br><span class="line"></span><br><span class="line">  JsonElement代表 在 Gson 中的代表一个元素。它是一个抽象类，有4个子类：JsonObject、JsonArray、JsonPrimitive、JsonNull。</span><br><span class="line">1.**JsonObject**  表示的是包含name-value型的 json 字符串，其中 name 是字符串，而 value 可以是其它类型的 JsonElement 元素。在json中用 **“&#123;&#125;”** 包裹起来的一个整体就是JsonObject。例如</span><br></pre></td></tr></table></figure><p>// “attributes” 是name，后面跟着的{}内容是它对应的value，而这个value就是一个JsonObject<br>  “attributes”: {<br>                  “first-name”: “Su”,<br>                  “last-name”: “Tu”<br>                 }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.**JsonArray** 这个类在 Gson 中代表一个数组类型，一个数组就是JsonElement的集合，这个集合中每一个类型都可能不同。这是一个有序的集合，意味着元素的添加顺序是被维持着的。上面例子中list对应的 **“[]”** 包裹起来的json就是JsonArray。</span><br><span class="line"></span><br><span class="line">3.**JsonPrimitive ** 这个可以认为是json中的原始类型的值，包含Java的8个基本类型和它们对应的包装类型，也包含 String 类型。比如上面 &quot;first-name&quot; 对应的 &quot;Su&quot; 就是一个 String 类型的 JsonPrimitive 。</span><br><span class="line"></span><br><span class="line">4.**JsonNull**  通过名字也可以猜到，这个代表的是 null 值。</span><br><span class="line"></span><br><span class="line">## Type</span><br><span class="line"></span><br><span class="line">Type是Java中的所有类型的顶层接口，它的子类有 GenericArrayType、ParameterizedType、TypeVariable、WildcardType，这个都是在java.lang.reflect包下面的类。另外，我们最熟悉的一个类 Class 也实现了 Type 接口。</span><br><span class="line"></span><br><span class="line">一般来讲，调用 GsonBuilder 的 registerTypeAdapter() 去注册，第一个参数使用 Class 类型就可以了。</span><br><span class="line"></span><br><span class="line">## JsonDeserializationContext</span><br><span class="line"></span><br><span class="line">这个类是在反序列过程中，由其它类调用我们自定义的 JsonDeserialization 的 deserialize() 方法时传递过来的，在 Gson 中它唯一的一个实现是TreeTypeAdapter 中的一个私有的内部类 GsonContextImpl 。可以在自定义的 JsonDeserializer 的 deserialize() 中去调用 JsonDeserializationContext 的 deserialize() 方法去获得一个对象。</span><br><span class="line"></span><br><span class="line">**但是要记住，如果传递到 JsonDeserializationContext 中的 json 与 JsonDeserializer 中的 json 一样的话，可能会导致死循环调用。**</span><br><span class="line"></span><br><span class="line"># 思路分析</span><br><span class="line">## 创建JavaBean</span><br><span class="line"></span><br><span class="line">还是以最上面的那个 json 进行分析，在 **list** 对应 JsonArray ，其中的两个 JsonObject 中，**attributes** 对应的 JsonObject 字段完全不一样，但是为了统一，在写 JavaBean 的时候可以给它们设置一个共同的父类，尽管它是空的。</span><br></pre></td></tr></table></figure><p>public class Attribute {<br>      …<br>}</p><p>public class AddressAttribute extends Attribute {<br>    private String street;<br>    private String city;<br>    private String country;<br>… 省略get/set<br>}</p><p>public class NameAttribute extends Attribute {<br>    @SerializedName(“first-name”)<br>    private String firstname;<br>    @SerializedName(“last-name”)<br>    private String lastname;<br>…省略get/set<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置 Attribute 这个 SuperClass 只是为了在 GsonBuilder 去注册，当具体解析的时候我们会根据type 对应的类型去找到对应的Class。</span><br></pre></td></tr></table></figure><p> gsonBuilder.registerTypeAdapter(Attribute.class, new AttributeJsonDeserializer());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">到了这里我们就应该想到，type 对应的 value 肯定是要与具体的 JavaBean 对应起来的。比如在这里就是</span><br></pre></td></tr></table></figure></p><p>“address”——AddressAttribute.class<br>“name”——NameAttribute.class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果 type 是 **&quot;address&quot;** ，那么我们就可以用 gson 去拿 AddressAttribute.class 和对应的 json 去解析。</span><br></pre></td></tr></table></figure></p><p>Attribute attribute = gson.form(addressJson,AddressAttribute.class);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 如何把 json 准确的转为对应的 JavaBean </span><br><span class="line">我们注册的是父类 Attribute ，当反序列化需要解析 Attribute 的时候就会把对应的 json 作为参数回调自定义的 JsonDeserializer 。我们就可以在下面这个方法中写自己的逻辑得到我们需要的  Attribute 对象了。</span><br></pre></td></tr></table></figure></p><p> public Attribute deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是细心的朋友应该会发现了，这个时候传递的 json 有可能是这样的</span><br></pre></td></tr></table></figure></p><p>{<br>   “street”: “NanJing Road”,<br>   “city”: “ShangHai”,<br>   “country”: “China”<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也有可能是这样的</span><br></pre></td></tr></table></figure></p><p>{<br>   “first-name”: “Su”,<br>   “last-name”: “Tu”<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们怎么知道该解析成 AddressAttribute 还是 NameAttribute  ？？？</span><br><span class="line"></span><br><span class="line">我们想想，具体解析成哪个，我们肯定是需要知道 type 对应的 value 。而这个 type 是与 attributes 同级的字段，照着刚才这样肯定是没希望拿到这个 value 的。</span><br><span class="line"></span><br><span class="line">我们再想想，能够知道这个 type 对应的 value 是什么的肯定是 attributes 上一层级的 json 。</span><br></pre></td></tr></table></figure></p><p>{<br>   “type”: “name”,<br>   “attributes”: {<br>                          …<br>                 }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么我们可不可以在 GsonBuilder 中再去注册一个 typeAdapter 来解析这个外层的 json 呢？当然可以。</span><br></pre></td></tr></table></figure></p><p>gsonBuilder.registerTypeAdapter(AttributeWithType.class, new AttributeWithTypeJsonDeserializer());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个 AttributeWithType 就是外层的 json 对应的 JavaBean</span><br></pre></td></tr></table></figure></p><p>public class AttributeWithType {<br>    private String type;<br>    private Attribute attributes;<br>     …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在反序列化 AttributeWithType 这个类的时候，我们可以获得这个 type 对应的 value，然后把这个 value 传递给里层的 Attribute 对应的 JsonDeserializer。这样就可以根据 value 是 “address” 或者 “name” 去对 AddresAttribute 或者 NameAttribute 进行反序列化了。</span><br><span class="line"></span><br><span class="line">## 有一个坑</span><br><span class="line">前面那我们讲过，调用 JsonDeserializationContext 的方法应该注意死循环。在具体的实践中，我虽然没有调用 JsonDeserializationContext 的方法，但是依然出现了死循环的情况。就是因为我是这么用的。</span><br></pre></td></tr></table></figure></p><p> AttributeWithType attributeWithType = gson.fromJson(json, AttributeWithType.class);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">乍一看没什么问题啊，问题就出在这个 gson 身上。这个 gson 是已经注册过解析 AttributeWithType 的 GsonBuilder 创建的。 gson.fromJson() 方法中的 json 是 AttributeWithType 对应的反序列化的 json，gson.fromJson() 内部会再次调用 AttributeWithType 对应的 JsonDeserializer 中的 deserialize() 方法，从而导致死循环。</span><br><span class="line"></span><br><span class="line">避免死循环的方式就是用GsonBuilder新建一个 gson ，这个GsonBuilder不再注册  AttributeWithType  ，而只去注册  Attribute 去解析。</span><br><span class="line"></span><br><span class="line"># 为了更好更通用</span><br><span class="line">1.在项目中，可能还会存在另一种格式的json，外部没有单独的type元素，而是与其它的元素放在同一个JsonObject中。这样的格式更省事，不需要注册外层的typeAdaper即可。</span><br></pre></td></tr></table></figure><p>{<br>    “total”: 2,<br>    “list”: [<br>        {<br>            “type”: “address”,<br>            “street”: “NanJing Road”,<br>            “city”: “ShangHai”,<br>            “country”: “China”<br>        },<br>        {<br>            “type”: “name”,<br>            “first-name”: “Su”,<br>            “last-name”: “Tu”<br>        }<br>    ]<br>}</p><p>MultiTypeJsonParser<attribute> multiTypeJsonParser = new MultiTypeJsonParser.Builder<attribute>()<br>        .registerTypeElementName(“type”)<br>        .registerTargetClass(Attribute.class)<br>// 如果所要解析的 jsonObejct 中已经含有能够表示自身类型的字段，不需要注册外层 Type，这样更省事<br>//        .registerTargetUpperLevelClass(AttributeWithType.class)<br>        .registerTypeElementValueWithClassType(“address”, AddressAttribute.class)<br>        .registerTypeElementValueWithClassType(“name”, NameAttribute.class)<br>        .build();</attribute></attribute></p><p>ListInfoWithType listInfoWithType = multiTypeJsonParser.fromJson(TestJson.TEST_JSON_1, ListInfoWithType.class);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.如果在解析过程中发现有些类型没有注册到 MultiTypeJsonParser 的 Builder 中，解析的时候碰到相应的 jsonObject 就直接返回null。比如下面这样的json中，&quot;type&quot; 对应的 &quot;parents&quot; 如果没有注册，那么反序列化的时候这个 json 所代表的对象就为 null 。</span><br></pre></td></tr></table></figure></p><p> {<br>        “type”: “parents”,<br>        “attributes”: {<br>          “mather”: “mi lan”,<br>          “father”: “lin ken”<br>        }<br> }<br>```</p><p>在Android中我们反序列这样的 json 后一般会把得到的对象的设置到列表控件上，如果后端返回的 json 中包含之前未注册的类型，为了程序不至于 crash，需要对反序列化的 null 对象进行过滤，项目中提供了一个工具类 ListItemFilter 可以过滤集合中为 null 的元素。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对于如何优雅的解析这种类型不同的 JsonObject ，刚开始我是缺少思路的，在网上也没有查到合适的文档。但是通过查看 Gson 的文档和源码，通过自己的理解和分析，逐步的完成了这个过程。我的一个感触就是，多去看看官方的使用文档应该比盲目去搜索解决方案更好。</p><p>代码是最好的文档，本文只简单介绍了一些实现思路，文中贴出的一些代码是为了讲述方便，与项目中的代码可能会有有些区别。具体的使用可以看<a href="https://github.com/sososeen09/MultiTypeJsonParser" target="_blank" rel="noopener">项目</a>中的例子。</p><p>如果有问题，欢迎提 issue 或留言，如果对您有所帮助，欢迎Star。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener">Gson官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重识OkHttp——探究源码设计</title>
      <link href="/2016/11/21/%E9%87%8D%E8%AF%86OkHttp%E2%80%94%E2%80%94%E6%8E%A2%E7%A9%B6%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
      <url>/2016/11/21/%E9%87%8D%E8%AF%86OkHttp%E2%80%94%E2%80%94%E6%8E%A2%E7%A9%B6%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是重试OkHttp系列的第2篇，依然是基于<a href="https://github.com/square/okhttp/tree/okhttp_34" target="_blank" rel="noopener">OkHttp3.4</a>。上一篇<a href="http://www.jianshu.com/p/c70d0ce5400c" target="_blank" rel="noopener">重识OkHttp——更深入了解如何使用</a>算是对OkHttp的基本使用做了一个简单的总结，本篇会深入源码内部，探究OkHttp是如何工作的。</p></blockquote><p>#1 客户端完整的请求</p><p>OkHttp发送一个请求需要4步：</p><ul><li>构建OkHttpClient</li><li>构建Request</li><li>创建一个Call</li><li>执行Call的同步或者异步方法，处理响应。</li></ul><p>我们只以一个简单的异步get请求来举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建OkHttpClient</span><br><span class="line">OkHttpClient client = new OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line">//创建Request</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;http://publicobject.com/helloworld.txt&quot;) </span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">//创建Call</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">//执行Call的异步方法</span><br><span class="line"> call.enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                //做一些请求失败的处理</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">              //做一些请求成功的处理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>Request和OkHttpClient都是我们自己创建的，不再讨论了。就从这个Call来展开讨论。</p><h1 id="探究源码"><a href="#探究源码" class="headerlink" title="探究源码"></a>探究源码</h1><h2 id="Call的实现类RealCall"><a href="#Call的实现类RealCall" class="headerlink" title="Call的实现类RealCall"></a>Call的实现类RealCall</h2><p>Call是一个准备执行的请求，它是一个接口。含有一个内部接口Factory 用于生成Call。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Call &#123;</span><br><span class="line">//返回当前Call的Request</span><br><span class="line">  Request request();</span><br><span class="line">//同步请求</span><br><span class="line">  Response execute() throws IOException;</span><br><span class="line">//异步请求</span><br><span class="line">  void enqueue(Callback responseCallback);</span><br><span class="line">//取消请求</span><br><span class="line">  void cancel();</span><br><span class="line">//判断是否执行过</span><br><span class="line">  boolean isExecuted();</span><br><span class="line">//判断是否取消了</span><br><span class="line">  boolean isCanceled();</span><br><span class="line"></span><br><span class="line">  interface Factory &#123;</span><br><span class="line">    Call newCall(Request request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OkHttpClient实现了Call.Factory接口，所以有一个newCall方法，这个方法中干了这么个事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#OkHttpClient</span><br><span class="line">  @Override public Call newCall(Request request) &#123;</span><br><span class="line">    return new RealCall(this, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#RealCall的构造方法</span><br><span class="line">  protected RealCall(OkHttpClient client, Request originalRequest) &#123;</span><br><span class="line">    this.client = client;</span><br><span class="line">    this.originalRequest = originalRequest;</span><br><span class="line">    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，返回了一个RealCall，这个RealCall是OkHttp中Call的唯一实现类。说明我们执行请求，是通过RealCall发出的。<br>在RealCall的构造方法中，我们还创建了一个拦截器RetryAndFollowUpInterceptor，通过名字我们可以猜测一下这个拦截器的作用是重试和跟进，这个负责是否断线重连和重定向，可以看到这个拦截器跟OkHttpClient有关联，我们可以在配置OkHttpClient的时候配置断线重连等，默认的都是true。</p><blockquote><p>在OkHttp中以Real为前缀的类，都是真正干活的类</p></blockquote><h2 id="RealCall的enqueue-Callback-callBack-方法"><a href="#RealCall的enqueue-Callback-callBack-方法" class="headerlink" title="RealCall的enqueue( Callback callBack)方法"></a>RealCall的enqueue( Callback callBack)方法</h2><p>OkHttpClient的newCall方法只是创建了一个RealCall，RealCall的enqueue方法传递了一个CallBack用于处理回调，那我们看看这个方法都干了些什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#RealCall</span><br><span class="line">  @Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line"> //同一个Call只能执行一次，否则会报错。</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，同一个Call只能执行一次，否则会报错。<br>client.dispatcher()返回的是与OkHttpClient绑定的一个Dispatcher。这个Dispatcher用来管理请求的调度。在上一篇<a href="http://www.jianshu.com/p/c70d0ce5400c" target="_blank" rel="noopener">重识OkHttp——更深入了解如何使用</a>中我们简单的也提到过这个类。这个类主要是用来管理异步请求的调度，同步请求中虽然也参与了，但只是简单的统计正在执行的Call并在Call执行完毕之后做相应的处理。</p><p>AsyncCall是RealCall的内部类，继承了NamedRunnable，实际上也是一个Runnable实现类。这个AsyncCall 包装了Callback。它的run()方法中最终会调用它自己的execute()方法。后面我们会讲到AsyncCall的execute()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#NamedRunnable</span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br></pre></td></tr></table></figure><p>RealCall的enqueue( Callback callBack)实际上最后调用了Dispatcher的enqueue(AsyncCall call)方法。</p><h2 id="Dispatcher的enqueue方法"><a href="#Dispatcher的enqueue方法" class="headerlink" title="Dispatcher的enqueue方法"></a>Dispatcher的enqueue方法</h2><p>Dispatcher的enqueue方法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Dispatcher</span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">//判断是否可以执行当前这个Call</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">//满足条件，添加到代表执行的Call的集合中，并开始执行</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//不满足条件，添加到等待的集合中</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法中首先会判断当前正在执行的Call的数量以及访问同一个主机地址的Call的数量是否在限定范围内。Dispatcher默认的Call的并发数是64，同一个主机地址的并发数是5。这个并发数可以更改。<br>如果满足条件，就向代表当前正在执行的Call的集合中添加该Call，并且去执行它。否则就会向等待的集合中添加该Call，等待被执行。</p><p>executorService()返回的是ExecutorService对象，调用ExecutorService的execute(call)方法实际上最后调用的就是AsyncCall 的execute()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#RealCall.AsyncCall</span><br><span class="line">   @Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">//最核心的方法，调用之后返回Response</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          // Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个execute()方法中，能获得返回Response，之后做回调处理，Dispatcher也会对Call进行管理。核心的方法就是getResponseWithInterceptorChain()。</p><h2 id="核心方法getResponseWithInterceptorChain"><a href="#核心方法getResponseWithInterceptorChain" class="headerlink" title="核心方法getResponseWithInterceptorChain()"></a>核心方法getResponseWithInterceptorChain()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> private Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">//添加开发者用户自己定义的拦截器。</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line"></span><br><span class="line">//添加失败重连和重定向的拦截器</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line"></span><br><span class="line">//这个拦截器主要是添加一些请求头和其它信息，同时对返回的响应做一些响应头或其它处理。</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line"></span><br><span class="line">//添加缓存拦截器，根据不同的缓存策略做相应的处理。</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">/**</span><br><span class="line"> * 添加连接拦截器，与服务器建立Socket连接。</span><br><span class="line"> * 其他的拦截器都会对Request和Response进行一些操作，这个拦截器不会。</span><br><span class="line"> */</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">/**</span><br><span class="line"> * 默认retryAndFollowUpInterceptor.isForWebSocket()为false，</span><br><span class="line"> * 所以会添加网络拦截器networkInterceptors()，</span><br><span class="line"> * 这个拦截器也是在配置OkHttpClient的时候开发者添加的。</span><br><span class="line"> * 这个拦截器工作的时候肯定已经联网了。</span><br><span class="line"> */</span><br><span class="line">    if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line"> * 添加CallServerInterceptor拦截器，它主要就是IO操作了， 本质就是Socket的网络IO操作。 </span><br><span class="line"> * 对服务器：写入请求头，如果有请求体的话写入请求体。</span><br><span class="line"> * 拿到响应之后处理响应头、code、message、body等。</span><br><span class="line"> */</span><br><span class="line">    interceptors.add(new CallServerInterceptor(</span><br><span class="line">        retryAndFollowUpInterceptor.isForWebSocket()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 创建一个RealInterceptorChain，用它来开始处理请求。</span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这个getResponseWithInterceptorChain()方法中，有大量的Interceptors，有开发者自己定义的Interceptor也有OkHttp自己的Interceptor。这些Interceptor都存入到了ArrayList集合，我们在这里就可以大胆猜测一下这个Interceptor应该是顺序执行的。最后创建了一个RealInterceptorChain，通过调用它的proceed(request)方法开始处理原始的request，然后我们就拿到了我们想要的Response。</p><p>RealInterceptorChain是Interceptor.Chain的实现类，看这个Real前缀就知道它干的绝对是重要的事。它是一个具体的拦截器链，我们存放在List<interceptor> interceptors集合中的拦截器之间的传递都要靠它。<br>它的proceed(request)最终会调用到四个参数的重载方法：</interceptor></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public Response proceed(Request request, StreamAllocation streamAllocation, HttpStream httpStream,</span><br><span class="line">      Connection connection) throws IOException &#123;</span><br><span class="line">  ...</span><br><span class="line">//下面的代码能够调用拦截器链中的下一个拦截器Interceptor</span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">//创建一个新的RealInterceptorChain用于把Request传递给下一个Interceptor去处理</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpStream, connection, index + 1, request);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">  ...</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上述代码部分就是这个方法的核心，能够把Request依次传递给下一个Interceptor去处理。<br>拦截器Interceptor的设计真是很赞，每一个Interceptor在发送Request的时候只处理自己那一部分Request，然后通过RealInterceptorChain的带动传递给下一个Interceptor进行处理，最后一个Interceptor发送完请求得到服务器的响应Response，经过自己的处理之后返回给它之前的那个Interceptor进行处理，依次进行，最后一个处理完毕的Response返回给开发者用户。<br>形象一点，Interceptor就像是生产线上的工人，Request是物料，Response是产品，RealInterceptorChain是一节一节的传送带。每个工人同时负责处理自己那一部分的Request和Response，由传送带进行传递，各司其职，最后完成一件对用户来讲完美的产品。</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-b7337609283fad43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器流程.png"></p><p>我第一次看OkHttp3.4源码的的时候真是一脸懵逼继而叹为观止。后来看了其它文章，才知道原来这个设计模式叫作<strong>责任链模式</strong>。在<em>Android源码设计模式解析与实战</em>这本书中介绍了Android的事件分发处理采用的也是责任链模式。</p><p>具体到每个拦截器都是怎么处理Request和Response的，最好自己去看一下，我们就不展开讨论了。</p><h1 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h1><p>看了异步请求的调用，同步请求的分析就比较简单了，因为最终调用的还是getResponseWithInterceptorChain()这个核心方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#RealCall</span><br><span class="line">  @Override public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">  //同一个Call只能执行一次，否则会报错。</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">//Dispatcher.execute(Call call)方法，只是把当前正在执行的Call添加到代表执行中的集合去。</span><br><span class="line">      client.dispatcher().executed(this);</span><br><span class="line">//核心的方法就是调用的这个getResponseWithInterceptorChain()方法返回响应Response。</span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">//下面的方法只是代表对一个Call结束之后做的处理。</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对OkHttp一个完整的请求过程做了简单的说明，限于篇幅有些地方讲的不是很详细，有兴趣的读者可以自己去探索一下这个流程，尤其是在拦截器那一部分，掌握好了之后对我们平时灵活运用OkHttp会有很大帮助，如配置我们自定义的缓存拦截器，或者在拦截器中监听下载进度，网上也有很多文章可供参考。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><ul><li><a href="http://gold.xitu.io/post/581311cabf22ec0068826aff" target="_blank" rel="noopener">从OKHttp框架看代码设计</a></li><li><a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆 OkHttp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重识OkHttp——更深入了解如何使用</title>
      <link href="/2016/11/14/%E9%87%8D%E8%AF%86OkHttp%E2%80%94%E2%80%94%E6%9B%B4%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/11/14/%E9%87%8D%E8%AF%86OkHttp%E2%80%94%E2%80%94%E6%9B%B4%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的分析基于<a href="https://github.com/square/okhttp/tree/okhttp_34" target="_blank" rel="noopener">OkHttp3.4</a>，不展示完整的代码示例，具体可以查看<a href="https://github.com/square/okhttp/wiki/Recipes" target="_blank" rel="noopener">这个官方例子</a>或者项目中的<strong>samples</strong>。</p></blockquote><p>OkHttp作为square公司出品的一个网络请求框架，应该算是目前Android端最火爆的网络框架了。我公司目前的项目中采用的都是Rxjava结合Retrofit进行网络请求的处理，对于底层真正实现网络请求的OkHttp关注的不是很多。最近探究了一下OkHttp的源码，对OkHttp的使用有了一些新的认识，在此做一下总结。</p><h1 id="1-OkHttp的优点"><a href="#1-OkHttp的优点" class="headerlink" title="1 OkHttp的优点"></a>1 OkHttp的优点</h1><p>OkHttp作为当前Android端最火热的网络请求框架，必然有很多的优点。</p><ul><li>支持HTTP/2 协议，允许连接到同一个主机地址的所有请求共享Socket。这必然会提高请求效率。</li><li>在HTTP/2协议不可用的情况下，通过连接池减少请求的延迟。</li><li>GZip透明压缩减少传输的数据包大小。</li><li>响应缓存，避免同一个重复的网络请求。</li></ul><h1 id="2-网络处理3要素"><a href="#2-网络处理3要素" class="headerlink" title="2 网络处理3要素"></a>2 网络处理3要素</h1><p>对于客户端来讲，我们关注的就是把正确的请求发送到服务端并拿到结果来进行处理。在OkHttp中，我认为可以分为3个部分：</p><ul><li>Request类封装客户端发送的请求，包括请求的url，请求方法method（主要是GET和POST方法）、请求头header以及请求体requestBody；</li><li>Response类封装了服务器响应的数据，包括code、message、body、header等。</li><li>OkHttpClient负责发送请求Request并通过同步或者异步的方式返回服务器的响应Response，就好比是一个浏览器。</li></ul><p>OkHttp中通过建造者模式来构建OkHttpClient、Request和Response。对于客户端来讲，我们不需要过多关注Response是如何构建的，因为这个是OkHttp对响应结果进行了封装处理。我们只关注请求Request和客户端OkHttpClient如何构建即可。</p><h1 id="2-1-请求Request"><a href="#2-1-请求Request" class="headerlink" title="2.1 请求Request"></a>2.1 请求Request</h1><p>Request采用建造者模式来配置url，请求方法method、header、tag和cacheControl。</p><ul><li>设置url。可以是String类型、URL类型和HttpUrl类型。最终都是用到HttpUrl类型。</li><li>设置method，包含get、post方法等。默认的是get方法。post方法要传RequestBody，类似的还有delete、put、patch。</li><li>设置header，方法有addHeader(String name, String value)、 removeHeader(String name)、header(String name, String value)、headers(Headers headers)。headers(Headers headers)调用之后其它的header都会被移除，只添加这一个header。而header(String name, String value)方法调用之后，其它与这个name同名的header都会被移除，只保留这一个header。</li><li>设置tag，设置tag可以用来取消这一请求。如果未指定tag或者tag为null，那么这个request本身就会当做是一个tag用来被取消请求。</li><li>设置cacheControl，这个是设置到请求头中。用来替换其它name是”Cache-Control”的header。如果cacheControl是空的话就会移除请求头中name是”Cache-Control”的header。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2083810-256d5a86abb5e29b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Request.png"></p><p>OkHttp采用POST方法向服务器发送一个请求体，在OkHttp中这个请求体是RequestBody。这个请求体可以是：</p><ul><li>String类型</li><li>Stream流类型</li><li>File文件类型</li><li>Form表单形式的key-value类型</li><li>类似Html文件上传表单的复杂请求体类型（多块请求）。</li></ul><p>RequestBody有几个静态方法用于创建不同类型的请求体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建String类型的请求体</span><br><span class="line">public static RequestBody create(MediaType contentType, String content)</span><br><span class="line"></span><br><span class="line">//创建文件类型的请求体</span><br><span class="line"> public static RequestBody create(final MediaType contentType, final File file)</span><br></pre></td></tr></table></figure><p>最终都是相当于重写了RequestBody的两个抽象方法来写入流，如果传递流类型的参数，只要重写这两个抽象方法即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对应的是name为Content-Type的header</span><br><span class="line">public abstract MediaType contentType();</span><br><span class="line"></span><br><span class="line">//这个BufferedSink位于Okio包下，提供高效的写入。</span><br><span class="line">public abstract void writeTo(BufferedSink sink) throws IOException;</span><br><span class="line"></span><br><span class="line">//在写入的时候可以传递内容的大小，如果不知道就返回-1即可。</span><br><span class="line">public long contentLength() throws IOException &#123;  return -1;&#125;</span><br></pre></td></tr></table></figure><p>例如，我们提交一个String：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String postBody = &quot;&quot;</span><br><span class="line">        + &quot;Releases\n&quot;</span><br><span class="line">        + &quot;--------\n&quot;</span><br><span class="line">        + &quot;\n&quot;</span><br><span class="line">        + &quot; * _1.0_ May 6, 2013\n&quot;</span><br><span class="line">        + &quot; * _1.1_ June 15, 2013\n&quot;</span><br><span class="line">        + &quot; * _1.2_ August 11, 2013\n&quot;;</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>提交File：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;README.md&quot;);</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>提交流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody = new RequestBody() &#123;</span><br><span class="line">       @Override</span><br><span class="line">        public MediaType contentType() &#123;</span><br><span class="line">             return MEDIA_TYPE_MARKDOWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">         public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class="line">              sink.writeUtf8(&quot;Numbers\n&quot;);</span><br><span class="line">              sink.writeUtf8(&quot;-------\n&quot;);</span><br><span class="line">              for (int i = 2; i &lt;= 997; i++) &#123;</span><br><span class="line">                     sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">          private String factor(int n) &#123;</span><br><span class="line">                for (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">                     int x = n / i;</span><br><span class="line">                     if (x * i == n) return factor(x) + &quot; × &quot; + i;</span><br><span class="line">                 &#125;</span><br><span class="line">                return Integer.toString(n);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>对于提交表单和分块请求，OkHttp提供了两个RequestBody的子类，<strong>FormBody</strong>和<strong>MultipartBody</strong></p><h3 id="2-1-1-表单FormBody"><a href="#2-1-1-表单FormBody" class="headerlink" title="2.1.1 表单FormBody"></a>2.1.1 表单FormBody</h3><p>FormBody也是采用建造者模式， 这个很简单，添加key-value形式的键值对即可。<br>添加键值对有两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//采用OkHttp默认的编码</span><br><span class="line">public Builder add(String name, String value) </span><br><span class="line"></span><br><span class="line">//采用用户要求的编码</span><br><span class="line">public Builder addEncoded(String name, String value)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RequestBody formBody = new FormBody.Builder()</span><br><span class="line">                      .add(&quot;search&quot;, &quot;Jurassic Park&quot;)</span><br><span class="line">                      .build();</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">                      .url(&quot;https://en.wikipedia.org/w/index.php&quot;)</span><br><span class="line">                      .post(formBody)</span><br><span class="line">                      .build();</span><br></pre></td></tr></table></figure><h3 id="2-1-2-分块MultipartBody"><a href="#2-1-2-分块MultipartBody" class="headerlink" title="2.1.2 分块MultipartBody"></a>2.1.2 分块MultipartBody</h3><p>MultipartBody也是采用建造者模式，MultipartBody.Builder可以构建兼容Html文件上传表单的复杂请求体。每一部分的多块请求体都是它自身的请求体，并且可以定义它自己的请求头。如果存在的话，这些请求头用来描述这部分的请求体。例如Content-Disposition、Content-Length 和 Content-Type如果可用就会被自动添加到头。</p><p>MIME类型有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final MediaType MIXED = MediaType.parse(&quot;multipart/mixed&quot;);</span><br><span class="line"></span><br><span class="line">public static final MediaType ALTERNATIVE = MediaType.parse(&quot;multipart/alternative&quot;);</span><br><span class="line"></span><br><span class="line">public static final MediaType DIGEST = MediaType.parse(&quot;multipart/digest&quot;);</span><br><span class="line"></span><br><span class="line">public static final MediaType PARALLEL = MediaType.parse(&quot;multipart/parallel&quot;);</span><br></pre></td></tr></table></figure><p>有几个主要的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//设置MIME类型，如MIXED（默认的）</span><br><span class="line">  public Builder setType(MediaType type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//添加请求体</span><br><span class="line">  public Builder addPart(RequestBody body) &#123;</span><br><span class="line">    return addPart(Part.create(body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//添加包含header的请求体</span><br><span class="line">  public Builder addPart(Headers headers, RequestBody body) &#123;</span><br><span class="line">    return addPart(Part.create(headers, body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //请求体添加表单</span><br><span class="line">  public Builder addFormDataPart(String name, String value) &#123;</span><br><span class="line">    return addPart(Part.createFormData(name, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //请求体中包含文件</span><br><span class="line">  public Builder addFormDataPart(String name, String filename, RequestBody body) &#123;</span><br><span class="line">    return addPart(Part.createFormData(name, filename, body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //添加自己定义的part</span><br><span class="line">  public Builder addPart(Part part) &#123;</span><br><span class="line">    if (part == null) throw new NullPointerException(&quot;part == null&quot;);</span><br><span class="line">    parts.add(part);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>例如提交一个图片文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody = new MultipartBody.Builder()</span><br><span class="line">         .setType(MultipartBody.FORM)</span><br><span class="line">        .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)</span><br><span class="line">        .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,</span><br><span class="line">         RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"> Request request = new Request.Builder()</span><br><span class="line">         .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)</span><br><span class="line">         .url(&quot;https://api.imgur.com/3/image&quot;)</span><br><span class="line">         .post(requestBody)</span><br><span class="line">         .build();</span><br></pre></td></tr></table></figure><h1 id="2-2-客户端OkHttpClient"><a href="#2-2-客户端OkHttpClient" class="headerlink" title="2.2 客户端OkHttpClient"></a>2.2 客户端OkHttpClient</h1><p>OkHttpClient采用建造者模式，通过Builder可以配置连接超时时间、读写时间，是否缓存、是否重连，还可以设置各种拦截器interceptor等。<br>建议在一个App中，OkHttpClient保持一个实例。一个OkHttpClient支持一定数量的并发，请求同一个主机最大并发是5，所有的并发最大是64。这个与OkHttp中的调度器Dispatcher有关，可以设置并发数。本文不对Dispatcher进行讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient=new OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line">//如果不需要我们额外配置，可以使用默认的配置</span><br><span class="line">OkHttpClient okHttpClient1 = new OkHttpClient();</span><br></pre></td></tr></table></figure><p>一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int cacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class="line">File cacheDirectory = new File(getCacheDir(), &quot;OkHttpCache&quot;);</span><br><span class="line">Cache cache = new Cache(cacheDirectory, cacheSize);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(60, TimeUnit.SECONDS)//连接超时时间</span><br><span class="line">        .readTimeout(60, TimeUnit.SECONDS)//读的时间</span><br><span class="line">        .writeTimeout(60, TimeUnit.SECONDS)//写的时间</span><br><span class="line">        .cache(cache)//配置缓存</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>OkHttpClient支持单独配置，例如原来设置不同的请求时间，可以通过OkHttpClient的newBuilder()方法来重新构造一个OkHttpClient。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">//读的时间设置为500ms</span><br><span class="line">OkHttpClient copy = client.newBuilder()</span><br><span class="line">                          .readTimeout(500, TimeUnit.MILLISECONDS)</span><br><span class="line">                          .build();</span><br><span class="line"></span><br><span class="line">//读的时间设置为3000ms</span><br><span class="line">OkHttpClient copy = client.newBuilder()</span><br><span class="line">                          .readTimeout(3000, TimeUnit.MILLISECONDS)</span><br><span class="line">                          .build();</span><br></pre></td></tr></table></figure><h1 id="3-同步请求和异步请求"><a href="#3-同步请求和异步请求" class="headerlink" title="3 同步请求和异步请求"></a>3 同步请求和异步请求</h1><p>上面已经讲了如何创建Request和OkHttpClient，剩下的就是发送请求并得到服务器的响应了。OkHttp发送请求可分为同步和异步。OkHttpClient首先通过Request构建一个Call，通过这个Call去执行同步或者异步请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#OkHttpClient</span><br><span class="line">public Call newCall(Request request)</span><br></pre></td></tr></table></figure><p>同步方式，调用Call的execute()方法，返回Response，会阻塞当前线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure><p>异步方式，调用Call的enqueue(CallBack callBack)方法，会在另一个线程中返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">              //处理错误的回调</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">              //处理正确的回调</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h1><h2 id="4-1-配置响应缓存"><a href="#4-1-配置响应缓存" class="headerlink" title="4.1 配置响应缓存"></a>4.1 配置响应缓存</h2><p>为了缓存响应，需要一个可读写并且设置大小Size的缓存目录。缓存目录需要私有，其它不信任的应用不能访问这个文件。<br>如果同时有多个缓存访问同一个缓存目录会报错。所以最好只在App中初始化一次OkHttpClient，给这个实例配置缓存，在整个App生命周期内都用这一个缓存。否则几个缓存会相互影响，导致缓存出错，引起程序崩溃。<br>响应缓存采用Http头来配置，你可以添加这样的请求头<strong>Cache-Control: max-stale=3600</strong>。 <strong>max-age</strong>指的是客户端可以接收生存期不大于指定时间（以<strong>秒</strong>为单位）的响应。<br>为了防止响应使用缓存，可以用<strong>CacheControl.FORCE_NETWORK</strong>。为了防止使用网络，采用 <strong>CacheControl.FORCE_CACHE</strong>。</p><blockquote><p>注意:如果使用FORCE_CACHE禁止使用网络，而响应又没有缓存存在，OkHttp会报<strong>504 Unsatisfiable Request </strong>响应错误。</p></blockquote><h2 id="4-2-取消请求"><a href="#4-2-取消请求" class="headerlink" title="4.2 取消请求"></a>4.2 取消请求</h2><p>调用Call.cancel()方法可以立即取消一个网络请求。如果当前线程正在写request或者读response会报IO异常。如果不再需要网络请求，采用这种方法是比较方便的。例如在App中返回了上一页。无论是同步还是异步的请求都可以被取消。</p><h2 id="4-3-Response读取响应结果"><a href="#4-3-Response读取响应结果" class="headerlink" title="4.3 Response读取响应结果"></a>4.3 Response读取响应结果</h2><p>可以通过Response的code来判断请求是否成功，如果服务器返回的有数据，可以通过Response的body得到一个ResponseBody读取。<br>如果采用ResponseBody的string()方法会一次性把数据读取到内存中，如果数据超过1MB可能会报内存溢出，所以对于超过1MB的数据，建议采用流的方式去读取，如ResponseBody的byteStream()方法。</p><p><strong>需要说明的是：</strong></p><ul><li>如果ResponseBody的内容不读取的话，不会触发IO流的读取操作</li><li>内容读取之后，这个body需要关闭。</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>OkHttp中的很多类都用到了建造者模式，可以根据需要灵活配置。采用建造者模式的有：</p><ul><li>OkHttpClient.Builder</li><li>Request.Builder</li><li>FormBody.Builder</li><li>MultipartBody.Builder</li><li>Response.Builder</li></ul><p>如果单独使用OkHttp进行网络请求，通常需要开发者自己再封装一下，如果不想重复造轮子，Github上面的有一些优秀开源库可以拿来使用（本文只列出star较多的几个）：</p><ul><li><a href="https://github.com/hongyangAndroid" target="_blank" rel="noopener">hongyangAndroid</a>/<strong><a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">okhttputils</a></strong>（曾经在项目中用过）</li><li><a href="https://github.com/jeasonlzy" target="_blank" rel="noopener">jeasonlzy</a>/<strong><a href="https://github.com/jeasonlzy/okhttp-OkGo" target="_blank" rel="noopener">okhttp-OkGo</a></strong></li><li><a href="https://github.com/yanzhenjie" target="_blank" rel="noopener">yanzhenjie</a>/<strong><a href="https://github.com/yanzhenjie/NoHttp" target="_blank" rel="noopener">NoHttp</a></strong></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/square/okhttp/wiki" target="_blank" rel="noopener">OkHttp官方Wiki文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都是套路——Dagger2没有想象的那么难</title>
      <link href="/2016/10/30/%E9%83%BD%E6%98%AF%E5%A5%97%E8%B7%AF%E2%80%94%E2%80%94Dagger2%E6%B2%A1%E6%9C%89%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E9%9A%BE/"/>
      <url>/2016/10/30/%E9%83%BD%E6%98%AF%E5%A5%97%E8%B7%AF%E2%80%94%E2%80%94Dagger2%E6%B2%A1%E6%9C%89%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的分析基于<a href="https://github.com/google/dagger" target="_blank" rel="noopener">dagger2的2.7版本</a>。</p></blockquote><p>谷歌开发维护的Dagger2出来有很长时间了，目前在很多开源项目上也能看到它的身影。看了一些文章和项目，发现Dagger2的入门虽然有些难，但还是有一些规律可循的。</p><p><strong>对于开源的第三方项目，我认为都是有套路可循的，找到这个套路，入门就不会难了，难的是如何更好的在实际开发项目中灵活运用。而灵活运用必然是建立在对这些开源框架深刻理解的基础之上。</strong></p><p>关于Dagger2这种依赖注入框架的好处在这只简单的提一下</p><ul><li>依赖的注入和配置独立于组件之外</li><li>依赖对象是在一个独立、不耦合的地方初始化。当初始化方式改变的时候修改的代码少。</li><li>依赖注入使得单元测试更加简单。</li></ul><p>那么Dagger2相对于其他的依赖注入框架，有哪些有点和缺点呢？</p><p><strong>优点：</strong></p><ul><li>编译期生成代码，生成的代码像手写的一样。而且如果有错误会在编译期报出。</li><li>错误可追踪</li><li>易于调试。</li></ul><p><strong>缺点：</strong></p><ul><li>缺少灵活性，很多代码要按照既定的规则写</li><li>没有动态机制。</li></ul><p>下面会展开对Dagger2的介绍，看看Dagger2都有哪些套路。文中的代码都是从自己写的一个Demo中提取，文末会给出项目地址。</p><h1 id="1-Dagger2的注解"><a href="#1-Dagger2的注解" class="headerlink" title="1 Dagger2的注解"></a>1 Dagger2的注解</h1><p>想要理解Dagger2，首先要理解Dagger2中的注解，至少先了解一下，否则理解Dagger2会有障碍。Dagger2的注解比较多，但主要的会有下面7种。</p><ul><li><p><strong>@Inject：</strong>@Inject注解有两个作用，1是在需要依赖的类（下面这样的类都会称为目标类）中标记成员变量告诉Dagger这个类型的变量需要一个实例对象。2是标记类中的构造方法，告诉Dagger我可以提供这种类型的依赖实例。</p></li><li><p><strong>@Provide:</strong> 对方法进行注解，都是有返回类型的。用来告诉Dagger我们想如何创建并提供该类型的依赖实例（一般会在方法中new出实例）。用@Provide标记的方法，谷歌推荐采用provide为前缀。</p></li><li><p><strong>@Module:</strong> @Module这个注解用来标记类（一般类名以Module结尾）。Module主要的作用是用来集中管理@Provide标记的方法。我们定义一个被@Module注解的类，Dagger就会知道在哪里找到依赖来满足创建类的实例。<strong>modules的一个重要特征是被设计成区块并可以组合在一起。</strong>（例如可以在App中看到多个组合在一起的modules）</p></li><li><p><strong>@Component:</strong>Components是组件，也可以称为注入器。是<strong>@Inject</strong>和<strong>@Module</strong>之间的桥梁，主要职责是把二者组合在一起。@Component注解用来标记接口或者抽象类。所有的components都可以通过它的modules知道它所提供的依赖范围。一个Component可以依赖一个或多个Component，并拿到被依赖Component暴露出来的实例，Component的<strong>dependencies</strong>属性就是确定依赖关系的实现。<br><img src="http://upload-images.jianshu.io/upload_images/2083810-33f9ffeb9c6436a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本原理.png"></p></li><li><p><strong>@Scope:</strong> 作用域。Scopes非常有用，Dagger2通过自定义注解来限定作用域。这是一个非常强大的功能，所有的对象都不再需要知道怎么管理它自己的实例。Dagger2中有一个默认的作用域注解@Singleton，通常在Android中用来标记在App整个生命周期内存活的实例。也可以自定义一个@PerActivity注解，用来表明生命周期与Activity一致。<strong>换句话说，我们可以自定义作用域的粒度（比如@PerFragment, @PerUser等等）。</strong></p></li><li><p><strong>@Qualifier:</strong> 限定符，也是很有用。<strong>当一个类的类型不足以标示一个依赖的时候，我们就可以用这个注解。</strong>例如，在Android中，我们需要不同类型的Context，我们可以自定义标识符注解<strong>“@ForApplication”</strong>和<strong>“@ForActivity”</strong>。这样的话，当注解一个Context的时候，我们可以用这个标识符来告诉Dagger我们想提供哪一种Context。Dagger2里面已经存在一个限定符@Named注解。</p></li><li><p><strong> @SubComponent:</strong>如果我们需要父组件全部的提供对象，这时我们可以用包含方式而不是用依赖方式，相比于依赖方式，包含方式不需要父组件显式显露对象，就可以拿到父组件全部对象。且SubComponent只需要在父Component接口中声明就可以了。</p></li></ul><h1 id="2-Dagger2的套路"><a href="#2-Dagger2的套路" class="headerlink" title="2 Dagger2的套路"></a>2 Dagger2的套路</h1><h2 id="2-1-最简单的运用"><a href="#2-1-最简单的运用" class="headerlink" title="2.1 最简单的运用"></a>2.1 最简单的运用</h2><p>最简单的Dagger2运用只采用两个注解@Inject和@Component即可。因为本身@Inject就自带两个作用。<br>如一个User类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    //用这个@Inject表示来表示我可以提供User类型的依赖</span><br><span class="line">    @Inject</span><br><span class="line">    public User() &#123;</span><br><span class="line">        name = &quot;sososeen09&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要依赖的的目标类中标记成员变量，在这里我们这个目标类是OnlyInjectTestActivity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject //在目标类中@Inject标记表示我需要这个类型的依赖      </span><br><span class="line">User mUser;</span><br></pre></td></tr></table></figure><p>在Component中，Component内有一个方法是inject(OnlyInjectTestActivity onlyInjectTestActivity)，参数OnlyInjectTestActivity表示目标类，也就是把依赖实例注入该类中，必须精确，不能用父类代替。查看了一下编译后生成的代码，最后给变量赋值按照<strong>“类名.变量”</strong>来的。比如我们需要给mUser赋值，那么调用inject方法后，是按照<strong>“OnlyInjectTestActivity.mUser=xxx”</strong>来的。至于inject这个方法名是可以改的，但是谷歌推荐用inject。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 没有modules和dependencies的情况下，纯粹用@Inject来提供依赖</span><br><span class="line"> */</span><br><span class="line">@Component()</span><br><span class="line">public interface OnlyInjectComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 必须有个目标让Component知道需要往哪个类中注入</span><br><span class="line">     * 这个方法名可以是其它的，但是推荐用inject</span><br><span class="line">     * 目标类OnlyInjectTestActivity必须精确，不能用它的父类</span><br><span class="line">     * 这是Dagger2的机制决定的</span><br><span class="line">     */</span><br><span class="line">    void inject(OnlyInjectTestActivity onlyInjectTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就写好了，此时Make Project就会在build文件夹内生成对应的代码。我们的OnlyInjectComponent接口会生成一个<strong>以Dagger为前缀</strong>的DaggerOnlyInjectComponent类。<br>采用这个DaggerOnlyInjectComponent就能完成依赖对象的注入。可以在Activity的onCreate方法中调用如下代码，初始化注入。这样的话OnlyInjectTestActivity 中的成员变量mUser就完成了注入过程（也就是变量赋值过程）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerOnlyInjectComponent.builder().build().inject(this);</span><br></pre></td></tr></table></figure><p>整个依赖注入过程就结束了，是不是很简单。<br>@Inject提供依赖虽然很简单，但是它也有缺陷：</p><ul><li>只能标记一个构造方法，如果我们标记两个构造方法，编译的时候就会报错。因为不知道到底要用哪一个构造提供实例。</li><li>不能标记其它我们自己不能修改的类，如第三方库，因为我们没办法用@Inject标记它们的构造函数。</li></ul><p>举个例子，还是User类，有一个带参的构造方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    /**</span><br><span class="line">     * 用@Inject标记的构造函数如果有参数，那么这个参数也需要其它地方提供依赖。</span><br><span class="line">     * 但是@Inject有一个缺陷，就是对于第三方的类无能为力。因为我们不能修改第三方的构造函数，</span><br><span class="line">     * 所以对于String还有其他的一些我们不能修改的类，只能用@Module中的@Provides来提供实例了</span><br><span class="line">     */</span><br><span class="line">    @Inject</span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的注释写的很清楚了，如果用@Inject标记带参的构造方法，如String类型。那么这个String类参数也需要依赖，也就是说需要其它地方告诉Dagger可以提供一个String类型的对象。这个时候@Inject就无能为力了，你没办法修改String类给它的构造方法加上@Inject标记啊。所以必须要用我们另一个强大的标记@Module了。</p><h2 id="2-2-采用-Module提供依赖"><a href="#2-2-采用-Module提供依赖" class="headerlink" title="2.2 采用@Module提供依赖"></a>2.2 采用@Module提供依赖</h2><p>采用@Module标记的类提供依赖是一个常规套路，我们在项目中运用最多的也是这种方式。前面已经提到，@Module标记的类主要起到一个管理作用，真正提供依赖实例靠的是@Provides标记的带返回类型的方法。</p><p>这次以一个Person类为例，Person类如下，构造方法没有用@Inject标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public Person(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        sex = &quot;太监&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用Module提供Person实例，Module代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    Person providePerson() &#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码也算是一个固定套路了，用@Module标记类，用@Provides标记方法。如果想用Module提供实例，还要有一个Component，如我们下面的PersonComponent 。这个PersonComponent 与纯粹用@Inject方式提供依赖不同，还需要有一个modules指向DataModule 。这是告诉Component我们用DataModule 提供你想要的类型的实例。其它的方式相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = DataModule.class)</span><br><span class="line">public interface PersonComponent &#123;</span><br><span class="line">    void inject(ModuleTestActivity moduleTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ModuleTestActivity 中需要一个Person类型的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">Person mPerson;</span><br></pre></td></tr></table></figure><p>编译之后，我们就可以在目标类ModuleTestActivity 中进行初始化注入了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerPersonComponent.builder().dataModule(new DataModule()).build().inject(this);</span><br></pre></td></tr></table></figure><p>与纯粹用@Inject提供实例不同。新增加了一个dataModule方法，参数是DataModule类型的。因为PersonComponent需要依赖DataModule提供实例，当然也需要一个DataModule对象了。在这里，需要说明一点：<strong>如果DataModule只有一个默认的无参构造方法，我们是可以不用调用dataModule方法的</strong>，而且此时我们还可以用一个更简单的方式来替代，采用create()方法。之前讲的纯粹用@Inject提供依赖实例的方式也可以这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//如果DataModule有一个无参构造方法</span><br><span class="line">DaggerPersonComponent.create().inject(this);</span><br></pre></td></tr></table></figure><p>这样的话，依赖注入过程结束。mPerson已经被赋值。<br><strong>完成上面两步之后我们会不会有这样的思考：</strong>如果同时有@Module和@Inject构造方法来提供同一类型的实例，Dagger会调用哪个呢？这就牵涉到@Module和@Inject的优先级问题了。</p><h2 id="2-3-Module和-Inject的优先级问题"><a href="#2-3-Module和-Inject的优先级问题" class="headerlink" title="2.3 @Module和@Inject的优先级问题"></a>2.3 @Module和@Inject的优先级问题</h2><p>虽然优先级的问题，我们可以直接说出来，但还是亲手做一个实验好了，这样印象必定会更深刻。而且当你告诉别人这个结论的时候，你就可以挺直腰板的说就是这样，不然心里总虚啊。<br>新建一个实体类PriorityTestEntity，用@Inject标记构造方法，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityTestEntity &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public PriorityTestEntity() &#123;</span><br><span class="line">        name = &quot;我是@Inject注解提供的对象&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PriorityTestEntity(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DataModule中有一个方法，返回值类型是PriorityTestEntity：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    PriorityTestEntity providePriorityTestEntity() &#123;</span><br><span class="line">        return new PriorityTestEntity(&quot;我是module提供的对象&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新建Component，PriorityTestComponent，有一个inject()方法，注入目标类<br>PriorityTestActivity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = &#123;DataModule.class&#125;)</span><br><span class="line">public interface PriorityTestComponent &#123;</span><br><span class="line">    //注入目标类PriorityTestActivity </span><br><span class="line">    void inject(PriorityTestActivity priorityTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是在PriorityTestActivity 中进行初始化注入了，步骤都是跟之前讲的一样，真真的是套路啊，没什么难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在PriorityTestActivity 中</span><br><span class="line">//@Inject标记成员变量</span><br><span class="line">@Inject</span><br><span class="line">PriorityTestEntity mPriorityTestEntity;</span><br><span class="line"></span><br><span class="line">//初始化注入</span><br><span class="line">DaggerPriorityTestComponent.create().inject(this);</span><br><span class="line"></span><br><span class="line">//调用代码验证</span><br><span class="line">mTvShowUser.setText(mPriorityTestEntity.getName());</span><br><span class="line"></span><br><span class="line">//最后TextView上会显示&quot;我是module提供的对象&quot;</span><br></pre></td></tr></table></figure><p>总结一句话就是：<strong>在提供依赖对象这一层面上，@Module级别高于@Inject。</strong></p><h2 id="2-4-初始化依赖实例的步骤"><a href="#2-4-初始化依赖实例的步骤" class="headerlink" title="2.4 初始化依赖实例的步骤"></a>2.4 初始化依赖实例的步骤</h2><p>讲完了@Mudule和@Inject的优先级问题，我们可以总结一下Dagger是如何查找所需的依赖实例进行注入了。</p><p><strong>步骤如下：</strong></p><ol><li><p>查找Module中是否存在创建该类型的方法（前提是@Conponent标记的接口中包含了@Module标记的Module类，如果没有则直接找@Inject对应的构造方法）</p></li><li><p>若存在方法，查看该方法是否有参数</p><ul><li>若不存在参数，直接初始化该类的实例，一次依赖注入到此结束。</li><li>若存在参数，则从<strong>步骤1</strong>开始初始化每个参数</li></ul></li></ol><ol><li>若不存在创建类方法，则查找该类型的类中有@Inject标记的构造方法，查看构造方法中是否有参数<ul><li>若构造方法中无参数，则直接初始化该类实例，一次依赖注入到此结束。</li><li>若构造方法中有参数，从<strong>步骤1</strong>依次开始初始化每个参数。</li></ul></li></ol><p>如果你要问：<strong>我既没有@Module提供的实例，也没有@Inject标记的构造方法会怎样？很简单，编译期就会报错。</strong></p><p><strong>Dagger2的报错提醒还是很好的，能帮你快速的查找出问题所在。</strong></p><h2 id="2-5-Qualifier限定符有什么神奇的作用"><a href="#2-5-Qualifier限定符有什么神奇的作用" class="headerlink" title="2.5 @Qualifier限定符有什么神奇的作用"></a>2.5 @Qualifier限定符有什么神奇的作用</h2><p>@Qualifier这个限定符在项目中也会比较有用，比如之前讲的在Android中同样的Context，有ApplicationContext还有Activity的Context，就可以用自定义的<strong>“@ForApplication”</strong>和<strong>“@ForActivity”</strong>限定符来表示。Dagger2中已经有一个定义好的限定符@Named，长的是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Named &#123;</span><br><span class="line"></span><br><span class="line">    /** The name. */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面还是以Person为例，并且我们自定义一个限定符来看看这个东西具体如何使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public Person(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        sex = &quot;太监&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，默认的Person对象是一个太监，那么我想要一个<strong>“妹子”</strong>和<strong>“汉子”</strong>，还想自定义一个，如何区分呢？</p><p>我们先自定义一个限定符@PersonQualifier：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PersonQualifier &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DataModule，我们额外提供“汉子”、“妹子”和”qualifier sex”，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line"></span><br><span class="line">//一个默认的</span><br><span class="line">    @Provides</span><br><span class="line">    Person providePerson() &#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//采用@Qualifier注解，表示我可以提供这种标识符的Person</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;male&quot;)</span><br><span class="line">    Person providePersonMale() &#123;</span><br><span class="line">        return new Person(&quot;汉子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;female&quot;)</span><br><span class="line">    Person providePersonFemale() &#123;</span><br><span class="line">        return new Person(&quot;妹子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @PersonQualifier</span><br><span class="line">    Person providePersonByQualifier() &#123;</span><br><span class="line">        return new Person(&quot;qualifier sex&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Component长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = DataModule.class)</span><br><span class="line">public interface PersonComponent &#123;</span><br><span class="line">    void inject(ModuleTestActivity moduleTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要依赖的类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//在ModuleTestActivity中成员变量这样标记。</span><br><span class="line">    @Inject</span><br><span class="line">    Person mPerson;</span><br><span class="line"></span><br><span class="line">    //这么多对象，如果需要特定的对象，用@Qualifier标识符注解，@Named是自定义的一个标识符注解</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;male&quot;)</span><br><span class="line">    Person mPersonMale;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;female&quot;)</span><br><span class="line">    Person mPersonFemale;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @PersonQualifier</span><br><span class="line">    Person mPersonQualifier;</span><br></pre></td></tr></table></figure><p>然后注入，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerPersonComponent.builder().dataModule(new DataModule()).build().inject(this);</span><br></pre></td></tr></table></figure><p>查看Person对象的性别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPerson.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonMale.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonFemale.getSex());</span><br><span class="line">...</span><br><span class="line">mTvShowUser.setText(mPersonQualifier.getSex());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就可以看到，我们拿到了我们想要的对象。</p><h2 id="2-6-Scope作用域怎么用"><a href="#2-6-Scope作用域怎么用" class="headerlink" title="2.6 @Scope作用域怎么用"></a>2.6 @Scope作用域怎么用</h2><p>个人觉得，@Scope的作用主要是在组织Component和Module的时候起到一个提醒和管理的作用。<br>Dagger2中有一个默认的作用域@Singleton，是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><p>乍一看到Singleton，都会觉得Dagger2这么吊，标记一下就能创建单例了？后来研究了一下发现，这个@Singleton并没有创建单例的能力，或者也可以说不是我们常规用的那种单例，直接用AClass.getInstance()就能获取一个AClass的一个全局单例了。</p><p>下面我们看看，这个@Singleton怎么用，又是如何获取单例的。<br>我们有一个实体SingletonTestEntity，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTestEntity &#123;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public SingletonTestEntity(String desc) &#123;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DataModule中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class DataModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Singleton</span><br><span class="line">    SingletonTestEntity provideSingletonTestEntity() &#123;</span><br><span class="line">        return new SingletonTestEntity(&quot;测试单例&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个SingletonTestComponent ，我们之前说过@Component可以标注接口，也可以标注抽象类，我们就把这个SingletonTestComponent 改成了抽象类。<br><strong>需要说明的是：</strong>DataModule中的SingletonTestEntity 使用@Singleton标注了，那么对应的Component也必须采用@Singleton标注，表明它们的作用域一致，否则编译的时候会报作用域不同的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = &#123;DataModule.class&#125;)</span><br><span class="line">@Singleton//这个Component的@Scope要和对应的Module的@Scope一致</span><br><span class="line">public abstract class SingletonTestComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * /@Component不仅可以注解接口也可以注解抽象类，为了方便测试单例，把Component改为抽象类，</span><br><span class="line">     * 实际开发中可以在Application中创建单例。</span><br><span class="line">     */</span><br><span class="line">    public abstract void inject(SingletonTestActivity singletonTestActivity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SingletonTestComponent必须是单例的，</span><br><span class="line">     * 否则怎么能保证不同的Component对象提供同一个依赖实例呢？</span><br><span class="line">     */</span><br><span class="line">    private static SingletonTestComponent sComponent;</span><br><span class="line"></span><br><span class="line">    public static SingletonTestComponent getInstance() &#123;</span><br><span class="line">        if (sComponent == null) &#123;</span><br><span class="line">            sComponent = DaggerSingletonTestComponent.builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        return sComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新建一个SingletonTestActivity，显示mSingletonTestEntity这个对象，有一个Button用于启动一个新的SingletonTestActivity，这样我们就可以看每次这个mSingletonTestEntity是不是同一个，是的话当然就能说明我们创建的这个实体对象是单例了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//成员变量</span><br><span class="line">@Inject</span><br><span class="line">SingletonTestEntity mSingletonTestEntity;</span><br><span class="line"></span><br><span class="line">//展示mSingletonTestEntity这个对象</span><br><span class="line">mTvShowUser.setText(mSingletonTestEntity.getDesc() + &quot;: &quot; + mSingletonTestEntity);</span><br></pre></td></tr></table></figure><p>上面少了一步，就是初始化注入，我一开始是这么初始化的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerSingletonTestComponent.builder().build().inject(this);</span><br></pre></td></tr></table></figure><p>然后我发现每次启动新的Activity，拿到的SingletonTestEntity不是同一个，让我很困惑，还以为是用的姿势不对。后来研究了一下生成的代码，也查了一些文章，发现真的是我用的姿势不对。初始化依赖注入应该这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingletonTestComponent.getInstance().inject(this);</span><br></pre></td></tr></table></figure><p>这样的话，我们的这个注入器SingletonTestComponent就首先实实在在地变成一个单例了，用这个Component去注入的依赖才是单例的。</p><p>说到这大家可能也看到了，这怎么能是单例呢？我们常规理解的单例是类在虚拟机中只有一个对象。而我们这个依赖实例其实只是每次都由同一个Component注入器对象提供，重新生成一个Component对象的话注入的依赖实例就不再是同一个。</p><p>我们还可以仿造@Singleton自定义一个作用域，如@PerActivity，用来表示跟Activity的生命周期一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface PerActivity &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的用法就不再介绍了，跟@Singleton用法一样，项目中可以看。</p><p><strong>总结一下：想要用Component只提供同一个实例对象，就必须保证Component只初始化一次。</strong></p><h2 id="2-7-重点和难点——组织Component"><a href="#2-7-重点和难点——组织Component" class="headerlink" title="2.7 重点和难点——组织Component"></a>2.7 重点和难点——组织Component</h2><p>通过上述的讲解可以发现，Dagger2也没有想象的那么难啊。但是不得不说，Dagger2入门并不难，想要灵活运用就不容易了。主要的原因就是在实际开发中我们要好好的组织Component，那么多页面，那么多类，我们怎么写Component就有学问了。Component有3种组织方式：</p><ul><li>依赖方式——一个Component可以依赖一个或多个Component，采用的是@Component的<strong>dependencies</strong>属性。</li><li>包含方式——这里就用到了我们<strong>@SubComponent</strong>注解，用@SubComponent标记接口或者抽象类，表示它可以被包含。一个Component可以包含一个或多个Component，而且被包含的Component还可以继续包含其他的Component。说起来跟Activity包含Fragment方式很像。</li><li>继承方式——用一个Component继承另外一个Component。</li></ul><p>下面这张图，是<strong><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">Android-CleanArchitecture</a></strong>项目Component组织方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/2083810-049a5487c6769ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组织方式.png"></p><p>可以看到这么划分的思想是：</p><ul><li>我们需要一个ApplicationComponent，管理在App的全局实例，保证在App生命周期内，对象只有一个。例如网络请求的全局HttpClient。</li><li>ActivityComponent: 负责管理生命周期跟Activity一样的组件。</li><li>UserComponent: 继承于ActivityComponent的组件，通常会在Activity内部的Fragment中使用。</li></ul><p>说到这，我想提一下上面为了演示@Singleton的用法，我们并没有在Application中进行初始化。个人觉得，实际开发中用@Singleton标记来表示在App生命周期内全局的对象，然后用自定义的@PerActivity、@PerFragment等来表示跟Activity、Fragment生命周期一致比较好。</p><p>现在我们采用依赖、包含、继承的方式来演示Component的组织方式。就提供一个全局的ApplicationContext好了，只是演示，没必要那么复杂。</p><p>Module类是这样的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line"></span><br><span class="line">    private final Application application;</span><br><span class="line"></span><br><span class="line">    public AppModule(Application application) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Singleton</span><br><span class="line">    Context getAppContext() &#123;</span><br><span class="line">        return application;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppComponent是这样的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Exposed to sub-graphs.</span><br><span class="line">     * 其他的依赖想要用这个Context，必须显式的暴露。</span><br><span class="line">     * 因为，其它依赖这个的Component需要Context，然后这个Context会去AppModule中找对应的Context</span><br><span class="line">     * 与方法名无关，只与返回类型有关</span><br><span class="line">     * 举个例子：小弟B依赖大哥A,A有一把杀猪刀。哪天小弟碰上事了，找大哥借一把刀，</span><br><span class="line">     * 如果大哥把刀藏起来不给小弟用，小弟会因为找不到刀用很崩溃的。（程序编译报错），</span><br><span class="line">     * 所以必须是大哥把刀拿出来给小弟用，小弟才能拿出去用啊。（代码正常）</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    Context context();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要其它依赖这个AppComponent的Component并使用使用全局的Appliation Context，我们必须显式地暴露出去。</p><p>这个AppComponent接口内没有inject方法，因为具体地注入哪个类，是由依赖它的Component决定的。</p><p>我们自定义Appliation ，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class App extends Application &#123;</span><br><span class="line">    private static AppComponent sAppComponent = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        if (sAppComponent == null) &#123;</span><br><span class="line">            sAppComponent = DaggerAppComponent.builder()</span><br><span class="line">                                              .appModule(new AppModule(this))</span><br><span class="line">                                              .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AppComponent getAppComponent() &#123;</span><br><span class="line">        //向外界的依赖提供这个AppComponent</span><br><span class="line">        return sAppComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再次强调：这个AppConponent只能初始化一次</strong></p><h3 id="2-7-1-依赖"><a href="#2-7-1-依赖" class="headerlink" title="2.7.1 依赖"></a>2.7.1 依赖</h3><p>现在我们有一个ActivityComponent，需要依赖这个AppComponent ，那么写出来是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@PerActivity</span><br><span class="line">//@Singleton //不能与依赖的AppComponent的作用域相同，否则会报错</span><br><span class="line">@Component(dependencies = AppComponent.class, modules = ActModule.class)</span><br><span class="line">public interface ActivityComponent &#123;</span><br><span class="line"></span><br><span class="line">    void inject(DependenceTestActivity DependenceTestActivity);</span><br><span class="line"></span><br><span class="line">    void inject(SubComponentTestActivity subComponentTestActivity);</span><br><span class="line"></span><br><span class="line">    //包含SubComponent,这样的话该SubComponent也可以拿到ActivityComponent中能提供的依赖。</span><br><span class="line">    ActSubComponent getActSubComponent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Component依赖另一个Component，它们的作用域不能相同</strong>。所以我们自定义了一个@PerActivity作用域。<br>我们的这个ActivityComponent本身也可以需要Module提供依赖实例，如ActModule，这个ActModule没有作用域。至于ActEntity的代码，我们就不贴出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class ActModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    ActEntity getActEntity() &#123;</span><br><span class="line">        return new ActEntity(&quot;我是ActEntity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化注入是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DaggerActivityComponent.builder()</span><br><span class="line">                       .appComponent(((App) getApplication()).getAppComponent())</span><br><span class="line">                       .build()</span><br><span class="line">                       .inject(this);</span><br></pre></td></tr></table></figure><h3 id="2-7-2-包含"><a href="#2-7-2-包含" class="headerlink" title="2.7.2 包含"></a>2.7.2 包含</h3><p>上面的ActSubComponent 是被包含，它需要有个@Subcomponent注解，如果是包含的方式，作用域可以与包含它的Component一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Subcomponent</span><br><span class="line">@PerActivity //如果是包含的方式，作用域与上一层的Component相同也没关系。采用依赖的方式就不行。</span><br><span class="line">public interface ActSubComponent &#123;</span><br><span class="line">    void inject(SubFragment subFragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化注入是这个样子：<br>在Activity中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mActivityComponent = DaggerActivityComponent</span><br><span class="line">                    .builder()</span><br><span class="line">                    .appComponent(((App) getApplication()).getAppComponent())</span><br><span class="line">                    .actModule(new ActModule())</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>然后在Fragment中拿到这个mActivityComponent :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((SubComponentTestActivity) getActivity()).getActivityComponent()</span><br><span class="line">                                          .getActSubComponent()</span><br><span class="line">                                          .inject(this);</span><br></pre></td></tr></table></figure><h3 id="2-7-3-继承"><a href="#2-7-3-继承" class="headerlink" title="2.7.3 继承"></a>2.7.3 继承</h3><p>我们的ExtendTestComponent继承了ActivityComponent，那么ActivityComponent中需要的Module我们就必须提供。有的人可能会问ActivityComponent并没有AppModule啊，那是因为ActivityComponent依赖了AppComponent，由AppComponent提供了AppModule。</p><p>ExtendTestComponent有@Singleton标记，这是因为AppModule中有@Singleton作用域。如果ActModule中有一个@PerActivity作用域的话，这个Component必须要再加上@PerActivity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ExtendTestComponent继承了ActivityComponent，</span><br><span class="line"> * 如果ActivityComponent中的modules定义了创建实例的方法，</span><br><span class="line"> * ExtendTestComponent中也必须提供相应的modules。</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;ActModule.class, AppModule.class&#125;)</span><br><span class="line">public interface ExtendTestComponent extends ActivityComponent &#123;</span><br><span class="line">    void inject(ExtendTestActivity extendTestActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化注入是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DaggerExtendTestComponent.builder()</span><br><span class="line">                         .appModule(new AppModule(getApplication()))</span><br><span class="line">                         .actModule(new ActModule())</span><br><span class="line">                         .build()</span><br><span class="line">                         .inject(this);</span><br></pre></td></tr></table></figure><p>哦了，先到这吧。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>通过上面的内容，至少可以了解Dagger2中常用的一些注解以及组织方式，在这里做一下简单的总结：</p><ul><li>@Module提供依赖的优先级高于@Inject</li><li>@Singleton并不是真的能创建单例，但我们依然可以保证在App的生命周期内一个类只存在一个对象。@Singleton更重要的作用是通过标记提醒我们自己来达到更好的管理实例的目的。</li><li>Component的作用域必须与对应的Module作用域一致，如果@Module没有标记作用域，就不影响。</li><li>Component和依赖的Component作用域范围不能一样，否则会报错。一般来讲，我们应该对每个Component都定义不同的作用域。</li><li>由于@Inject，@Module和@Provides注解是分别验证的，所有绑定关系的有效性是在@Component层级验证。（在这里提一下，本文没有讲这个具体过程）</li></ul><p>本文内容都是个人理解与实践，难免有错误和遗漏之处，欢迎指正，共同学习。<br><a href="https://github.com/sososeen09/ThirdPartDemo/tree/dagger2_study1/dagger2" target="_blank" rel="noopener">项目地址</a></p><p><strong>参考文章：</strong></p><ul><li><a href="http://google.github.io/dagger/" target="_blank" rel="noopener">dagger谷歌官方文档</a></li><li><a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="noopener">Tasting Dagger 2 on Android</a>    —— <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html" target="_blank" rel="noopener">对应翻译</a></li><li><a href="http://www.jianshu.com/p/cd2c1c9f68d4" target="_blank" rel="noopener">Android：dagger2让你爱不释手-基础依赖注入框架篇</a></li><li><a href="http://www.jianshu.com/p/1d42d2e6f4a5" target="_blank" rel="noopener">Android：dagger2让你爱不释手-重点概念讲解、融合篇</a></li><li><a href="http://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></li><li><a href="https://dreamerhome.github.io/2016/07/07/dagger/" target="_blank" rel="noopener">依赖注入神器：Dagger2详解系列</a></li><li><a href="http://zpayh.xyz/2016/07/07/Dagger2%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Dagger2使用详解</a></li><li><a href="http://blog.zhaiyifan.cn/2016/03/27/android-new-project-from-0-p4/" target="_blank" rel="noopener">从零开始的Android新项目4 - Dagger2篇</a></li><li><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="noopener">Dagger2图文完全教程</a></li><li><a href="http://blog.csdn.net/u012943767/article/details/51954939" target="_blank" rel="noopener">Dagger2 彻底了解如何构建依赖关系</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Dagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码分析之消息机制Handler</title>
      <link href="/2016/06/23/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6Handler/"/>
      <url>/2016/06/23/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6Handler/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>Handler在Android开发中使用的比较多，通常Handler是在主线程中创建，子线程拿到这个Handler向主线程中发送消息。</p><blockquote><p>那么如果需要主线程中向子线程中发送消息呢？</p></blockquote><p>本文只是提出这个问题，并不在此提供实现这种场景的例子，写这篇文章的目的主要是理解Handler的运行原理，以便更好、更灵活的运用Handler。</p><h1 id="2-Android消息机制简介"><a href="#2-Android消息机制简介" class="headerlink" title="2 Android消息机制简介"></a>2 Android消息机制简介</h1><ol><li>Android的消息机制主要是指Handler的运行机制，Handler的运行依赖于MessageQueue和Looper，当然，既然是消息机制，通常也需要用到Message。</li><li>Handler、Looper、MessageQueue和Message的工作原理就像是生产线，Looper是发动机，MessageQueue就是传送带，Handler是工人，Message就是待处理的产品</li></ol><h1 id="3-Handler的工作流程"><a href="#3-Handler的工作流程" class="headerlink" title="3 Handler的工作流程"></a>3 Handler的工作流程</h1><p>一个应用的启动需要有main方法作为启动的入口，在Android中这个main方法在ActivityThread类中，查看这个类的main方法可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static final void main(String[] args) &#123;</span><br><span class="line">        //省略无关代码</span><br><span class="line">        ...</span><br><span class="line">        //主线程中调用Looper.prepareMainLooper()方法创建Looper</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = new Handler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    //主线程中调用Looper.loop()，开始轮询，取消息</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        if (Process.supportsProcesses()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-Looper轮询器"><a href="#3-1-Looper轮询器" class="headerlink" title="3.1 Looper轮询器"></a>3.1 Looper轮询器</h2><p>在ActivityThread的main方法中首先调用Looper.prepareMainLooper()方法，我们来看一下，这个方法中做了哪些工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Looper类中</span><br><span class="line">public static final void prepareMainLooper() &#123;</span><br><span class="line">     prepare();</span><br><span class="line">     setMainLooper(myLooper());</span><br><span class="line">     if (Process.supportsProcesses()) &#123;</span><br><span class="line">        myLooper().mQueue.mQuitAllowed = false;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中首先调用本类中的prepare()方法，这个方法的主要作用是创建Looper对象，并且把该对象绑定到当前线程中，在这里既然是主线程调用的，那么该Looper对象也就是在主线程当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Looper类中</span><br><span class="line">public static final void prepare() &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //把Looper绑定到当前线程</span><br><span class="line">    sThreadLocal.set(new Looper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Looper的构造方法中，我们可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Looper() &#123;</span><br><span class="line">    //创建消息队列</span><br><span class="line">    mQueue = new MessageQueue();</span><br><span class="line">    mRun = true;</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Looper这个类的构造方法是私有的，也就是说不允许外界直接new出来Looper对象。在创建Looper的时候，同时创建了一个消息队列MessageQueue。</p><blockquote><p>所以请注意，消息队列MessageQueue是在Looper创建的时候，同时创建的</p></blockquote><p>通过调用Looper.loop()方法，开始轮询消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static final void loop() &#123;</span><br><span class="line">     Looper me = myLooper();</span><br><span class="line">     //通过拿到Looper对象，取获取与之对应的消息队列MessageQueue</span><br><span class="line">     MessageQueue queue = me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">     //通过死循环方式去取消息</span><br><span class="line">     while (true) &#123;</span><br><span class="line">         //调用MessageQueue的next()方法取消息，这个过程也是死循环</span><br><span class="line">         Message msg = queue.next(); // might block</span><br><span class="line">         </span><br><span class="line">         if (msg != null) &#123;</span><br><span class="line">             ...</span><br><span class="line">             //取到消息之后，交给发送该消息的Handler取处理消息</span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">            ...</span><br><span class="line">             //回收消息，在Message中维护的有一个消息池</span><br><span class="line">             msg.recycle();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过上述简单的叙述，我们可以明白，在Activity启动的时候创建的一个与主线程相关的Looper和对应的消息队列MessageQueue，并且通过消息队列通过阻塞的方式去取消息。</p><h2 id="3-2-Handler的工作过程"><a href="#3-2-Handler的工作过程" class="headerlink" title="3.2 Handler的工作过程"></a>3.2 Handler的工作过程</h2><p>Handler的工作过程主要包含发送消息和处理消息。Handler的构造方法有多个，他们的共同点是均会获取当前线程的Looper对象和消息队列MessageQueue对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//Handler的构造方法1</span><br><span class="line">public Handler() &#123;</span><br><span class="line">    ...</span><br><span class="line">    //获取当前线程的Looper对象</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    if (mLooper == null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取消息队列对象</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Handler的构造方法2</span><br><span class="line">public Handler(Callback callback) &#123;</span><br><span class="line">   ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    if (mLooper == null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Handler的构造方法3</span><br><span class="line">public Handler(Looper looper) &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Handler的构造方法4</span><br><span class="line">public Handler(Looper looper, Callback callback) &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息可以通过一系列send方法，也可以通过一系列post方法，不过post方法最终还是通过send方法去实现。<br>用send方法，最终也会调用一个方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//在Handler中</span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis)</span><br><span class="line">&#123;</span><br><span class="line">    boolean sent = false;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    if (queue != null) &#123;</span><br><span class="line">        //调用msg.target的方法把Message和发送它的Handler绑定，所以Looper能够把正确的Message交给发送它的Handler处理</span><br><span class="line">        msg.target = this;</span><br><span class="line">        //调用MessageQueue的enqueueMessage方法把消息加入消息队列</span><br><span class="line">        sent = queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">            this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    return sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Handler发送消息的过程就是向消息队列中插入一条消息。前面已经讲到，MessageQueue调用next方法去轮询消息，那么当MessageQueue拿到消息之后，把消息传递给Looper，最终交给Handler去处理，即dispatchMessage方法会被调用。此时，Handler开始处理消息。值得一提的是，在消息队列中可能有不同Handler发送的多个消息，通过在发送消息的时候把Message和发送它的Handler绑定，Looper就会把消息正确的交给发送它的Handler来处理。dispatchMessage方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Handler中</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler处理消息的过程如下：</p><ol><li><p>查看Message的callback是否为null，不为null的话就通过handleCallback(msg)方法处理消息。这里的callback实际上就是一个Runnable对象，如果以post方式去发送消息，最终就会调用handleCallback(msg)方法去处理，这个方法内容为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final void handleCallback(Message message) &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检查mCallBack是否为null，如果不为null就调用mCallBack的handleMessage(msg)方法。这个mCallBack是CallBack接口的子类对象，前面已经说过Handler的构造方法中有两个可以用到这个CallBack。</p></li><li>如果mCallBack为null，最终就会调用Handler的handleMessage(msg)方法，这个方法通常是在创建Handler时被使用者重写的方法。</li></ol><p><strong>需要说明的是：在主线程当前我们创建Handler时并没有自己创建Looper对象，这是因为主线程已经为我们创建好了；如果要在子线程当前创建Handler，一定要在之前创建Looper对象，即调用Looper.prepare()方法。</strong></p><h2 id="3-3-MessageQueue消息队列"><a href="#3-3-MessageQueue消息队列" class="headerlink" title="3.3 MessageQueue消息队列"></a>3.3 MessageQueue消息队列</h2><p>前面的内容已经讲了很多关于MessageQueue的东西，这里也就不再赘述，MessageQueue主要包含两个操作：插入消息（enqueueMessage方法）和读取消息（next方法）。读取的过程也伴随着删除操作。MessageQueue的的内部实际上是通过一个单链表的数据结构来维护消息列表，这主要也是因为单链表在插入和删除上比较有优势。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   final boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    ...</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // 当前发送的message需要马上被处理调，needWake唤醒状态置true</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; // new head, might need to wake up</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">              // 当前发送的message被排队到其他message的后面，needWake唤醒状态置为false</span><br><span class="line">                Message prev = null;</span><br><span class="line">                while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = prev.next;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">                needWake = false; // still waiting on head, no need to wake up</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否唤醒主线程</span><br><span class="line">    if (needWake) &#123;</span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueMessage的主要操作其实就是单链表的插入操作，根据时间看当前发送的Message是否需要马上处理。这个enqueueMessage方法是Handler发送消息的时候调用。</p><p>下面来看next方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final Message next() &#123;</span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            final Message msg = mMessages;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                final long when = msg.when;</span><br><span class="line">                if (now &gt;= when) &#123;</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    mMessages = msg.next;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (Config.LOGV) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，next方法返回一个Message对象。next方法中也是采用阻塞的方式去获取消息队列中的消息，一旦有消息立即返回并且将它从单链表中移除。如果没有消息就一直阻塞。前面已经提到，这个取消息的next方法是在Looper的loop()方法中调用。</p><h2 id="3-4-Message消息载体"><a href="#3-4-Message消息载体" class="headerlink" title="3.4 Message消息载体"></a>3.4 Message消息载体</h2><p>Message只有一个无参构造方法，但是Message有多个obtain静态方法来返回Message对象。</p><p>采用哪种方式创建Message对象都可以，但是建议采用obtain方法来创建。这是因为Message通过在内部构建一个链表来维护一个被回收的Message对象池。当用户调用obtain方法时会优先从池中获取，如果池中没有则创建新的Message对象。同时在使用完毕之后，进入池中以便于复用。这个在Looper.loop()方法可以看到一点端倪，在使用完毕时候调用了Message的recycle()方法。<br>下面是obtain方法创建Message对象的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h1><ul><li>在应用启动时，会开启一个主线程（即UI线程）,会创建一个Looper对象，并把该对象绑定到主线程中。Looper对象被封装在ThreadLocal中，使得不同线程间的Looper不能共享</li><li>创建Looper时同时创建了MessageQueue消息队列对象</li><li>Handler通过send方法或者post方法，把消息加入消息队列MessageQueue中</li><li>主线程中调用Looper的loop()方法，会开启消息循环，不断的从消息队列中取出消息</li><li>Looper拿到消息之后调用Handler的dispatchMessage方法来处理消息</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
